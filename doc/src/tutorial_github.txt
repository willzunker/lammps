"LAMMPS WWW Site"_lws - "LAMMPS Documentation"_ld - "LAMMPS Commands"_lc :c

:link(lws,http://lammps.sandia.gov)
:link(ld,Manual.html)
:link(lc,Section_commands.html#comm)

:line

LAMMPS GitHub tutorial :h3
[written by Stefan Paquay]

:line

This document briefly describes how to use GitHub to merge changes you
make into LAMMPS, using GitHub. It assumes that you are familiar with
git. You may want to have a look at the "Git
book"_http://git-scm.com/book/ to reacquaint yourself.

:line

[Making an account]

First of all, you need a GitHub account. This is fairly simple, just
go to "GitHub"_https://github.com and create an account by clicking
the "Sign up for GitHub" button. Once your account is created, you
can sign in by clicking the button in the top left and filling in your
username or e-mail address and password.

:line

[Forking the repository]

To get changes into LAMMPS, you need to first fork the repository. At
the time of writing, master is the preferred branch. Go to "LAMMPS
on GitHub"_https://github.com/lammps/lammps and make sure branch is
set to "master", see the figure below.

:c,image(JPG/tutorial_branch.png)

If it is not, use the button to change it to master. Once it is, use the
fork button to create a fork.

:c,image(JPG/tutorial_fork.png)


This will create your own fork of the LAMMPS repository. You can make
changes in this fork and later file {pull requests} to allow the
upstream repository to merge changes from your own fork into the one
we just forked from. At the same time, you can set things up, so you
can include changes from upstream into your repository.

:line

[Adding changes to your own fork]

Additions to the upstream version of LAMMPS are handled using {feature branches}.
For every new feature, a so-called feature branch is created, which contains only
those modification relevant to one specific feature. For example, adding a single
fix would consist of creating a branch with only the fix header and source file
and nothing else.
It is explained in more detail here: "feature branch
workflow"_https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow.

[Feature branches]

First of all, create a clone of your version on github on your local machine via HTTPS

  $ git clone https://github.com/<your user name>/lammps.git <some name> :pre

or, if you have SSH keys setup, using your SSH key:

  $ git clone git@github.com:<your user name>/lammps.git :pre
  
You can find the proper url by clicking the "Clone or download"-button:

:c,image(JPG/tutorial_https_block.png)

The above command copies ("clones") the git repository to your local
machine to a directory with the name you chose. If none is given, it will
default to "lammps". Typical names are "mylammps" or something similar.

You can use this local clone to make changes and
test them without interfering with the repository on Github.

To pull changes from upstream into this copy, you can go to the directory
and use git pull:

  $ cd mylammps :pre
  $ git pull https://github.com/lammps/lammps :pre

You can also add this url as a remote:

  $ git remote add lammps_upstream https://www.github.com/lammps/lammps :pre

At this point, you typically make a feature branch for the feature you
want to work on. This tutorial contains the workflow that updated this
tutorial, and hence we will call the branch "github-tutorial-update":

  $ git checkout -b github-tutorial-update :pre

Now that we have changed branches, we can make our changes to our local
repository. Just remember that if you want to start working on another,
unrelated feature, you should switch branches!

[After changes are made]

After everything is done, add the files to the branch and commit them:

  $ git add doc/src/tutorial_github.txt
  $ git add doc/src/JPG/tutorial_*.png :pre

[Warning]

{"Do not use "git commit -a".  the -a flag will automatically include
*all* modified or new files.  mercurial does that and it find it
hugely annoying and often leading to accidental commits of files you
don't want.  use git add, git rm, git mv for adding, removing,
renaming and then git commit to finalize the commit.  personally, i
find it very convenient to use the bundled gui for commits, i.e. git
gui.  typically, i will do git add and other operations, but then
verify and review them with git gui.  git gui also allows to do
line-by-line unstaging and other convenient operations." - Axel}

After adding all files, the change can be commited with some useful message
that explains the change.

  $ git commit -m 'Finally updated the github tutorial' :pre

After the commit, the changes can be pushed to the same branch on GitHub:

$ git push :pre

Git will ask you for your user name and password on GitHub if you have
not configured anything. If your local branch is not present on Github yet,
it will ask you to add it by running

  $ git push --set-upstream origin github-tutorial-update :pre

If you correctly type your user name and
password, the feature branch should be added to your fork on GitHub.

If you want to make really sure you push to the right repository
(which is good practice), you can provide it explicitly:

$ git push origin :pre

or using an explicit URL:

$ git push git@github.com:Pakketeretet2/lammps.git :pre

[Filing a pull request]
Up to this point in the tutorial, all changes were to {your} clones of LAMMPS.
Eventually, however, you want this feature to be included again upstream.
To do this, you will want to file a pull request by clicking on the
"New pull request" button:

:c,image(JPG/tutorial_new_pull_request.png)

Make sure that the current branch is set to the correct one, which, in
this case, is "github-tutorial-update". If done correctly, the only
changes you will see are those that were made on this branch.

This will open up a new window that lists changes made to the
repository. If you are just adding new files, there is not much to do,
but I suppose merge conflicts are to be resolved here if there are
changes in existing files. If all changes can automatically be merged,
green text at the top will say so and you can click the "Create pull
request" button, see image.

:c,image(JPG/tutorial_create_new_pull_request1.png)

After this you have to specify a short title and a comment with
details about your pull request. I guess here you write what your
modifications do and why they should be incorporated upstream. After
that, click the "Create pull request" button, see image below.

Now just write some nice comments, click "Comment", and that is it. It
is now up to the maintainer(s) of the upstream repository to
incorporate the changes into the repository and to close the pull
request.

:c,image(JPG/tutorial_create_new_pull_request2.png)

You will notice some that some checks are performed automatically:

:c,image(JPG/tutorial_automated_checks.png)



:line

[Additional changes]

Before the pull request is accepted, any additional changes you push
into your repository will automatically become part of the pull
request.

:line

[After a merge]

When everything is fine the feature branch is merged into the LAMMPS
repositories:

:c,image(JPG/tutorial_merged.png)

Now one question remains: What to do with the feature branch that got
merged into upstream?

It is in principle safe to delete them from your own fork. This helps
keep it a bit more tidy. Note that you first have to switch to another
branch!

$ git checkout master
$ git pull master
$ git branch -d github-tutorial-update :pre

If you do not pull first, it is not really a problem but git will warn
you at the next statement that you are deleting a local branch that
was not yet fully merged into HEAD. This is because git does not yet
know your branch just got merged into lammps-icms upstream. If you
first delete and then pull, everything should still be fine.

Finally, if you delete the branch locally, you might want to push this
to your remote(s) as well:

$ git push origin :github-tutorial-update :pre

[Recent changes in the workflow]

Some changes to the workflow are not captured in this tutorial.
For example, in addition to the master branch, to which all
new features should be submitted, there is now also an "unstable"
and a "stable" branch. Furthermore, the naming of the patches
now follow the pattern "patch_<Day><Month><Year>" so simplify
comparisons between releases.
Finally, all patches and submissions are subject to automatic
testing and code checks to make sure they at the very least
compile.
