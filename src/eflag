angle.cpp:/* ----------------------------------------------------------------------
angle.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
angle.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
angle.cpp:------------------------------------------------------------------------- */
angle.cpp:/* ---------------------------------------------------------------------- */
angle.cpp:/* ---------------------------------------------------------------------- */
angle.cpp:/* ----------------------------------------------------------------------
angle.cpp:------------------------------------------------------------------------- */
angle.cpp:/* ----------------------------------------------------------------------
angle.cpp:------------------------------------------------------------------------- */
angle.cpp:  eflag_atom = eflag / 2;
angle.cpp:  vflag_atom = vflag / 4;
angle.cpp:  // reallocate per-atom arrays if necessary
angle.cpp:  // zero accumulators
angle.cpp:/* ----------------------------------------------------------------------
angle.cpp:------------------------------------------------------------------------- */
angle.cpp:/* ---------------------------------------------------------------------- */
angle_hybrid.cpp:/* ----------------------------------------------------------------------
angle_hybrid.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
angle_hybrid.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
angle_hybrid.cpp:------------------------------------------------------------------------- */
angle_hybrid.cpp:/* ---------------------------------------------------------------------- */
angle_hybrid.cpp:/* ---------------------------------------------------------------------- */
angle_hybrid.cpp:/* ---------------------------------------------------------------------- */
angle_hybrid.cpp:  // save ptrs to original anglelist
angle_hybrid.cpp:  // if this is re-neighbor step, create sub-style anglelists
angle_hybrid.cpp:  // nanglelist[] = length of each sub-style list
angle_hybrid.cpp:  // realloc sub-style anglelist if necessary
angle_hybrid.cpp:  // load sub-style anglelist with 4 values from original anglelist
angle_hybrid.cpp:  // call each sub-style's compute function
angle_hybrid.cpp:  // set neighbor->anglelist to sub-style anglelist before call
angle_hybrid.cpp:  // accumulate sub-style global/peratom energy/virial in hybrid
angle_hybrid.cpp:  // restore ptrs to original anglelist
angle_hybrid.cpp:/* ---------------------------------------------------------------------- */
angle_hybrid.cpp:/* ----------------------------------------------------------------------
angle_hybrid.cpp:------------------------------------------------------------------------- */
angle_hybrid.cpp:  // delete old lists, since cannot just change settings
angle_hybrid.cpp:  // count sub-styles by skipping numeric args
angle_hybrid.cpp:  // one exception is 1st arg of style "table", which is non-numeric word
angle_hybrid.cpp:  // need a better way to skip these exceptions
angle_hybrid.cpp:  // allocate list of sub-styles
angle_hybrid.cpp:  // allocate each sub-style and call its settings() with subset of args
angle_hybrid.cpp:  // allocate uses suffix, but don't store suffix version in keywords,
angle_hybrid.cpp:  //   else syntax in coeff() will not match
angle_hybrid.cpp:  // define subset of args for a sub-style by skipping numeric args
angle_hybrid.cpp:  // one exception is 1st arg of style "table", which is non-numeric
angle_hybrid.cpp:  // need a better way to skip these exceptions
angle_hybrid.cpp:/* ----------------------------------------------------------------------
angle_hybrid.cpp:---------------------------------------------------------------------- */
angle_hybrid.cpp:  // 2nd arg = angle sub-style name
angle_hybrid.cpp:  // allow for "none" or "skip" as valid sub-style name
angle_hybrid.cpp:  // move 1st arg to 2nd arg
angle_hybrid.cpp:  // just copy ptrs, since arg[] points into original input line
angle_hybrid.cpp:  // invoke sub-style coeff() starting with 1st arg
angle_hybrid.cpp:  // set setflag and which type maps to which sub-style
angle_hybrid.cpp:  // if sub-style is skip: auxiliary class2 setting in data file so ignore
angle_hybrid.cpp:  // if sub-style is none: set hybrid setflag, wipe out map
angle_hybrid.cpp:/* ----------------------------------------------------------------------
angle_hybrid.cpp:------------------------------------------------------------------------- */
angle_hybrid.cpp:/* ----------------------------------------------------------------------
angle_hybrid.cpp:------------------------------------------------------------------------- */
angle_hybrid.cpp:/* ----------------------------------------------------------------------
angle_hybrid.cpp:------------------------------------------------------------------------- */
angle_hybrid.cpp:/* ----------------------------------------------------------------------
angle_hybrid.cpp:------------------------------------------------------------------------- */
angle_hybrid.cpp:/* ---------------------------------------------------------------------- */
angle_hybrid.cpp:/* ----------------------------------------------------------------------
angle_hybrid.cpp:------------------------------------------------------------------------- */
angle_zero.cpp:/* ----------------------------------------------------------------------
angle_zero.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
angle_zero.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
angle_zero.cpp:------------------------------------------------------------------------- */
angle_zero.cpp:/* ----------------------------------------------------------------------
angle_zero.cpp:------------------------------------------------------------------------- */
angle_zero.cpp:/* ---------------------------------------------------------------------- */
angle_zero.cpp:/* ---------------------------------------------------------------------- */
angle_zero.cpp:/* ---------------------------------------------------------------------- */
angle_zero.cpp:/* ---------------------------------------------------------------------- */
angle_zero.cpp:/* ---------------------------------------------------------------------- */
angle_zero.cpp:/* ----------------------------------------------------------------------
angle_zero.cpp:------------------------------------------------------------------------- */
angle_zero.cpp:  // convert theta0 from degrees to radians
angle_zero.cpp:    theta0[i] = theta0_one/180.0 * MY_PI;
angle_zero.cpp:/* ---------------------------------------------------------------------- */
angle_zero.cpp:/* ----------------------------------------------------------------------
angle_zero.cpp:------------------------------------------------------------------------- */
angle_zero.cpp:/* ----------------------------------------------------------------------
angle_zero.cpp:------------------------------------------------------------------------- */
angle_zero.cpp:/* ----------------------------------------------------------------------
angle_zero.cpp:------------------------------------------------------------------------- */
angle_zero.cpp:    fprintf(fp,"%d %g\n",i,theta0[i]/MY_PI*180.0);
angle_zero.cpp:/* ---------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
atom.cpp:/* ---------------------------------------------------------------------- */
atom.cpp:  // initialize atom arrays
atom.cpp:  // customize by adding new array
atom.cpp:  // USER-SPIN
atom.cpp:  // USER-DPD
atom.cpp:  // USER-SMD
atom.cpp:  // molecular info
atom.cpp:  // user-defined molecules
atom.cpp:  // custom atom arrays
atom.cpp:  // initialize atom style and array existence flags
atom.cpp:  // customize by adding new flag
atom.cpp:  //Magnetic flags
atom.cpp:  // USER-SMD
atom.cpp:  // Peridynamic scale factor
atom.cpp:  // ntype-length arrays
atom.cpp:  // callback lists & extra restart info
atom.cpp:  // default atom ID and mapping values
atom.cpp:/* ---------------------------------------------------------------------- */
atom.cpp:  // delete atom arrays
atom.cpp:  // customize by adding new array
atom.cpp:  // delete custom atom arrays
atom.cpp:  // delete user-defined molecules
atom.cpp:  // delete per-type arrays
atom.cpp:  // delete extra arrays
atom.cpp:  // delete mapping data structures
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // unset atom style and array existence flags
atom.cpp:  // may have been set by old avec
atom.cpp:  // customize by adding new flag
atom.cpp:  //Magnetic flags
atom.cpp:  // create instance of AtomVec
atom.cpp:  // use grow() to initialize atom-based arrays to length 1
atom.cpp:  //   so that x[0][0] can always be referenced even if proc has no atoms
atom.cpp:    if (sflag == 1) sprintf(estyle,"%s/%s",style,lmp->suffix);
atom.cpp:    else sprintf(estyle,"%s/%s",style,lmp->suffix2);
atom.cpp:  // if molecular system:
atom.cpp:  // atom IDs must be defined
atom.cpp:  // force atom map to be created
atom.cpp:  // map style may be reset by map_init() and its call to map_style_set()
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix);
atom.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix2);
atom.cpp:  //printf("test entries function: %s, %d, %d \n ",style, trysuffix, &sflag);
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ---------------------------------------------------------------------- */
atom.cpp:  // delete extra array since it doesn't persist past first run
atom.cpp:  // check arrays that are atom type in length
atom.cpp:  // setup of firstgroup
atom.cpp:  // init AtomVec
atom.cpp:/* ---------------------------------------------------------------------- */
atom.cpp:  // setup bins for sorting
atom.cpp:  // cannot do this in init() because uses neighbor cutoff
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // maxtag_all = max tag for all atoms
atom.cpp:  // DEBUG: useful for generating 64-bit IDs even for small systems
atom.cpp:  // use only when LAMMPS is compiled with BIGBIG
atom.cpp:  //maxtag_all += 1000000000000;
atom.cpp:  // notag = # of atoms I own with no tag (tag = 0)
atom.cpp:  // notag_sum = # of total atoms on procs <= me with no tag
atom.cpp:  // itag = 1st new tag that my untagged atoms should use
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // set bounds for my proc
atom.cpp:  // if periodic and I am lo/hi proc, adjust bounds by EPSILON
atom.cpp:  // insures all data atoms will be owned even with round-off
atom.cpp:  // xptr = which word in line starts xyz coords
atom.cpp:  // iptr = which word in line starts ix,iy,iz image flags
atom.cpp:  // loop over lines of atom data
atom.cpp:  // tokenize the line into values
atom.cpp:  // extract xyz coords and image flags
atom.cpp:  // remap atom into simulation box
atom.cpp:  // if atom is in my sub-domain, unpack its values
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // loop over lines of atom velocities
atom.cpp:  // tokenize the line into values
atom.cpp:  // if I own atom tag, unpack its values
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // loop over lines of bonus atom data
atom.cpp:  // tokenize the line into values
atom.cpp:  // if I own atom tag, unpack its values
atom.cpp:    // ok to call child's data_atom_bonus() method thru parent avec_bonus,
atom.cpp:    // since data_bonus() was called with child ptr, and method is virtual
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // loop over lines of body data
atom.cpp:  // if I own atom tag, tokenize lines into ivalues/dvalues, call data_body()
atom.cpp:  // else skip values
atom.cpp:      nvalues = ninteger + ndouble;    // number of values to skip
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:   init per-atom fix/compute/variable values for newly created atoms
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // 1st molecule in set stores nset = # of mols, others store nset = 0
atom.cpp:  // ifile = count of molecules in set
atom.cpp:  // index = argument index where next molecule starts, updated by constructor
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:    rmass[ilocal] = 4.0*MY_PI/3.0 *
atom.cpp:    body[ilocal] = 0;     // as if a body read from data file
atom.cpp:  // add bond topology info
atom.cpp:  // for molecular atom styles, but not atom style template
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // insure there is one extra atom location at end of arrays for swaps
atom.cpp:  // loop over owned atoms
atom.cpp:  // nfirst = index of first atom not in firstgroup
atom.cpp:  // when find firstgroup atom out of place, swap it with atom nfirst
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:   don't have to worry about clearing/setting atom->map since done in comm
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // set next timestep for sorting to take place
atom.cpp:  nextsort = (update->ntimestep/sortfreq)*sortfreq + sortfreq;
atom.cpp:  // re-setup sort bins if needed
atom.cpp:  // reallocate per-atom vectors if needed
atom.cpp:  // insure there is one extra atom location at end of arrays for swaps
atom.cpp:  // bin atoms in reverse order so linked list will be in forward order
atom.cpp:  // permute = desired permutation of atoms
atom.cpp:  // permute[I] = J means Ith new atom will be Jth old atom
atom.cpp:  // current = current permutation, just reuse next vector
atom.cpp:  // current[I] = J means Ith current atom is Jth old atom
atom.cpp:  // reorder local atom list, when done, current = permute
atom.cpp:  // perform "in place" using copy() to extra atom location at end of list
atom.cpp:  // inner while loop processes one cycle of the permutation
atom.cpp:  // copy before inner-loop moves an atom to end of atom list
atom.cpp:  // copy after inner-loop moves atom at end of list back into list
atom.cpp:  // empty = location in atom list that is currently empty
atom.cpp:  // sanity check that current = permute
atom.cpp:  //int flag = 0;
atom.cpp:  //for (i = 0; i < nlocal; i++)
atom.cpp:  //  if (current[i] != permute[i]) flag = 1;
atom.cpp:  //int flagall;
atom.cpp:  //MPI_Allreduce(&flag,&flagall,1,MPI_INT,MPI_SUM,world);
atom.cpp:  //if (flagall) error->all(FLERR,"Atom sort did not operate correctly");
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // binsize:
atom.cpp:  // user setting if explicitly set
atom.cpp:  // default = 1/2 of neighbor cutoff
atom.cpp:  // check if neighbor cutoff = 0.0
atom.cpp:  double bininv = 1.0/binsize;
atom.cpp:  // nbin xyz = local bins
atom.cpp:  // bbox lo/hi = bounding box of my sub-domain
atom.cpp:  bininvx = nbinx / (bboxhi[0]-bboxlo[0]);
atom.cpp:  bininvy = nbiny / (bboxhi[1]-bboxlo[1]);
atom.cpp:  bininvz = nbinz / (bboxhi[2]-bboxlo[2]);
atom.cpp:  // reallocate per-bin memory if needed
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // find the fix
atom.cpp:  // if find NULL ptr:
atom.cpp:  //   it's this one, since it is being replaced and has just been deleted
atom.cpp:  //   at this point in re-creation
atom.cpp:  // if don't find NULL ptr:
atom.cpp:  //   i is set to nfix = new one currently being added at end of list
atom.cpp:  // add callback to lists, reallocating if necessary
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:  // compact the list of callbacks
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:   return index if found, and flag = 0/1 for int/double
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:   add a custom variable with name of type flag = 0/1 for int/double
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:   remove a custom variable of type flag = 0/1 for int/double at index
atom.cpp:   ivector/dvector and iname/dname lists never shrink
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom.cpp:/* ----------------------------------------------------------------------
atom.cpp:------------------------------------------------------------------------- */
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_map.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_map.cpp:------------------------------------------------------------------------- */
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:------------------------------------------------------------------------- */
atom_map.cpp:  // check for new map style if max atomID changed (check = 1 = default)
atom_map.cpp:  // recreate = 1 if must delete old map and create new map
atom_map.cpp:  // recreate = 0 if can re-use old map w/out realloc and just adjust settings
atom_map.cpp:  // map_maxarray/map_nhash initially -1, to force recreate even when no atoms
atom_map.cpp:  // if not recreating:
atom_map.cpp:  // for array, initialize current map_tag_max values
atom_map.cpp:  // for hash, set all buckets to empty, put all entries in free list
atom_map.cpp:  // recreating: delete old map and create new one for array or hash
atom_map.cpp:      // map_nhash = max # of atoms that can be hashed on this proc
atom_map.cpp:      // set to max of ave atoms/proc or atoms I can store
atom_map.cpp:      // multiply by 2, require at least 1000
atom_map.cpp:      // doubling means hash table will need to be re-init only rarely
atom_map.cpp:      int nper = static_cast<int> (natoms/comm->nprocs);
atom_map.cpp:      // map_nbucket = prime just larger than map_nhash
atom_map.cpp:      // next_prime() should be fast enough,
atom_map.cpp:      //   about 10% of odd integers are prime above 1M
atom_map.cpp:      // set all buckets to empty
atom_map.cpp:      // set hash to map_nhash in length
atom_map.cpp:      // put all hash entries in free list and point them to each other
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:------------------------------------------------------------------------- */
atom_map.cpp:      // search for key
atom_map.cpp:      // if don't find it, done
atom_map.cpp:      // delete the hash entry and add it to free list
atom_map.cpp:      // special logic if entry is 1st in the bucket
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:------------------------------------------------------------------------- */
atom_map.cpp:    // possible reallocation of sametag must come before loop over atoms
atom_map.cpp:    // since loop sets sametag
atom_map.cpp:    // if this proc has more atoms than hash table size, call map_init()
atom_map.cpp:    //   call with 0 since max atomID in system has not changed
atom_map.cpp:    // possible reallocation of sametag must come after map_init(),
atom_map.cpp:    //   b/c map_init() may invoke map_delete(), whacking sametag
atom_map.cpp:      // search for key
atom_map.cpp:      // if found it, just overwrite local value with index
atom_map.cpp:      // take one entry from free list
atom_map.cpp:      // add the new global/local pair as entry at end of bucket list
atom_map.cpp:      // special logic if this entry is 1st in bucket
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:------------------------------------------------------------------------- */
atom_map.cpp:    // search for key
atom_map.cpp:    // if found it, just overwrite local value with index
atom_map.cpp:    // take one entry from free list
atom_map.cpp:    // add the new global/local pair as entry at end of bucket list
atom_map.cpp:    // special logic if this entry is 1st in bucket
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:------------------------------------------------------------------------- */
atom_map.cpp:  // map_tag_max = max ID of any atom that will be in new map
atom_map.cpp:  // map_tag_max = -1 if no atoms
atom_map.cpp:  // set map_style for new map
atom_map.cpp:  // if user-selected, use that setting
atom_map.cpp:  // else if map_tag_max > 1M, use hash
atom_map.cpp:  // else use array
atom_map.cpp:  // recreate = 1 if must create new map b/c map_style changed
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:------------------------------------------------------------------------- */
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:------------------------------------------------------------------------- */
atom_map.cpp:/* ----------------------------------------------------------------------
atom_map.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_atomic.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ---------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_atomic.cpp:/* ----------------------------------------------------------------------
atom_vec_atomic.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_body.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:  // size_forward and size_border set in settings(), via Body class
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:  // max size of forward/border comm
atom_vec_body.cpp:  // 7,16 are packed in pack_comm/pack_border
atom_vec_body.cpp:  // bptr values = max number of additional ivalues/dvalues from Body class
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:  // if deleting atom J via delflag and J has bonus data, then delete it
atom_vec_body.cpp:  // if atom I has bonus data, reset I's bonus.ilocal to loc J
atom_vec_body.cpp:  // do NOT do this if self-copy (I=J) since I's bonus data is already deleted
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:      // corresponding put() calls are in clear_bonus()
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:      // corresponding put() calls are in clear_bonus()
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:      // corresponding put() calls are in clear_bonus()
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:    else m += (bonus[j].ninteger+1)/2;
atom_vec_body.cpp:/* ---------------------------------------------------------------------- */
atom_vec_body.cpp:    // corresponding put() calls are in copy()
atom_vec_body.cpp:    else m += (bonus[nlocal_bonus].ninteger+1)/2;
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:      else n += (bonus[body[i]].ninteger+1)/2;
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:    else m += (bonus[j].ninteger+1)/2;
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:    else m += (bonus[nlocal_bonus].ninteger+1)/2;
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:   body computes its size based on ivalues/dvalues and returns it
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/* ----------------------------------------------------------------------
atom_vec_body.cpp:   debug method for sanity checking of own/bonus data pointers
atom_vec_body.cpp:------------------------------------------------------------------------- */
atom_vec_body.cpp:/*
atom_vec_body.cpp:*/
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_charge.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ---------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec_charge.cpp:/* ----------------------------------------------------------------------
atom_vec_charge.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ---------------------------------------------------------------------- */
atom_vec.cpp:/* ---------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:  nmax = nmax/DELTA * DELTA;
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:  nmax_bonus = nmax_bonus/DELTA_BONUS * DELTA_BONUS;
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:   do not count/pack bonds with bondtype = 0
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:   do not count/pack angles with angletype = 0
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec.cpp:/* ----------------------------------------------------------------------
atom_vec.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_ellipsoid.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:  // if deleting atom J via delflag and J has bonus data, then delete it
atom_vec_ellipsoid.cpp:  // if atom I has bonus data, reset I's bonus.ilocal to loc J
atom_vec_ellipsoid.cpp:  // do NOT do this if self-copy (I=J) since I's bonus data is already deleted
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:  // reset ellipsoid mass
atom_vec_ellipsoid.cpp:  // previously stored density in rmass
atom_vec_ellipsoid.cpp:  rmass[m] *= 4.0*MY_PI/3.0 * shape[0]*shape[1]*shape[2];
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:      buf[i][3] = rmass[i] / (4.0*MY_PI/3.0 * shape[0]*shape[1]*shape[2]);
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:    buf[1] = rmass[i] / (4.0*MY_PI/3.0 * shape[0]*shape[1]*shape[2]);
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_ellipsoid.cpp:/* ----------------------------------------------------------------------
atom_vec_ellipsoid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_hybrid.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // build list of all known atom styles
atom_vec_hybrid.cpp:  // allocate list of sub-styles as big as possibly needed if no extra args
atom_vec_hybrid.cpp:  // allocate each sub-style
atom_vec_hybrid.cpp:  // call process_args() with set of args that are not atom style names
atom_vec_hybrid.cpp:  // use known_style() to determine which args these are
atom_vec_hybrid.cpp:  // free allstyles created by build_styles()
atom_vec_hybrid.cpp:  // hybrid settings are MAX or MIN of sub-style settings
atom_vec_hybrid.cpp:  // hybrid sizes are minimal values plus extra values for each sub-style
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // sub-styles perform all reallocation
atom_vec_hybrid.cpp:  // turn off nextra_grow so hybrid can do that once below
atom_vec_hybrid.cpp:  // insure hybrid local ptrs and sub-style ptrs are up to date
atom_vec_hybrid.cpp:  // for sub-styles, do this in case
atom_vec_hybrid.cpp:  //   multiple sub-style reallocs of same array occurred
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // pack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // pack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // unpack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // unpack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // pack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // unpack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // pack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // pack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // unpack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ---------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // unpack sub-style contributions as contiguous chunks
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // each sub-style parses sub-style specific values
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  // each sub-style parses sub-style specific values
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:  int index = multiindex/nstyles;
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_hybrid.cpp:/* ----------------------------------------------------------------------
atom_vec_hybrid.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_line.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:  // if deleting atom J via delflag and J has bonus data, then delete it
atom_vec_line.cpp:  // if atom I has bonus data, reset I's bonus.ilocal to loc J
atom_vec_line.cpp:  // do NOT do this if self-copy (I=J) since I's bonus data is already deleted
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:  // also set radius = half of length
atom_vec_line.cpp:  // unless value = 0.0, then set diameter = 1.0
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ---------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:  rmass[nlocal] = 4.0*MY_PI/3.0 * radius[nlocal]*radius[nlocal]*radius[nlocal];
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:    rmass[nlocal] *= 4.0*MY_PI/3.0 *
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:    rmass[nlocal] *= 4.0*MY_PI/3.0 *
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:  if (dy >= 0.0) bonus[nlocal_bonus].theta = acos(dx/length);
atom_vec_line.cpp:  else bonus[nlocal_bonus].theta = -acos(dx/length);
atom_vec_line.cpp:  if (delta/length > EPSILON)
atom_vec_line.cpp:  // reset line radius and mass
atom_vec_line.cpp:  // rmass currently holds density
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:      buf[i][4] = rmass[i] / (4.0*MY_PI/3.0 * radius[i]*radius[i]*radius[i]);
atom_vec_line.cpp:    else buf[i][4] = rmass[i]/bonus[line[i]].length;
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:    buf[2] = rmass[i] / (4.0*MY_PI/3.0 * radius[i]*radius[i]*radius[i]);
atom_vec_line.cpp:  else buf[2] = rmass[i]/bonus[line[i]].length;
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/* ----------------------------------------------------------------------
atom_vec_line.cpp:------------------------------------------------------------------------- */
atom_vec_line.cpp:/*
atom_vec_line.cpp:      //if (comm->me == 1 && update->ntimestep == 873)
atom_vec_line.cpp:      //        printf("CCHK %s: %d %d: %d %d: %d %d\n",
atom_vec_line.cpp:      //       str,i,n,line[i],nlocal_bonus,bonus[line[i]].ilocal,iflag);
atom_vec_line.cpp:*/
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:  // set radvary if particle diameters are time-varying due to fix adapt
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ---------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:  rmass[nlocal] = 4.0*MY_PI/3.0 * radius[nlocal]*radius[nlocal]*radius[nlocal];
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:    rmass[nlocal] = 4.0*MY_PI/3.0 *
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:    rmass[nlocal] = 4.0*MY_PI/3.0 *
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:      buf[i][3] = rmass[i] / (4.0*MY_PI/3.0 * radius[i]*radius[i]*radius[i]);
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:  else buf[1] = rmass[i] / (4.0*MY_PI/3.0 * radius[i]*radius[i]*radius[i]);
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_sphere.cpp:/* ----------------------------------------------------------------------
atom_vec_sphere.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_spin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:  mass_type = 1; //check why
atom_vec_spin.cpp:  //comm_x_only = 0;
atom_vec_spin.cpp:  //comm_f_only = 1;
atom_vec_spin.cpp:  size_data_atom = 9; //to check later
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:  //Allocating mag. quantities
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ---------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_spin.cpp:/* ----------------------------------------------------------------------
atom_vec_spin.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
atom_vec_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:  // if deleting atom J via delflag and J has bonus data, then delete it
atom_vec_tri.cpp:  // if atom I has bonus data, reset I's bonus.ilocal to loc J
atom_vec_tri.cpp:  // do NOT do this if self-copy (I=J) since I's bonus data is already deleted
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:  // also set radius = distance from center to corner-pt = len(c1)
atom_vec_tri.cpp:  // unless size = 0.0, then set diameter = 1.0
atom_vec_tri.cpp:    c1[0] = -size/2.0;
atom_vec_tri.cpp:    c1[1] = -sqrt(3.0)/2.0 * size / 3.0;
atom_vec_tri.cpp:    c2[0] = size/2.0;
atom_vec_tri.cpp:    c2[1] = -sqrt(3.0)/2.0 * size / 3.0;
atom_vec_tri.cpp:    c3[1] = sqrt(3.0)/2.0 * size * 2.0/3.0;
atom_vec_tri.cpp:    inertia[0] = sqrt(3.0)/96.0 * size*size*size*size;
atom_vec_tri.cpp:    inertia[1] = sqrt(3.0)/96.0 * size*size*size*size;
atom_vec_tri.cpp:    inertia[2] = sqrt(3.0)/48.0 * size*size*size*size;
atom_vec_tri.cpp:    c1[0] = -size/2.0;
atom_vec_tri.cpp:    c1[1] = -sqrt(3.0)/2.0 * size / 3.0;
atom_vec_tri.cpp:    c2[0] = size/2.0;
atom_vec_tri.cpp:    c2[1] = -sqrt(3.0)/2.0 * size / 3.0;
atom_vec_tri.cpp:    c3[1] = sqrt(3.0)/2.0 * size * 2.0/3.0;
atom_vec_tri.cpp:    inertia[0] = sqrt(3.0)/96.0 * size*size*size*size;
atom_vec_tri.cpp:    inertia[1] = sqrt(3.0)/96.0 * size*size*size*size;
atom_vec_tri.cpp:    inertia[2] = sqrt(3.0)/48.0 * size*size*size*size;
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ---------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:  rmass[nlocal] = 4.0*MY_PI/3.0 * radius[nlocal]*radius[nlocal]*radius[nlocal];
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:    rmass[nlocal] *= 4.0*MY_PI/3.0 *
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:    rmass[nlocal] *= 4.0*MY_PI/3.0 *
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:  // check for duplicate points
atom_vec_tri.cpp:  // size = length of one edge
atom_vec_tri.cpp:  // centroid = 1/3 of sum of vertices
atom_vec_tri.cpp:  centroid[0] = (c1[0]+c2[0]+c3[0]) / 3.0;
atom_vec_tri.cpp:  centroid[1] = (c1[1]+c2[1]+c3[1]) / 3.0;
atom_vec_tri.cpp:  centroid[2] = (c1[2]+c2[2]+c3[2]) / 3.0;
atom_vec_tri.cpp:  if (delta/size > EPSILON)
atom_vec_tri.cpp:  // reset tri radius and mass
atom_vec_tri.cpp:  // rmass currently holds density
atom_vec_tri.cpp:  // tri area = 0.5 len(U x V), where U,V are edge vectors from one vertex
atom_vec_tri.cpp:  // inertia = inertia tensor of triangle as 6-vector in Voigt notation
atom_vec_tri.cpp:  // diagonalize inertia tensor via Jacobi rotations
atom_vec_tri.cpp:  // bonus[].inertia = 3 eigenvalues = principal moments of inertia
atom_vec_tri.cpp:  // evectors and exzy_space = 3 evectors = principal axes of triangle
atom_vec_tri.cpp:  // enforce 3 orthogonal vectors as a right-handed coordinate system
atom_vec_tri.cpp:  // flip 3rd vector if needed
atom_vec_tri.cpp:  // create initial quaternion
atom_vec_tri.cpp:  // bonus c1,c2,c3 = displacement of c1,c2,c3 from centroid
atom_vec_tri.cpp:  // in basis of principal axes
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:      buf[i][4] = rmass[i] / (4.0*MY_PI/3.0 * radius[i]*radius[i]*radius[i]);
atom_vec_tri.cpp:      buf[i][4] = rmass[i]/area;
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:    buf[2] = rmass[i] / (4.0*MY_PI/3.0 * radius[i]*radius[i]*radius[i]);
atom_vec_tri.cpp:    buf[2] = rmass[i]/area;
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
atom_vec_tri.cpp:/* ----------------------------------------------------------------------
atom_vec_tri.cpp:------------------------------------------------------------------------- */
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
balance.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp://#define BALANCE_DEBUG 1
balance.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
balance.cpp:/* ---------------------------------------------------------------------- */
balance.cpp:/* ---------------------------------------------------------------------- */
balance.cpp:  // check nfix in case all fixes have already been deleted
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // parse required arguments
balance.cpp:  // error checks
balance.cpp:  // process remaining optional args
balance.cpp:  // insure particles are in current box & update box via shrink-wrap
balance.cpp:  // init entire system since comm->setup is done
balance.cpp:  // comm::init needs neighbor::init needs pair::init needs kspace::init, etc
balance.cpp:  // must reset atom map after exchange() since it clears it
balance.cpp:  // imbinit = initial imbalance
balance.cpp:  // no load-balance if imbalance doesn't exceed threshold
balance.cpp:  // unless switching from tiled to non tiled layout, then force rebalance
balance.cpp:  // debug output of initial state
balance.cpp:  // perform load-balance
balance.cpp:  // style XYZ = explicit setting of cutting planes of logical 3d grid
balance.cpp:        comm->xsplit[i] = i * 1.0/procgrid[0];
balance.cpp:        comm->ysplit[i] = i * 1.0/procgrid[1];
balance.cpp:        comm->zsplit[i] = i * 1.0/procgrid[2];
balance.cpp:  // style SHIFT = adjust cutting planes of logical 3d grid
balance.cpp:  // style BISECTION = recursive coordinate bisectioning
balance.cpp:  // reset proc sub-domains
balance.cpp:  // for either brick or tiled comm style
balance.cpp:  // move particles to new processors via irregular()
balance.cpp:  // output of final result
balance.cpp:  // check if any particles were lost
balance.cpp:  // imbfinal = final imbalance
balance.cpp:  // stats output
balance.cpp:      fprintf(screen,"  initial/final max load/proc = %g %g\n",
balance.cpp:      fprintf(screen,"  initial/final imbalance factor = %g %g\n",
balance.cpp:      fprintf(logfile,"  initial/final max load/proc = %g %g\n",
balance.cpp:      fprintf(logfile,"  initial/final imbalance factor = %g %g\n",
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // count max number of weight settings
balance.cpp:  // output file
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:   return imbalance = max load per proc / ave load per proc
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  if (maxcost > 0.0) imbalance = maxcost / (totalcost/nprocs);
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // NOTE: this logic is specific to orthogonal boxes, not triclinic
balance.cpp:  // shrink-wrap simulation box around atoms for input to RCB
balance.cpp:  // leads to better-shaped sub-boxes when atoms are far from box boundaries
balance.cpp:  // invoke RCB
balance.cpp:  // then invert() to create list of proc assignments for my atoms
balance.cpp:  // NOTE: (3/2017) can remove undocumented "old" option at some point
balance.cpp:  //       ditto in rcb.cpp
balance.cpp:  // reset RCB lo/hi bounding box to full simulation box as needed
balance.cpp:  // store RCB cut, dim, lo/hi box in CommTiled
balance.cpp:  // cut and lo/hi need to be in fractional form so can
balance.cpp:  // OK if changes by epsilon from what RCB used since atoms
balance.cpp:  //   will subsequently migrate to new owning procs by exchange() anyway
balance.cpp:  // ditto for atoms exactly on lo/hi RCB box boundaries due to ties
balance.cpp:  if (idim >= 0) comm->rcbcutfrac = (rcb->cut - boxlo[idim]) / prd[idim];
balance.cpp:  mysplit[0][0] = (lo[0] - boxlo[0]) / prd[0];
balance.cpp:  else mysplit[0][1] = (hi[0] - boxlo[0]) / prd[0];
balance.cpp:  mysplit[1][0] = (lo[1] - boxlo[1]) / prd[1];
balance.cpp:  else mysplit[1][1] = (hi[1] - boxlo[1]) / prd[1];
balance.cpp:  mysplit[2][0] = (lo[2] - boxlo[2]) / prd[2];
balance.cpp:  else mysplit[2][1] = (hi[2] - boxlo[2]) / prd[2];
balance.cpp:  // return list of procs to send my atoms to
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // if current layout is TILED, set initial uniform splits in Comm
balance.cpp:  // this gives starting point to subsequent shift balancing
balance.cpp:    for (int i = 0; i < procgrid[0]; i++) xsplit[i] = i * 1.0/procgrid[0];
balance.cpp:    for (int i = 0; i < procgrid[1]; i++) ysplit[i] = i * 1.0/procgrid[1];
balance.cpp:    for (int i = 0; i < procgrid[2]; i++) zsplit[i] = i * 1.0/procgrid[2];
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // no balancing if no atoms
balance.cpp:  // set delta for 1d balancing = root of threshold
balance.cpp:  // root = # of dimensions being balanced on
balance.cpp:  double delta = pow(stopthresh,1.0/ndim) - 1.0;
balance.cpp:  // all balancing done in lamda coords
balance.cpp:  // loop over dimensions in balance string
balance.cpp:    // split = ptr to xyz split in Comm
balance.cpp:    // initial count and sum
balance.cpp:    // target[i] = desired sum at split I
balance.cpp:    for (i = 0; i < np; i++) target[i] = totalcost/np * i;
balance.cpp:    // lo[i] = closest split <= split[i] with a sum <= target
balance.cpp:    // hi[i] = closest split >= split[i] with a sum >= target
balance.cpp:    // iterate until balanced
balance.cpp:      // stop if no change in splits, b/c all targets are met exactly
balance.cpp:      // stop if all split sums are within delta of targets
balance.cpp:      // this is a 1d test of particle count per slice
balance.cpp:      // assumption is that this is sufficient accuracy
balance.cpp:      //   for 3d imbalance factor to reach threshold
balance.cpp:        if (fabs(1.0*(sum[i]-target[i]))/target[i] > delta) doneflag = 0;
balance.cpp:    // eliminate final adjacent splits that are duplicates
balance.cpp:    // can happen if particle distribution is narrow and Nitermax is small
balance.cpp:    // set lo = midpt between splits
balance.cpp:    // spread duplicates out evenly between bounding midpts with non-duplicates
balance.cpp:    // i,j = lo/hi indices of set of duplicate splits
balance.cpp:    // delta = new spacing between duplicates
balance.cpp:    // bounding midpts = lo[i-1] and lo[j]
balance.cpp:          delta = (lo[j] - lo[i-1]) / (j-i+2);
balance.cpp:    // sanity check on bad duplicate or inverted splits
balance.cpp:    // zero or negative width sub-domains will break Comm class
balance.cpp:    // should never happen if recursive multisection algorithm is correct
balance.cpp:    /*
balance.cpp:    */
balance.cpp:    // stop at this point in bstr if imbalance factor < threshold
balance.cpp:    // this is a true 3d test of particle count per processor
balance.cpp:  // restore real coords
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:   lo/hi = split values that bound current split
balance.cpp:   update lo/hi to reflect sums at current split values
balance.cpp:   recursive bisectioning zooms in on each cut by halving lo/hi
balance.cpp:   return 0 if no changes in any splits, b/c they are all perfect
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // reset lo/hi based on current sum and splits
balance.cpp:  // insure lo is monotonically increasing, ties are OK
balance.cpp:  // insure hi is monotonically decreasing, ties are OK
balance.cpp:  // this effectively uses info from nearby splits
balance.cpp:  // to possibly tighten bounds on lo/hi
balance.cpp:        fraction = 1.0*(target[i]-losum[i]) / (hisum[i]-losum[i]);
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:   return imbalance factor = max load per proc / ave load per proc
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // one proc's particles may map to many partitions, so must Allreduce
balance.cpp:  if (maxcost > 0.0) imbalance = maxcost / (totalcost/nprocs);
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // insure vec[lo] <= value < vec[hi] at every iteration
balance.cpp:  // done when lo,hi are adjacent
balance.cpp:  int index = (lo+hi)/2;
balance.cpp:    index = (lo+hi)/2;
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  // Allgather each proc's sub-box
balance.cpp:  // could use Gather, but that requires MPI to alloc memory
balance.cpp:  // proc 0 writes out nodal coords
balance.cpp:  // some will be duplicates
balance.cpp:  // write out one square/cube per processor for 2d/3d
balance.cpp:/* ----------------------------------------------------------------------
balance.cpp:------------------------------------------------------------------------- */
balance.cpp:  fprintf(stderr,"  Imbalance factor: %g\n",1.0*max*np/target[np]);
body.cpp:/* ----------------------------------------------------------------------
body.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
body.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
body.cpp:------------------------------------------------------------------------- */
body.cpp:/* ---------------------------------------------------------------------- */
body.cpp:/* ---------------------------------------------------------------------- */
bond.cpp:/* ----------------------------------------------------------------------
bond.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
bond.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
bond.cpp:------------------------------------------------------------------------- */
bond.cpp:/* -----------------------------------------------------------------------
bond.cpp:------------------------------------------------------------------------- */
bond.cpp:/* ---------------------------------------------------------------------- */
bond.cpp:/* ----------------------------------------------------------------------
bond.cpp:------------------------------------------------------------------------- */
bond.cpp:/* ----------------------------------------------------------------------
bond.cpp:------------------------------------------------------------------------- */
bond.cpp:  eflag_atom = eflag / 2;
bond.cpp:  vflag_atom = vflag / 4;
bond.cpp:  // reallocate per-atom arrays if necessary
bond.cpp:  // zero accumulators
bond.cpp:/* ----------------------------------------------------------------------
bond.cpp:------------------------------------------------------------------------- */
bond.cpp:/* ----------------------------------------------------------------------
bond.cpp:   write a table of bond potential energy/force vs distance to a file
bond.cpp:------------------------------------------------------------------------- */
bond.cpp:  // parse optional arguments
bond.cpp:    error->all(FLERR,"Invalid rlo/rhi values in bond_write command");
bond.cpp:  // open file in append mode
bond.cpp:  // print header in format used by bond_style table
bond.cpp:  // initialize potentials before evaluating bond potential
bond.cpp:  // insures all bond coeffs are set and force constants
bond.cpp:  // also initialize neighbor so that neighbor requests are processed
bond.cpp:  // NOTE: might be safest to just do lmp->init()
bond.cpp:    // evaluate energy and force at each of N distances
bond.cpp:    // note that Bond::single() takes r**2 and returns f/r.
bond.cpp:    const double dr = (outer-inner) / static_cast<double>(n-1);
bond.cpp:/* ---------------------------------------------------------------------- */
bond.cpp:/* -----------------------------------------------------------------------
bond.cpp:-------------------------------------------------------------------------- */
bond_hybrid.cpp:/* ----------------------------------------------------------------------
bond_hybrid.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
bond_hybrid.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
bond_hybrid.cpp:------------------------------------------------------------------------- */
bond_hybrid.cpp:/* ---------------------------------------------------------------------- */
bond_hybrid.cpp:/* ---------------------------------------------------------------------- */
bond_hybrid.cpp:/* ---------------------------------------------------------------------- */
bond_hybrid.cpp:  // save ptrs to original bondlist
bond_hybrid.cpp:  // if this is re-neighbor step, create sub-style bondlists
bond_hybrid.cpp:  // nbondlist[] = length of each sub-style list
bond_hybrid.cpp:  // realloc sub-style bondlist if necessary
bond_hybrid.cpp:  // load sub-style bondlist with 3 values from original bondlist
bond_hybrid.cpp:  // call each sub-style's compute function
bond_hybrid.cpp:  // set neighbor->bondlist to sub-style bondlist before call
bond_hybrid.cpp:  // accumulate sub-style global/peratom energy/virial in hybrid
bond_hybrid.cpp:  // restore ptrs to original bondlist
bond_hybrid.cpp:/* ---------------------------------------------------------------------- */
bond_hybrid.cpp:/* ----------------------------------------------------------------------
bond_hybrid.cpp:------------------------------------------------------------------------- */
bond_hybrid.cpp:  // delete old lists, since cannot just change settings
bond_hybrid.cpp:  // count sub-styles by skipping numeric args
bond_hybrid.cpp:  // one exception is 1st arg of style "table", which is non-numeric word
bond_hybrid.cpp:  // need a better way to skip these exceptions
bond_hybrid.cpp:  // allocate list of sub-styles
bond_hybrid.cpp:  // allocate each sub-style and call its settings() with subset of args
bond_hybrid.cpp:  // allocate uses suffix, but don't store suffix version in keywords,
bond_hybrid.cpp:  //   else syntax in coeff() will not match
bond_hybrid.cpp:  // define subset of args for a sub-style by skipping numeric args
bond_hybrid.cpp:  // one exception is 1st arg of style "table", which is non-numeric
bond_hybrid.cpp:  // need a better way to skip these exceptions
bond_hybrid.cpp:/* ----------------------------------------------------------------------
bond_hybrid.cpp:---------------------------------------------------------------------- */
bond_hybrid.cpp:  // 2nd arg = bond sub-style name
bond_hybrid.cpp:  // allow for "none" as valid sub-style name
bond_hybrid.cpp:  // move 1st arg to 2nd arg
bond_hybrid.cpp:  // just copy ptrs, since arg[] points into original input line
bond_hybrid.cpp:  // invoke sub-style coeff() starting with 1st arg
bond_hybrid.cpp:  // set setflag and which type maps to which sub-style
bond_hybrid.cpp:  // if sub-style is none: set hybrid setflag, wipe out map
bond_hybrid.cpp:/* ---------------------------------------------------------------------- */
bond_hybrid.cpp:/* ----------------------------------------------------------------------
bond_hybrid.cpp:------------------------------------------------------------------------- */
bond_hybrid.cpp:/* ----------------------------------------------------------------------
bond_hybrid.cpp:------------------------------------------------------------------------- */
bond_hybrid.cpp:/* ----------------------------------------------------------------------
bond_hybrid.cpp:------------------------------------------------------------------------- */
bond_hybrid.cpp:/* ---------------------------------------------------------------------- */
bond_hybrid.cpp:/* ----------------------------------------------------------------------
bond_hybrid.cpp:------------------------------------------------------------------------- */
bond_zero.cpp:/* ----------------------------------------------------------------------
bond_zero.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
bond_zero.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
bond_zero.cpp:------------------------------------------------------------------------- */
bond_zero.cpp:/* ----------------------------------------------------------------------
bond_zero.cpp:------------------------------------------------------------------------- */
bond_zero.cpp:/* ---------------------------------------------------------------------- */
bond_zero.cpp:/* ---------------------------------------------------------------------- */
bond_zero.cpp:/* ---------------------------------------------------------------------- */
bond_zero.cpp:/* ---------------------------------------------------------------------- */
bond_zero.cpp:/* ---------------------------------------------------------------------- */
bond_zero.cpp:/* ----------------------------------------------------------------------
bond_zero.cpp:------------------------------------------------------------------------- */
bond_zero.cpp:/* ----------------------------------------------------------------------
bond_zero.cpp:------------------------------------------------------------------------- */
bond_zero.cpp:/* ----------------------------------------------------------------------
bond_zero.cpp:------------------------------------------------------------------------- */
bond_zero.cpp:/* ----------------------------------------------------------------------
bond_zero.cpp:------------------------------------------------------------------------- */
bond_zero.cpp:/* ----------------------------------------------------------------------
bond_zero.cpp:------------------------------------------------------------------------- */
bond_zero.cpp:/* ---------------------------------------------------------------------- */
change_box.cpp:/* ----------------------------------------------------------------------
change_box.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
change_box.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
change_box.cpp:------------------------------------------------------------------------- */
change_box.cpp:/* ---------------------------------------------------------------------- */
change_box.cpp:/* ---------------------------------------------------------------------- */
change_box.cpp:  // group
change_box.cpp:  // parse operation arguments
change_box.cpp:  // allocate ops to max possible length
change_box.cpp:  // volume option does not increment nops
change_box.cpp:  // read options from end of input line
change_box.cpp:  // compute scale factors if FINAL,DELTA used since they have distance units
change_box.cpp:  // perform sequence of operations
change_box.cpp:  // first insure atoms are in current box & update box via shrink-wrap
change_box.cpp:  // no exchange() since doesn't matter if atoms are assigned to correct procs
change_box.cpp:  // save current box state so can remap atoms from it, if requested
change_box.cpp:                   "Cannot change box ortho/triclinic with dumps defined");
change_box.cpp:                     "Cannot change box ortho/triclinic with "
change_box.cpp:                   "Cannot change box ortho/triclinic with dumps defined");
change_box.cpp:                     "Cannot change box ortho/triclinic with "
change_box.cpp:      // convert atoms to lamda coords, using last box state
change_box.cpp:      // convert atoms back to box coords, using current box state
change_box.cpp:      // save current box state
change_box.cpp:  // clean up
change_box.cpp:  // apply shrink-wrap boundary conditions
change_box.cpp:  // move atoms back inside simulation box and to new processors
change_box.cpp:  // use remap() instead of pbc()
change_box.cpp:  //   in case box moved a long distance relative to atoms
change_box.cpp:  // use irregular() in case box moved a long distance relative to atoms
change_box.cpp:  // check if any atoms were lost
change_box.cpp:/* ----------------------------------------------------------------------
change_box.cpp:------------------------------------------------------------------------- */
change_box.cpp:/* ----------------------------------------------------------------------
change_box.cpp:------------------------------------------------------------------------- */
change_box.cpp:/* ----------------------------------------------------------------------
change_box.cpp:   reset box lengths of dim1/2 to preserve old volume
change_box.cpp:------------------------------------------------------------------------- */
change_box.cpp:  // invoke set_initial_box()
change_box.cpp:  // in case change by caller to dim3 was invalid or on shrink-wrapped dim
change_box.cpp:  // calculate newvol using boxlo/hi since xyz prd are not yet reset
change_box.cpp:  double scale = oldvol/newvol;
change_box.cpp:  // change dim1 only
change_box.cpp:  // change dim1 and dim2, keeping their relative aspect ratio constant
change_box.cpp:  // both are scaled by sqrt(scale)
citeme.cpp:/* ----------------------------------------------------------------------
citeme.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
citeme.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
citeme.cpp:------------------------------------------------------------------------- */
citeme.cpp:  "following references.  See http://lammps.sandia.gov/cite.html\n"
citeme.cpp:/* ---------------------------------------------------------------------- */
citeme.cpp:/* ----------------------------------------------------------------------
citeme.cpp:------------------------------------------------------------------------- */
citeme.cpp:/* ----------------------------------------------------------------------
citeme.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
comm_brick.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:enum{SINGLE,MULTI};               // same as in Comm
comm_brick.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
comm_brick.cpp:/* ---------------------------------------------------------------------- */
comm_brick.cpp:/* ---------------------------------------------------------------------- */
comm_brick.cpp:/* ---------------------------------------------------------------------- */
comm_brick.cpp://IMPORTANT: we *MUST* pass "*oldcomm" to the Comm initializer here, as
comm_brick.cpp://           the code below *requires* that the (implicit) copy constructor
comm_brick.cpp://           for Comm is run and thus creating a shallow copy of "oldcomm".
comm_brick.cpp://           The call to Comm::copy_arrays() then converts the shallow copy
comm_brick.cpp://           into a deep copy of the class with the new layout.
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  // bufextra = max size of one exchanged atom
comm_brick.cpp:  //          = allowed overflow of sendbuf in exchange()
comm_brick.cpp:  // atomvec, fix reset these 2 maxexchange values if needed
comm_brick.cpp:  // only necessary if their size > BUFEXTRA
comm_brick.cpp:/* ---------------------------------------------------------------------- */
comm_brick.cpp:  // memory for multi-style communication
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  // cutghost[] = max distance at which ghost atoms need to be acquired
comm_brick.cpp:  // for orthogonal:
comm_brick.cpp:  //   cutghost is in box coords = neigh->cutghost in all 3 dims
comm_brick.cpp:  // for triclinic:
comm_brick.cpp:  //   neigh->cutghost = distance between tilted planes in box coords
comm_brick.cpp:  //   cutghost is in lamda coords = distance between those planes
comm_brick.cpp:  // for multi:
comm_brick.cpp:  //   cutghostmulti = same as cutghost, only for each atom type
comm_brick.cpp:  // recvneed[idim][0/1] = # of procs away I recv atoms from, within cutghost
comm_brick.cpp:  //   0 = from left, 1 = from right
comm_brick.cpp:  //   do not cross non-periodic boundaries, need[2] = 0 for 2d
comm_brick.cpp:  // sendneed[idim][0/1] = # of procs away I send atoms to
comm_brick.cpp:  //   0 = to left, 1 = to right
comm_brick.cpp:  //   set equal to recvneed[idim][1/0] of neighbor proc
comm_brick.cpp:  // maxneed[idim] = max procs away any proc recvs atoms in either direction
comm_brick.cpp:  // layout = UNIFORM = uniform sized sub-domains:
comm_brick.cpp:  //   maxneed is directly computable from sub-domain size
comm_brick.cpp:  //     limit to procgrid-1 for non-PBC
comm_brick.cpp:  //   recvneed = maxneed except for procs near non-PBC
comm_brick.cpp:  //   sendneed = recvneed of neighbor on each side
comm_brick.cpp:  // layout = NONUNIFORM = non-uniform sized sub-domains:
comm_brick.cpp:  //   compute recvneed via updown() which accounts for non-PBC
comm_brick.cpp:  //   sendneed = recvneed of neighbor on each side
comm_brick.cpp:  //   maxneed via Allreduce() of recvneed
comm_brick.cpp:    maxneed[0] = static_cast<int> (cutghost[0] * procgrid[0] / prd[0]) + 1;
comm_brick.cpp:    maxneed[1] = static_cast<int> (cutghost[1] * procgrid[1] / prd[1]) + 1;
comm_brick.cpp:    maxneed[2] = static_cast<int> (cutghost[2] * procgrid[2] / prd[2]) + 1;
comm_brick.cpp:  // allocate comm memory
comm_brick.cpp:  // setup parameters for each exchange:
comm_brick.cpp:  // sendproc = proc to send to at each swap
comm_brick.cpp:  // recvproc = proc to recv from at each swap
comm_brick.cpp:  // for mode SINGLE:
comm_brick.cpp:  //   slablo/slabhi = boundaries for slab of atoms to send at each swap
comm_brick.cpp:  //   use -BIG/midpt/BIG to insure all atoms included even if round-off occurs
comm_brick.cpp:  //   if round-off, atoms recvd across PBC can be < or > than subbox boundary
comm_brick.cpp:  //   note that borders() only loops over subset of atoms during each swap
comm_brick.cpp:  //   treat all as PBC here, non-PBC is handled in borders() via r/s need[][]
comm_brick.cpp:  // for mode MULTI:
comm_brick.cpp:  //   multilo/multihi is same, with slablo/slabhi for each atom type
comm_brick.cpp:  // pbc_flag: 0 = nothing across a boundary, 1 = something across a boundary
comm_brick.cpp:  // pbc = -1/0/1 for PBC factor in each of 3/6 orthogonal/triclinic dirs
comm_brick.cpp:  // for triclinic, slablo/hi and pbc_border will be used in lamda (0-1) coords
comm_brick.cpp:  // 1st part of if statement is sending to the west/south/down
comm_brick.cpp:  // 2nd part of if statement is sending to the east/north/up
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   walk up/down the extent of nearby processors in dim and dir
comm_brick.cpp:   dir = 0/1 = walk to left/right
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    frac = cutghost[dim]/prd;
comm_brick.cpp:    frac = cutghost[dim]/prd;
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   other per-atom attributes may also be sent via pack/unpack routines
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  // exchange data with another proc
comm_brick.cpp:  // if other proc is self, just copy
comm_brick.cpp:  // if comm_x_only set, exchange or copy directly to x, don't unpack
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   other per-atom attributes may also be sent via pack/unpack routines
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  // exchange data with another proc
comm_brick.cpp:  // if other proc is self, just copy
comm_brick.cpp:  // if comm_f_only set, exchange or copy directly from f, don't pack
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  // clear global->local map for owned and ghost atoms
comm_brick.cpp:  // b/c atoms migrate to new procs in exchange() and
comm_brick.cpp:  //   new ghosts are created in borders()
comm_brick.cpp:  // map_set() is done at end of borders()
comm_brick.cpp:  // clear ghost count and any ghost bonus data internal to AtomVec
comm_brick.cpp:  // insure send buf is large enough for single atom
comm_brick.cpp:  // bufextra = max size of one atom = allowed overflow of sendbuf
comm_brick.cpp:  // fixes can change per-atom size requirement on-the-fly
comm_brick.cpp:  // subbox bounds for orthogonal or triclinic
comm_brick.cpp:  // loop over dimensions
comm_brick.cpp:    // fill buffer with atoms leaving my box, using < and >=
comm_brick.cpp:    // when atom is deleted, fill it in with last atom
comm_brick.cpp:    // send/recv atoms in both directions
comm_brick.cpp:    // send size of message first so receiver can realloc buf_recv if needed
comm_brick.cpp:    // if 1 proc in dimension, no send/recv
comm_brick.cpp:    //   set nrecv = 0 so buf_send atoms will be lost
comm_brick.cpp:    // if 2 procs in dimension, single send/recv
comm_brick.cpp:    // if more than 2 procs in dimension, send/recv to both neighbors
comm_brick.cpp:    // check incoming atoms to see if they are in my box
comm_brick.cpp:    // if so, add to my list
comm_brick.cpp:    // box check is only for this dimension,
comm_brick.cpp:    //   atom may be passed to another proc in later dims
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  // do swaps over all 3 dimensions
comm_brick.cpp:      // find atoms within slab boundaries lo/hi using <= and >=
comm_brick.cpp:      // check atoms between nfirst and nlast
comm_brick.cpp:      //   for first swaps in a dim, check owned and ghost
comm_brick.cpp:      //   for later swaps in a dim, only check newly arrived ghosts
comm_brick.cpp:      // store sent atom indices in sendlist for use in future timesteps
comm_brick.cpp:      // sendflag = 0 if I do not send on this swap
comm_brick.cpp:      // sendneed test indicates receiver no longer requires data
comm_brick.cpp:      // e.g. due to non-PBC or non-uniform sub-domains
comm_brick.cpp:      if (ineed/2 >= sendneed[dim][ineed % 2]) sendflag = 0;
comm_brick.cpp:      // find send atoms according to SINGLE vs MULTI
comm_brick.cpp:      // all atoms eligible versus only atoms in bordergroup
comm_brick.cpp:      // can only limit loop to bordergroup for first sends (ineed < 2)
comm_brick.cpp:      // on these sends, break loop in two: owned (in group) and ghost
comm_brick.cpp:      // pack up list of border atoms
comm_brick.cpp:      // swap atoms with other proc
comm_brick.cpp:      // no MPI calls except SendRecv if nsend/nrecv = 0
comm_brick.cpp:      // put incoming ghosts at end of my atom arrays
comm_brick.cpp:      // if swapping with self, simply copy, no messages
comm_brick.cpp:      // unpack buffer
comm_brick.cpp:      // set all pointers & counters
comm_brick.cpp:  // insure send/recv buffers are long enough for all forward & reverse comm
comm_brick.cpp:  // reset global->local map
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   size/nsize used only to set recv buffer limit
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   size/nsize used only to set recv buffer limit
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   handshake sizes before each Irecv/Send to insure buf_recv is big enough
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  // insure send/recv bufs are big enough for nsize
comm_brick.cpp:  // based on smax/rmax from most recent borders() invocation
comm_brick.cpp:    // pack buffer
comm_brick.cpp:    // exchange with another proc
comm_brick.cpp:    // if self, set recv buffer to send buffer
comm_brick.cpp:    // unpack buffer
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  // loop over dimensions
comm_brick.cpp:    // no exchange if only one proc in a dimension
comm_brick.cpp:    // send/recv info in both directions using same buf_recv
comm_brick.cpp:    // if 2 procs in dimension, single send/recv
comm_brick.cpp:    // if more than 2 procs in dimension, send/recv to both neighbors
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   if flag = 0, don't need to realloc with copy, just free/malloc
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:   free/malloc the size of the recv buffer as needed with BUFFACTOR
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:/* ----------------------------------------------------------------------
comm_brick.cpp:------------------------------------------------------------------------- */
comm_brick.cpp:  bytes += nprocs * sizeof(int);    // grid2proc
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
comm.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:#define BUFMIN 1000             // also in comm styles
comm.cpp:enum{SINGLE,MULTI};             // same as in Comm sub-styles
comm.cpp:enum{MULTIPLE};                   // same as in ProcMap
comm.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
comm.cpp:/* ---------------------------------------------------------------------- */
comm.cpp:  // use of OpenMP threads
comm.cpp:  // query OpenMP for number of threads/process set by user at run-time
comm.cpp:  // if the OMP_NUM_THREADS environment variable is not set, we default
comm.cpp:  // to using 1 thread. This follows the principle of the least surprise,
comm.cpp:  // while practically all OpenMP implementations violate it by using
comm.cpp:  // as many threads as there are (virtual) CPU cores by default.
comm.cpp:  // enforce consistent number of threads across all MPI tasks
comm.cpp:/* ---------------------------------------------------------------------- */
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:   all public/protected vectors/arrays in parent Comm class must be copied
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:  // check warn if any proc's subbox is smaller than neigh skin
comm.cpp:  //   since may lead to lost atoms in exchange()
comm.cpp:  // really should check every exchange() in case box size is shrinking
comm.cpp:  //   but seems overkill to do that (fix balance does perform this check)
comm.cpp:  // comm_only = 1 if only x,f are exchanged in forward/reverse comm
comm.cpp:  // comm_x_only = 0 if ghost_velocity since velocities are added
comm.cpp:  // set per-atom sizes for forward/reverse/border comm
comm.cpp:  // augment by velocity and fix quantities if needed
comm.cpp:  // per-atom limits for communication
comm.cpp:  // maxexchange = max # of datums in exchange comm, set in exchange()
comm.cpp:  // maxforward = # of datums in largest forward comm
comm.cpp:  // maxreverse = # of datums in largest reverse comm
comm.cpp:  // query pair,fix,compute,dump for their requirements
comm.cpp:  // pair style can force reverse comm even if newton off
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:        // need to reset cutghostuser when switching comm mode
comm.cpp:        // need to reset cutghostuser when switching comm mode
comm.cpp:                   "Use cutoff/multi keyword to set cutoff in multi mode");
comm.cpp:    } else if (strcmp(arg[iarg],"cutoff/multi") == 0) {
comm.cpp:                   "Cannot set cutoff/multi before simulation box is defined");
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:      else if (strcmp(arg[iarg+1],"cart/reorder") == 0) mapflag = CARTREORDER;
comm.cpp:      // only receiver has otherflag dependency
comm.cpp:  // error checks
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:  // recv 3d proc grid of another partition if my 3d grid depends on it
comm.cpp:  // create ProcMap class to create 3d grid and map procs to it
comm.cpp:  // create 3d grid of processors
comm.cpp:  // produces procgrid and coregrid (if relevant)
comm.cpp:  // error check on procgrid
comm.cpp:  // should not be necessary due to ProcMap
comm.cpp:  // grid2proc[i][j][k] = proc that owns i,j,k location in 3d grid
comm.cpp:  // map processor IDs to 3d processor grid
comm.cpp:  // produces myloc, procneigh, grid2proc
comm.cpp:  // print 3d grid info to screen and logfile
comm.cpp:  // print 3d grid details to outfile
comm.cpp:  // free ProcMap class
comm.cpp:  // set xsplit,ysplit,zsplit for uniform spacings
comm.cpp:  for (int i = 0; i < procgrid[0]; i++) xsplit[i] = i * 1.0/procgrid[0];
comm.cpp:  for (int i = 0; i < procgrid[1]; i++) ysplit[i] = i * 1.0/procgrid[1];
comm.cpp:  for (int i = 0; i < procgrid[2]; i++) zsplit[i] = i * 1.0/procgrid[2];
comm.cpp:  // set lamda box params after procs are assigned
comm.cpp:  // only set once unless load-balancing occurs
comm.cpp:  // send my 3d proc grid to another partition if requested
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:  // initialize triclinic b/c coord2proc can be called before Comm::init()
comm.cpp:  // via Irregular::migrate_atoms()
comm.cpp:      igx = static_cast<int> (procgrid[0] * (x[0]-boxlo[0]) / prd[0]);
comm.cpp:      igy = static_cast<int> (procgrid[1] * (x[1]-boxlo[1]) / prd[1]);
comm.cpp:      igz = static_cast<int> (procgrid[2] * (x[2]-boxlo[2]) / prd[2]);
comm.cpp:      igx = binary((x[0]-boxlo[0])/prd[0],procgrid[0],xsplit);
comm.cpp:      igy = binary((x[1]-boxlo[1])/prd[1],procgrid[1],ysplit);
comm.cpp:      igz = binary((x[2]-boxlo[2])/prd[2],procgrid[2],zsplit);
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:  // insure vec[lo] <= value < vec[hi] at every iteration
comm.cpp:  // done when lo,hi are adjacent
comm.cpp:  int index = (lo+hi)/2;
comm.cpp:    index = (lo+hi)/2;
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:   callback() is invoked to allow caller to process/update each proc's inbuf
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:  // no need to communicate without data
comm.cpp:    if (self || loop < nprocs-1) callback(nbytes/nper,buf);
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:------------------------------------------------------------------------- */
comm.cpp:/* ----------------------------------------------------------------------
comm.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
comm_tiled.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:enum{SINGLE,MULTI};               // same as in Comm
comm_tiled.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
comm_tiled.cpp:/* ---------------------------------------------------------------------- */
comm_tiled.cpp:/* ---------------------------------------------------------------------- */
comm_tiled.cpp://IMPORTANT: we *MUST* pass "*oldcomm" to the Comm initializer here, as
comm_tiled.cpp://           the code below *requires* that the (implicit) copy constructor
comm_tiled.cpp://           for Comm is run and thus creating a shallow copy of "oldcomm".
comm_tiled.cpp://           The call to Comm::copy_arrays() then converts the shallow copy
comm_tiled.cpp://           into a deep copy of the class with the new layout.
comm_tiled.cpp:/* ---------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // bufextra = max size of one exchanged atom
comm_tiled.cpp:  //          = allowed overflow of sendbuf in exchange()
comm_tiled.cpp:  // atomvec, fix reset these 2 maxexchange values if needed
comm_tiled.cpp:  // only necessary if their size > BUFEXTRA
comm_tiled.cpp:/* ---------------------------------------------------------------------- */
comm_tiled.cpp:  // temporary restrictions
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // domain properties used in setup method and methods it calls
comm_tiled.cpp:  // set function pointers
comm_tiled.cpp:  // if RCB decomp exists and just changed, gather needed global RCB info
comm_tiled.cpp:  // set cutoff for comm forward and comm reverse
comm_tiled.cpp:  // check that cutoff < any periodic box length
comm_tiled.cpp:  // if cut = 0.0, set to epsilon to induce nearest neighbor comm
comm_tiled.cpp:  // this is b/c sendproc is used below to infer touching exchange procs
comm_tiled.cpp:  // exchange procs will be empty (leading to lost atoms) if sendproc = 0
comm_tiled.cpp:  // will reset sendproc/etc to 0 after exchange is setup, down below
comm_tiled.cpp:  // setup forward/reverse communication
comm_tiled.cpp:  // loop over 6 swap directions
comm_tiled.cpp:  // determine which procs I will send to and receive from in each swap
comm_tiled.cpp:  // done by intersecting ghost box with all proc sub-boxes it overlaps
comm_tiled.cpp:  // sets nsendproc, nrecvproc, sendproc, recvproc
comm_tiled.cpp:  // sets sendother, recvother, sendself, pbc_flag, pbc, sendbox
comm_tiled.cpp:  // resets nprocmax
comm_tiled.cpp:      // one = first ghost box in same periodic image
comm_tiled.cpp:      // two = second ghost box wrapped across periodic boundary
comm_tiled.cpp:      // either may not exist
comm_tiled.cpp:      // noverlap = # of overlaps of box1/2 with procs via box_drop()
comm_tiled.cpp:      // overlap = list of overlapping procs
comm_tiled.cpp:      // if overlap with self, indexme = index of me in list
comm_tiled.cpp:      // if self is in overlap list, move it to end of list
comm_tiled.cpp:      // reallocate 2nd dimensions of all send/recv arrays, based on noverlap
comm_tiled.cpp:      // # of sends of this swap = # of recvs of iswap +/- 1
comm_tiled.cpp:      // overlap how has list of noverlap procs
comm_tiled.cpp:      // includes PBC effects
comm_tiled.cpp:      // compute sendbox for each of my sends
comm_tiled.cpp:      // obox = intersection of ghostbox with other proc's sub-domain
comm_tiled.cpp:      // sbox = what I need to send to other proc
comm_tiled.cpp:      //      = sublo to MIN(sublo+cut,subhi) in idim, for idir = 0
comm_tiled.cpp:      //      = MIN(subhi-cut,sublo) to subhi in idim, for idir = 1
comm_tiled.cpp:      //      = obox in other 2 dims
comm_tiled.cpp:      // if sbox touches other proc's sub-box boundaries in lower dims,
comm_tiled.cpp:      //   extend sbox in those lower dims to include ghost atoms
comm_tiled.cpp:  // setup exchange communication = subset of forward/reverse comm procs
comm_tiled.cpp:  // loop over dimensions
comm_tiled.cpp:  // determine which procs I will exchange with in each dimension
comm_tiled.cpp:  // subset of procs that touch my proc in forward/reverse comm
comm_tiled.cpp:  // sets nexchproc & exchproc, resets nexchprocmax
comm_tiled.cpp:    // overlap = list of procs that touch my sub-box in idim
comm_tiled.cpp:    // proc can appear twice in list if touches in both directions
comm_tiled.cpp:    // 2nd add-to-list checks to insure each proc appears exactly once
comm_tiled.cpp:    // reallocate exchproc and exchnum if needed based on noverlap
comm_tiled.cpp:  // reset sendproc/etc to 0 if cut is really 0.0
comm_tiled.cpp:  // reallocate MPI Requests and Statuses as needed
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   other per-atom attributes may also be sent via pack/unpack routines
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // exchange data with another set of procs in each swap
comm_tiled.cpp:  // post recvs from all procs except self
comm_tiled.cpp:  // send data to all procs except self
comm_tiled.cpp:  // copy data to self if sendself is set
comm_tiled.cpp:  // wait on all procs except self and unpack received data
comm_tiled.cpp:  // if comm_x_only set, exchange or copy directly to x, don't unpack
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   other per-atom attributes may also be sent via pack/unpack routines
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // exchange data with another set of procs in each swap
comm_tiled.cpp:  // post recvs from all procs except self
comm_tiled.cpp:  // send data to all procs except self
comm_tiled.cpp:  // copy data to self if sendself is set
comm_tiled.cpp:  // wait on all procs except self and unpack received data
comm_tiled.cpp:  // if comm_f_only set, exchange or copy directly from f, don't pack
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // clear global->local map for owned and ghost atoms
comm_tiled.cpp:  // b/c atoms migrate to new procs in exchange() and
comm_tiled.cpp:  //   new ghosts are created in borders()
comm_tiled.cpp:  // map_set() is done at end of borders()
comm_tiled.cpp:  // clear ghost count and any ghost bonus data internal to AtomVec
comm_tiled.cpp:  // insure send buf is large enough for single atom
comm_tiled.cpp:  // bufextra = max size of one atom = allowed overflow of sendbuf
comm_tiled.cpp:  // fixes can change per-atom size requirement on-the-fly
comm_tiled.cpp:  // domain properties used in exchange method and methods it calls
comm_tiled.cpp:  // subbox bounds for orthogonal or triclinic
comm_tiled.cpp:  // loop over dimensions
comm_tiled.cpp:    // fill buffer with atoms leaving my box, using < and >=
comm_tiled.cpp:    // when atom is deleted, fill it in with last atom
comm_tiled.cpp:    // send and recv atoms from neighbor procs that touch my sub-box in dim
comm_tiled.cpp:    // no send/recv with self
comm_tiled.cpp:    // send size of message first
comm_tiled.cpp:    // receiver may receive multiple messages, realloc buf_recv if needed
comm_tiled.cpp:    // check incoming atoms to see if I own it and they are in my box
comm_tiled.cpp:    // if so, add to my list
comm_tiled.cpp:    // box check is only for this dimension,
comm_tiled.cpp:    //   atom may be passed to another proc in later dims
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   one list is created per swap/proc that will be made
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // send/recv max one = max # of atoms in single send/recv for any swap
comm_tiled.cpp:  // send/recv max all = max # of atoms in all sends/recvs within any swap
comm_tiled.cpp:  // loop over swaps in all dimensions
comm_tiled.cpp:    // find atoms within sendboxes using >= and <
comm_tiled.cpp:    // hi test with ">" is important b/c don't want to send an atom
comm_tiled.cpp:    //   in lower dim (on boundary) that a proc will recv again in higher dim
comm_tiled.cpp:    // for x-dim swaps, check owned atoms
comm_tiled.cpp:    // for yz-dim swaps, check owned and ghost atoms
comm_tiled.cpp:    // store sent atom indices in sendlist for use in future timesteps
comm_tiled.cpp:    // NOTE: assume SINGLE mode, add logic for MULTI mode later
comm_tiled.cpp:    // send sendnum counts to procs who recv from me except self
comm_tiled.cpp:    // copy data to self if sendself is set
comm_tiled.cpp:    // setup other per swap/proc values from sendnum and recvnum
comm_tiled.cpp:    // insure send/recv buffers are large enough for this border comm swap
comm_tiled.cpp:    // swap atoms with other procs using pack_border(), unpack_border()
comm_tiled.cpp:    // use Waitall() instead of Waitany() because calls to unpack_border()
comm_tiled.cpp:    //   must increment per-atom arrays in ascending order
comm_tiled.cpp:    // increment ghost atoms
comm_tiled.cpp:  // insure send/recv buffers are long enough for all forward & reverse comm
comm_tiled.cpp:  // send buf is for one forward or reverse sends to one proc
comm_tiled.cpp:  // recv buf is for all forward or reverse recvs in one swap
comm_tiled.cpp:  // reset global->local map
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   size/nsize used only to set recv buffer limit
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   size/nsize used only to set recv buffer limit
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // insure send/recv bufs are big enough for nsize
comm_tiled.cpp:  // based on smaxone/rmaxall from most recent borders() invocation
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   determine overlap list of Noverlap procs the lo/hi box overlaps
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // NOTE: this is not triclinic compatible
comm_tiled.cpp:  // NOTE: these error messages are internal sanity checks
comm_tiled.cpp:  //       should not occur, can be removed at some point
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   determine overlap list of Noverlap procs the lo/hi box overlaps
comm_tiled.cpp:   no need to split lo/hi box as recurse b/c OK if box extends outside RCB box
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // end recursion when partition is a single proc
comm_tiled.cpp:  // add proc to overlap list
comm_tiled.cpp:  // drop box on each side of cut it extends beyond
comm_tiled.cpp:  // use > and < criteria so does not include a box it only touches
comm_tiled.cpp:  // procmid = 1st processor in upper half of partition
comm_tiled.cpp:  //         = location in tree that stores this cut
comm_tiled.cpp:  // dim = 0,1,2 dimension of cut
comm_tiled.cpp:  // cut = position of cut
comm_tiled.cpp:  int procmid = proclower + (procupper - proclower) / 2 + 1;
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   return other box owned by proc as lo/hi corner pts
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   return other box owned by proc as lo/hi corner pts
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // sending to left
comm_tiled.cpp:  // only touches if proc hi = my lo, or if proc hi = boxhi and my lo = boxlo
comm_tiled.cpp:  // sending to right
comm_tiled.cpp:  // only touches if proc lo = my hi, or if proc lo = boxlo and my hi = boxhi
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  // end recursion when partition is a single proc
comm_tiled.cpp:  // return proc
comm_tiled.cpp:  // drop point on side of cut it is on
comm_tiled.cpp:  // use < criterion so point is not on high edge of proc sub-domain
comm_tiled.cpp:  // procmid = 1st processor in upper half of partition
comm_tiled.cpp:  //         = location in tree that stores this cut
comm_tiled.cpp:  // dim = 0,1,2 dimension of cut
comm_tiled.cpp:  // cut = position of cut
comm_tiled.cpp:  int procmid = proclower + (procupper - proclower) / 2 + 1;
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   if flag = 0, don't need to realloc with copy, just free/malloc
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:   free/malloc the size of the recv buffer as needed with BUFFACTOR
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  nexchproc = new int[n/2];
comm_tiled.cpp:  nexchprocmax = new int[n/2];
comm_tiled.cpp:  exchproc = new int*[n/2];
comm_tiled.cpp:  exchnum = new int*[n/2];
comm_tiled.cpp:  for (int i = 0; i < n/2; i++) {
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
comm_tiled.cpp:  for (int i = 0; i < n/2; i++) {
comm_tiled.cpp:/* ----------------------------------------------------------------------
comm_tiled.cpp:------------------------------------------------------------------------- */
compute_angle.cpp:/* ----------------------------------------------------------------------
compute_angle.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_angle.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_angle.cpp:------------------------------------------------------------------------- */
compute_angle.cpp:/* ---------------------------------------------------------------------- */
compute_angle.cpp:  // check if bond style hybrid exists
compute_angle.cpp:/* ---------------------------------------------------------------------- */
compute_angle.cpp:/* ---------------------------------------------------------------------- */
compute_angle.cpp:  // recheck angle style in case it has been changed
compute_angle.cpp:/* ---------------------------------------------------------------------- */
compute_angle_local.cpp:/* ----------------------------------------------------------------------
compute_angle_local.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_angle_local.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_angle_local.cpp:------------------------------------------------------------------------- */
compute_angle_local.cpp:/* ---------------------------------------------------------------------- */
compute_angle_local.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute angle/local command");
compute_angle_local.cpp:    error->all(FLERR,"Compute angle/local used when angles are not allowed");
compute_angle_local.cpp:    else error->all(FLERR,"Invalid keyword in compute angle/local command");
compute_angle_local.cpp:/* ---------------------------------------------------------------------- */
compute_angle_local.cpp:/* ---------------------------------------------------------------------- */
compute_angle_local.cpp:    error->all(FLERR,"No angle style is defined for compute angle/local");
compute_angle_local.cpp:  // do initial memory allocation so that memory_usage() is correct
compute_angle_local.cpp:/* ---------------------------------------------------------------------- */
compute_angle_local.cpp:  // count local entries and compute angle info
compute_angle_local.cpp:/* ----------------------------------------------------------------------
compute_angle_local.cpp:------------------------------------------------------------------------- */
compute_angle_local.cpp:          // c = cosine of angle
compute_angle_local.cpp:          c /= r1*r2;
compute_angle_local.cpp:          tbuf[n] = 180.0*acos(c)/MY_PI;
compute_angle_local.cpp:/* ---------------------------------------------------------------------- */
compute_angle_local.cpp:  // grow vector_local or array_local
compute_angle_local.cpp:    memory->create(vlocal,nmax,"angle/local:vector_local");
compute_angle_local.cpp:    memory->create(alocal,nmax,nvalues,"angle/local:array_local");
compute_angle_local.cpp:/* ----------------------------------------------------------------------
compute_angle_local.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_angmom_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_angmom_chunk.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute angmom/chunk command");
compute_angmom_chunk.cpp:  // ID of compute chunk/atom
compute_angmom_chunk.cpp:  // chunk-based data
compute_angmom_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_angmom_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for "
compute_angmom_chunk.cpp:               "compute angmom/chunk");
compute_angmom_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_angmom_chunk.cpp:    error->all(FLERR,"Compute angmom/chunk does not use chunk/atom compute");
compute_angmom_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_angmom_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_angmom_chunk.cpp:  // extract ichunk index vector from compute
compute_angmom_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_angmom_chunk.cpp:  // zero local per-chunk values
compute_angmom_chunk.cpp:  // compute COM for each chunk
compute_angmom_chunk.cpp:      comall[i][0] /= masstotal[i];
compute_angmom_chunk.cpp:      comall[i][1] /= masstotal[i];
compute_angmom_chunk.cpp:      comall[i][2] /= masstotal[i];
compute_angmom_chunk.cpp:  // compute angmom for each chunk
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:   lock methods: called by fix ave/time
compute_angmom_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_angmom_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_angmom_chunk.cpp:  memory->create(massproc,maxchunk,"angmom/chunk:massproc");
compute_angmom_chunk.cpp:  memory->create(masstotal,maxchunk,"angmom/chunk:masstotal");
compute_angmom_chunk.cpp:  memory->create(com,maxchunk,3,"angmom/chunk:com");
compute_angmom_chunk.cpp:  memory->create(comall,maxchunk,3,"angmom/chunk:comall");
compute_angmom_chunk.cpp:  memory->create(angmom,maxchunk,3,"angmom/chunk:angmom");
compute_angmom_chunk.cpp:  memory->create(angmomall,maxchunk,3,"angmom/chunk:angmomall");
compute_angmom_chunk.cpp:/* ----------------------------------------------------------------------
compute_angmom_chunk.cpp:------------------------------------------------------------------------- */
compute_bond.cpp:/* ----------------------------------------------------------------------
compute_bond.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_bond.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_bond.cpp:------------------------------------------------------------------------- */
compute_bond.cpp:/* ---------------------------------------------------------------------- */
compute_bond.cpp:  // check if bond style hybrid exists
compute_bond.cpp:/* ---------------------------------------------------------------------- */
compute_bond.cpp:/* ---------------------------------------------------------------------- */
compute_bond.cpp:  // recheck bond style in case it has been changed
compute_bond.cpp:/* ---------------------------------------------------------------------- */
compute_bond_local.cpp:/* ----------------------------------------------------------------------
compute_bond_local.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_bond_local.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_bond_local.cpp:------------------------------------------------------------------------- */
compute_bond_local.cpp:/* ---------------------------------------------------------------------- */
compute_bond_local.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute bond/local command");
compute_bond_local.cpp:    error->all(FLERR,"Compute bond/local used when bonds are not allowed");
compute_bond_local.cpp:    else error->all(FLERR,"Invalid keyword in compute bond/local command");
compute_bond_local.cpp:  // set singleflag if need to call bond->single()
compute_bond_local.cpp:  // set velflag if compute any quantities based on velocities
compute_bond_local.cpp:/* ---------------------------------------------------------------------- */
compute_bond_local.cpp:/* ---------------------------------------------------------------------- */
compute_bond_local.cpp:    error->all(FLERR,"No bond style is defined for compute bond/local");
compute_bond_local.cpp:  // set ghostvelflag if need to acquire ghost atom velocities
compute_bond_local.cpp:  // do initial memory allocation so that memory_usage() is correct
compute_bond_local.cpp:/* ---------------------------------------------------------------------- */
compute_bond_local.cpp:  // count local entries and compute bond info
compute_bond_local.cpp:/* ----------------------------------------------------------------------
compute_bond_local.cpp:------------------------------------------------------------------------- */
compute_bond_local.cpp:  // communicate ghost velocities if needed
compute_bond_local.cpp:  // loop over all atoms and their bonds
compute_bond_local.cpp:          invmasstotal = 1.0 / (masstotal);
compute_bond_local.cpp:          // r12 = unit bond vector from atom1 to atom2
compute_bond_local.cpp:          // delr = vector from COM to each atom
compute_bond_local.cpp:          // delv = velocity of each atom relative to COM
compute_bond_local.cpp:          // vpar = component of delv parallel to bond vector
compute_bond_local.cpp:          // vvib = relative velocity of 2 atoms along bond direction
compute_bond_local.cpp:          // vvib < 0 for 2 atoms moving towards each other
compute_bond_local.cpp:          // vvib > 0 for 2 atoms moving apart
compute_bond_local.cpp:          // vrotsq = tangential speed squared of atom1 only
compute_bond_local.cpp:          // omegasq = omega squared, and is the same for atom1 and atom2
compute_bond_local.cpp:          omegasq = vrotsq / MathExtra::lensq3(delr1);
compute_bond_local.cpp:          // sanity check: engtotal = engtrans + engvib + engrot
compute_bond_local.cpp:          //engtot = 0.5 * (mass1*MathExtra::lensq3(v[atom1]) + 
compute_bond_local.cpp:          //                mass2*MathExtra::lensq3(v[atom2]));
compute_bond_local.cpp:          //if (fabs(engtot-engtrans-engvib-engrot) > EPSILON)
compute_bond_local.cpp:          //  error->one(FLERR,"Sanity check on 3 energy components failed");
compute_bond_local.cpp:          // scale energies by units
compute_bond_local.cpp:/* ---------------------------------------------------------------------- */
compute_bond_local.cpp:/* ---------------------------------------------------------------------- */
compute_bond_local.cpp:/* ---------------------------------------------------------------------- */
compute_bond_local.cpp:  // grow vector_local or array_local
compute_bond_local.cpp:    memory->create(vlocal,nmax,"bond/local:vector_local");
compute_bond_local.cpp:    memory->create(alocal,nmax,nvalues,"bond/local:array_local");
compute_bond_local.cpp:/* ----------------------------------------------------------------------
compute_bond_local.cpp:------------------------------------------------------------------------- */
compute_centro_atom.cpp:/* ----------------------------------------------------------------------
compute_centro_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_centro_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_centro_atom.cpp:------------------------------------------------------------------------- */
compute_centro_atom.cpp:/* ----------------------------------------------------------------------
compute_centro_atom.cpp:------------------------------------------------------------------------- */
compute_centro_atom.cpp:/* ---------------------------------------------------------------------- */
compute_centro_atom.cpp:  if (narg < 4 || narg > 6) error->all(FLERR,"Illegal compute centro/atom command");
compute_centro_atom.cpp:  // default values
compute_centro_atom.cpp:  // optional keywords
compute_centro_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute centro/atom command3");
compute_centro_atom.cpp:      else error->all(FLERR,"Illegal compute centro/atom command2");
compute_centro_atom.cpp:    } else error->all(FLERR,"Illegal compute centro/atom command1");
compute_centro_atom.cpp:    error->all(FLERR,"Illegal neighbor value for compute centro/atom command");
compute_centro_atom.cpp:/* ---------------------------------------------------------------------- */
compute_centro_atom.cpp:/* ---------------------------------------------------------------------- */
compute_centro_atom.cpp:    error->all(FLERR,"Compute centro/atom requires a pair style be defined");
compute_centro_atom.cpp:    if (strcmp(modify->compute[i]->style,"centro/atom") == 0) count++;
compute_centro_atom.cpp:    error->warning(FLERR,"More than one compute centro/atom");
compute_centro_atom.cpp:  // need an occasional full neighbor list
compute_centro_atom.cpp:/* ---------------------------------------------------------------------- */
compute_centro_atom.cpp:/* ---------------------------------------------------------------------- */
compute_centro_atom.cpp:  // grow centro array if necessary
compute_centro_atom.cpp:  // grow array_atom array if axes_flag set
compute_centro_atom.cpp:      memory->create(centro,nmax,"centro/atom:centro");
compute_centro_atom.cpp:      memory->create(centro,nmax,"centro/atom:centro");
compute_centro_atom.cpp:      memory->create(array_atom,nmax,size_peratom_cols,"centro/atom:array_atom");
compute_centro_atom.cpp:  // invoke full neighbor list (will copy or build if necessary)
compute_centro_atom.cpp:  // npairs = number of unique pairs
compute_centro_atom.cpp:  int nhalf = nnn/2;
compute_centro_atom.cpp:  int npairs = nnn * (nnn-1) / 2;
compute_centro_atom.cpp:  // compute centro-symmetry parameter for each atom in group
compute_centro_atom.cpp:  // use full neighbor list
compute_centro_atom.cpp:      // insure distsq and nearest arrays are long enough
compute_centro_atom.cpp:        memory->create(distsq,maxneigh,"centro/atom:distsq");
compute_centro_atom.cpp:        memory->create(nearest,maxneigh,"centro/atom:nearest");
compute_centro_atom.cpp:      // loop over list of all neighbors within force cutoff
compute_centro_atom.cpp:      // distsq[] = distance sq to each
compute_centro_atom.cpp:      // nearest[] = atom indices of neighbors
compute_centro_atom.cpp:      // check whether to include local crystal symmetry axes
compute_centro_atom.cpp:	// if not nnn neighbors, centro = 0.0
compute_centro_atom.cpp:	// store nnn nearest neighs in 1st nnn locations of distsq and nearest
compute_centro_atom.cpp:	// R = Ri + Rj for each of npairs i,j pairs among nnn neighbors
compute_centro_atom.cpp:	// pairs = squared length of each R
compute_centro_atom.cpp:	// calculate local crystal symmetry axes
compute_centro_atom.cpp:	// rsq1, rsq2 are two smallest values of R^2 
compute_centro_atom.cpp:	// R1, R2 are corresponding vectors Ri - Rj
compute_centro_atom.cpp:	// R3 is normal to R1, R2
compute_centro_atom.cpp:	// store nnn nearest neighs in 1st nnn locations of distsq and nearest
compute_centro_atom.cpp:      // store nhalf smallest pair distances in 1st nhalf locations of pairs
compute_centro_atom.cpp:      // centrosymmetry = sum of nhalf smallest squared values
compute_centro_atom.cpp:/* ----------------------------------------------------------------------
compute_centro_atom.cpp:------------------------------------------------------------------------- */
compute_centro_atom.cpp:/* ---------------------------------------------------------------------- */
compute_centro_atom.cpp:/* ----------------------------------------------------------------------
compute_centro_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_chunk_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:// NOTE: allow for bin center to be variables for sphere/cylinder
compute_chunk_atom.cpp:enum{ONCE,NFREQ,EVERY};              // used in several files
compute_chunk_atom.cpp:// allocate space for static class variable
compute_chunk_atom.cpp:/* ---------------------------------------------------------------------- */
compute_chunk_atom.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:  // chunk style and its args
compute_chunk_atom.cpp:  if (strcmp(arg[3],"bin/1d") == 0) {
compute_chunk_atom.cpp:  } else if (strcmp(arg[3],"bin/2d") == 0) {
compute_chunk_atom.cpp:  } else if (strcmp(arg[3],"bin/3d") == 0) {
compute_chunk_atom.cpp:  } else if (strcmp(arg[3],"bin/sphere") == 0) {
compute_chunk_atom.cpp:    if (iarg+6 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:  } else if (strcmp(arg[3],"bin/cylinder") == 0) {
compute_chunk_atom.cpp:    if (iarg+5 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:        error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:  } else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:  // optional args
compute_chunk_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:        error->all(FLERR,"Region ID for compute chunk/atom does not exist");
compute_chunk_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      if (limit < 0) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:          error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:        else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:    } else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:  // set nchunkflag and discard to default values if not explicitly set
compute_chunk_atom.cpp:  // for binning style, also check in init() if simulation box is static,
compute_chunk_atom.cpp:  //   which sets nchunkflag = ONCE
compute_chunk_atom.cpp:  // error checks
compute_chunk_atom.cpp:    error->all(FLERR,"Compute chunk/atom molecule for non-molecular system");
compute_chunk_atom.cpp:    error->all(FLERR,"Compute chunk/atom without bins "
compute_chunk_atom.cpp:    error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:    error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:    error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom sphere z origin must be 0.0 for 2d");
compute_chunk_atom.cpp:      error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom cylinder axis must be z for 2d");
compute_chunk_atom.cpp:      error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:      error->all(FLERR,"Compute ID for compute chunk /atom does not exist");
compute_chunk_atom.cpp:                 "Compute chunk/atom compute does not calculate "
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom compute does not "
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom compute does not "
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom compute array is "
compute_chunk_atom.cpp:      error->all(FLERR,"Fix ID for compute chunk/atom does not exist");
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom fix does not calculate "
compute_chunk_atom.cpp:                 "Compute chunk/atom fix does not calculate a per-atom vector");
compute_chunk_atom.cpp:                 "Compute chunk/atom fix does not calculate a per-atom array");
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom fix array is accessed out-of-range");
compute_chunk_atom.cpp:      error->all(FLERR,"Variable name for compute chunk/atom does not exist");
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom variable is not "
compute_chunk_atom.cpp:  // setup scaling
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom for triclinic boxes "
compute_chunk_atom.cpp:  // apply scaling factors and cylinder dims orthogonal to axis
compute_chunk_atom.cpp:	invdelta[idim] = 1.0/delta[idim];
compute_chunk_atom.cpp:      sradmin_user *= xscale;     // radii are scaled by xscale
compute_chunk_atom.cpp:        cradmin_user *= yscale;     // radii are scaled by first non-axis dim
compute_chunk_atom.cpp:  // initialize chunk vector and per-chunk info
compute_chunk_atom.cpp:  // computeflag = 1 if this compute might invoke another compute
compute_chunk_atom.cpp:  // during assign_chunk_ids()
compute_chunk_atom.cpp:  // other initializations
compute_chunk_atom.cpp:/* ---------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // check nfix in case all fixes have already been deleted
compute_chunk_atom.cpp:/* ---------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // set and check validity of region
compute_chunk_atom.cpp:      error->all(FLERR,"Region ID for compute chunk/atom does not exist");
compute_chunk_atom.cpp:  // set compute,fix,variable
compute_chunk_atom.cpp:      error->all(FLERR,"Compute ID for compute chunk/atom does not exist");
compute_chunk_atom.cpp:      error->all(FLERR,"Fix ID for compute chunk/atom does not exist");
compute_chunk_atom.cpp:      error->all(FLERR,"Variable name for compute chunk/atom does not exist");
compute_chunk_atom.cpp:  // for style MOLECULE, check that no mol IDs exceed MAXSMALLINT
compute_chunk_atom.cpp:  // don't worry about group or optional region
compute_chunk_atom.cpp:      error->all(FLERR,"Molecule IDs too large for compute chunk/atom");
compute_chunk_atom.cpp:  // for binning, if nchunkflag not already set, set it to ONCE or EVERY
compute_chunk_atom.cpp:  // depends on whether simulation box size is static or dynamic
compute_chunk_atom.cpp:  // reset invoked_setup if this is not first run and box just became static
compute_chunk_atom.cpp:  // require nchunkflag = ONCE if idsflag = ONCE
compute_chunk_atom.cpp:  // b/c nchunk cannot change if chunk IDs are frozen
compute_chunk_atom.cpp:  // can't check until now since nchunkflag may have been adjusted in init()
compute_chunk_atom.cpp:    error->all(FLERR,"Compute chunk/atom ids once but nchunk is not once");
compute_chunk_atom.cpp:  // create/destroy fix STORE for persistent chunk IDs as needed
compute_chunk_atom.cpp:  // need to do this if idsflag = ONCE or locks will be used by other commands
compute_chunk_atom.cpp:  // need to wait until init() so that fix command(s) are in place
compute_chunk_atom.cpp:  //   they increment lockcount if they lock this compute
compute_chunk_atom.cpp:  // fixstore ID = compute-ID + COMPUTE_STORE, fix group = compute group
compute_chunk_atom.cpp:  // fixstore initializes all values to 0.0
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:   invoke setup_chunks and/or compute_ichunk if only done ONCE
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // grow floating point chunk vector if necessary
compute_chunk_atom.cpp:    memory->create(chunk,nmax,"chunk/atom:chunk");
compute_chunk_atom.cpp:  // copy integer indices into floating-point chunk vector
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:               "same compute chunk/atom command in incompatible ways");
compute_chunk_atom.cpp:  // set lock to last calling Fix, since it will be last to unlock()
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // skip if already done on this step
compute_chunk_atom.cpp:  // if old IDs persist via storage in fixstore, then just retrieve them
compute_chunk_atom.cpp:  // yes if idsflag = ONCE, and already done once
compute_chunk_atom.cpp:  //   or if idsflag = NFREQ and lock is in place and are on later timestep
compute_chunk_atom.cpp:  // else proceed to recalculate per-atom chunk assignments
compute_chunk_atom.cpp:  // assign chunk IDs to atoms
compute_chunk_atom.cpp:  // will exclude atoms not in group or in optional region
compute_chunk_atom.cpp:  // already invoked if this is same timestep as last setup_chunks()
compute_chunk_atom.cpp:  // compress chunk IDs via hash of the original uncompressed IDs
compute_chunk_atom.cpp:  // also apply discard rule except for binning styles which already did
compute_chunk_atom.cpp:  // else if no compression apply discard rule by itself
compute_chunk_atom.cpp:  // set ichunk = 0 for excluded atoms
compute_chunk_atom.cpp:  // this should set any ichunk values which have not yet been set
compute_chunk_atom.cpp:  // if newly calculated IDs need to persist, store them in fixstore
compute_chunk_atom.cpp:  // yes if idsflag = ONCE or idsflag = NFREQ and lock is in place
compute_chunk_atom.cpp:  // one-time check if which = MOLECULE and
compute_chunk_atom.cpp:  // any chunks do not contain all atoms in the molecule
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // check if setup needs to be done
compute_chunk_atom.cpp:  // no if lock is in place
compute_chunk_atom.cpp:  // no if nchunkflag = ONCE, and already done once
compute_chunk_atom.cpp:  // otherwise yes
compute_chunk_atom.cpp:  // even if no, check if need to re-compute bin volumes
compute_chunk_atom.cpp:  //   so that fix ave/chunk can do proper density normalization
compute_chunk_atom.cpp:  // assign chunk IDs to atoms
compute_chunk_atom.cpp:  // will exclude atoms not in group or in optional region
compute_chunk_atom.cpp:  // for binning styles, need to setup bins and their volume first
compute_chunk_atom.cpp:  //   else chunk_volume_scalar = entire box volume
compute_chunk_atom.cpp:  // IDs are needed to scan for max ID and for compress()
compute_chunk_atom.cpp:  // set nchunk for chunk styles other than binning
compute_chunk_atom.cpp:  // for styles other than TYPE, scan for max ID
compute_chunk_atom.cpp:  // apply limit setting as well as compression of chunks with no atoms
compute_chunk_atom.cpp:  // if limit is set, there are 3 cases:
compute_chunk_atom.cpp:  //   no compression, limit specified before compression, or vice versa
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:   also set exclude vector to 0/1 for all atoms
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // grow integer chunk index vector if necessary
compute_chunk_atom.cpp:    memory->create(ichunk,nmaxint,"chunk/atom:ichunk");
compute_chunk_atom.cpp:    memory->create(exclude,nmaxint,"chunk/atom:exclude");
compute_chunk_atom.cpp:  // update region if necessary
compute_chunk_atom.cpp:  // exclude = 1 if atom is not assigned to a chunk
compute_chunk_atom.cpp:  // exclude atoms not in group or not in optional region
compute_chunk_atom.cpp:  // set ichunk to style value for included atoms
compute_chunk_atom.cpp:  // binning styles apply discard rule, others do not yet
compute_chunk_atom.cpp:      error->all(FLERR,"Fix used in compute chunk/atom not "
compute_chunk_atom.cpp:      memory->create(varatom,maxvar,"chunk/atom:varatom");
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // put my IDs into hash
compute_chunk_atom.cpp:  // n = # of my populated IDs
compute_chunk_atom.cpp:  // nall = n summed across all procs
compute_chunk_atom.cpp:  // create my list of populated IDs
compute_chunk_atom.cpp:  memory->create(list,n,"chunk/atom:list");
compute_chunk_atom.cpp:  // if nall < 1M, just allgather all ID lists on every proc
compute_chunk_atom.cpp:  // else perform ring comm
compute_chunk_atom.cpp:  // add IDs from all procs to my hash
compute_chunk_atom.cpp:    // setup for allgatherv
compute_chunk_atom.cpp:    memory->create(recvcounts,nprocs,"chunk/atom:recvcounts");
compute_chunk_atom.cpp:    memory->create(displs,nprocs,"chunk/atom:displs");
compute_chunk_atom.cpp:    memory->create(listall,nall,"chunk/atom:listall");
compute_chunk_atom.cpp:    // allgatherv acquires list of populated IDs from all procs
compute_chunk_atom.cpp:    // add all unique IDs in listall to my hash
compute_chunk_atom.cpp:    // clean up
compute_chunk_atom.cpp:  // nchunk = length of hash containing populated IDs from all procs
compute_chunk_atom.cpp:  // reset hash value of each original chunk ID to ordered index
compute_chunk_atom.cpp:  //   ordered index = new compressed chunk ID (1 to Nchunk)
compute_chunk_atom.cpp:  //   leverages fact that map stores keys in ascending order
compute_chunk_atom.cpp:  // also allocate and set chunkID = list of original chunk IDs
compute_chunk_atom.cpp:  //   used by fix ave/chunk and compute property/chunk
compute_chunk_atom.cpp:  memory->create(chunkID,nchunk,"chunk/atom:chunkID");
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // lo = bin boundary immediately below boxlo or minvalue
compute_chunk_atom.cpp:  // hi = bin boundary immediately above boxhi or maxvalue
compute_chunk_atom.cpp:  // allocate and initialize arrays based on new bin count
compute_chunk_atom.cpp:    if (lo > hi) error->all(FLERR,"Invalid bin bounds in compute chunk/atom");
compute_chunk_atom.cpp:  // allocate and set bin coordinates
compute_chunk_atom.cpp:  memory->create(coord,nbins,ndim,"chunk/atom:coord");
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // convert sorigin_user to sorigin
compute_chunk_atom.cpp:  // sorigin,srad are always in box units, for orthogonal or triclinic domains
compute_chunk_atom.cpp:  // lamda2x works for either orthogonal or triclinic
compute_chunk_atom.cpp:  // if pbcflag set, sradmax must be < 1/2 box in any periodic dim
compute_chunk_atom.cpp:  // treat orthogonal and triclinic the same
compute_chunk_atom.cpp:  // check every time bins are created
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom bin/sphere radius "
compute_chunk_atom.cpp:  sinvrad = nsbin / (sradmax-sradmin);
compute_chunk_atom.cpp:  // allocate and set bin coordinates
compute_chunk_atom.cpp:  // coord = midpt of radii for a spherical shell
compute_chunk_atom.cpp:  memory->create(coord,nsbin,1,"chunk/atom:coord");
compute_chunk_atom.cpp:    rlo = sradmin + i * (sradmax-sradmin) / nsbin;
compute_chunk_atom.cpp:    rhi = sradmin + (i+1) * (sradmax-sradmin) / nsbin;
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // setup bins along cylinder axis
compute_chunk_atom.cpp:  // ncplane = # of axis bins
compute_chunk_atom.cpp:  // convert corigin_user to corigin
compute_chunk_atom.cpp:  // corigin is always in box units, for orthogonal or triclinic domains
compute_chunk_atom.cpp:  // lamda2x works for either orthogonal or triclinic
compute_chunk_atom.cpp:  // if pbcflag set, sradmax must be < 1/2 box in any periodic non-axis dim
compute_chunk_atom.cpp:  // treat orthogonal and triclinic the same
compute_chunk_atom.cpp:  // check every time bins are created
compute_chunk_atom.cpp:      error->all(FLERR,"Compute chunk/atom bin/cylinder radius "
compute_chunk_atom.cpp:  cinvrad = ncbin / (cradmax-cradmin);
compute_chunk_atom.cpp:  // allocate and set radial bin coordinates
compute_chunk_atom.cpp:  // radial coord = midpt of radii for a cylindrical shell
compute_chunk_atom.cpp:  // axiscoord = saved bin coords along cylndrical axis
compute_chunk_atom.cpp:  // radcoord = saved bin coords in radial direction
compute_chunk_atom.cpp:  memory->create(coord,ncbin,1,"chunk/atom:coord");
compute_chunk_atom.cpp:    rlo = cradmin + i * (cradmax-cradmin) / ncbin;
compute_chunk_atom.cpp:    rhi = cradmin + (i+1) * (cradmax-cradmin) / ncbin;
compute_chunk_atom.cpp:  // create array of combined coords for all bins
compute_chunk_atom.cpp:  memory->create(coord,ncbin*ncplane,2,"chunk/atom:coord");
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:      chunk_volume_scalar *= delta[m]/prd[dim[m]];
compute_chunk_atom.cpp:    memory->create(chunk_volume_vec,nchunk,"chunk/atom:chunk_volume_vec");
compute_chunk_atom.cpp:      rlo = sradmin + i * (sradmax-sradmin) / nsbin;
compute_chunk_atom.cpp:      rhi = sradmin + (i+1) * (sradmax-sradmin) / nsbin;
compute_chunk_atom.cpp:      vollo = 4.0/3.0 * MY_PI * rlo*rlo*rlo;
compute_chunk_atom.cpp:      volhi = 4.0/3.0 * MY_PI * rhi*rhi*rhi;
compute_chunk_atom.cpp:    memory->create(chunk_volume_vec,nchunk,"chunk/atom:chunk_volume_vec");
compute_chunk_atom.cpp:    // slabthick = delta of bins along cylinder axis
compute_chunk_atom.cpp:    double slabthick = domain->prd[dim[0]] * delta[0]/prd[dim[0]];
compute_chunk_atom.cpp:    // area lo/hi of concentric circles in radial direction
compute_chunk_atom.cpp:      iradbin = i / ncplane;
compute_chunk_atom.cpp:      rlo = cradmin + iradbin * (cradmax-cradmin) / ncbin;
compute_chunk_atom.cpp:      rhi = cradmin + (iradbin+1) * (cradmax-cradmin) / ncbin;
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // remap each atom's relevant coord back into box via PBC if necessary
compute_chunk_atom.cpp:  // if scaleflag = REDUCED, box coords -> lamda coords
compute_chunk_atom.cpp:  // apply discard rule
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // remap each atom's relevant coord back into box via PBC if necessary
compute_chunk_atom.cpp:  // if scaleflag = REDUCED, box coords -> lamda coords
compute_chunk_atom.cpp:  // apply discard rule
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // remap each atom's relevant coord back into box via PBC if necessary
compute_chunk_atom.cpp:  // if scaleflag = REDUCED, box coords -> lamda coords
compute_chunk_atom.cpp:  // apply discard rule
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // remap each atom's relevant coords back into box via PBC if necessary
compute_chunk_atom.cpp:  // apply discard rule based on rmin and rmax
compute_chunk_atom.cpp:    // if requested, apply PBC to distance from sphere center
compute_chunk_atom.cpp:    // treat orthogonal and triclinic the same
compute_chunk_atom.cpp:    //   with dx,dy,dz = lengths independent of each other
compute_chunk_atom.cpp:    // so do not use domain->minimum_image() which couples for triclinic
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  // first use atom2bin1d() to bin all atoms along cylinder axis
compute_chunk_atom.cpp:  // now bin in radial direction
compute_chunk_atom.cpp:  // kbin = bin along cylinder axis
compute_chunk_atom.cpp:  // rbin = bin in radial direction
compute_chunk_atom.cpp:  // remap each atom's relevant coords back into box via PBC if necessary
compute_chunk_atom.cpp:  // apply discard rule based on rmin and rmax
compute_chunk_atom.cpp:    // if requested, apply PBC to distance from cylinder axis
compute_chunk_atom.cpp:    // treat orthogonal and triclinic the same
compute_chunk_atom.cpp:    //   with d1,d2 = lengths independent of each other
compute_chunk_atom.cpp:    // combine axis and radial bin indices to set ichunk
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  if (narg < iarg+3) error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:  else error->all(FLERR,"Illegal compute chunk/atom command");
compute_chunk_atom.cpp:    error->all(FLERR,"Cannot use compute chunk/atom bin z for 2d model");
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:/* ----------------------------------------------------------------------
compute_chunk_atom.cpp:------------------------------------------------------------------------- */
compute_chunk_atom.cpp:  double bytes = 2*MAX(nmaxint,0) * sizeof(int);   // ichunk,exclude
compute_chunk_atom.cpp:  bytes += nmax * sizeof(double);                  // chunk
compute_chunk_atom.cpp:  bytes += ncoord*nchunk * sizeof(double);         // coord
compute_chunk_atom.cpp:  if (compress) bytes += nchunk * sizeof(int);     // chunkID
compute_cluster_atom.cpp:/* ----------------------------------------------------------------------
compute_cluster_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_cluster_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_cluster_atom.cpp:------------------------------------------------------------------------- */
compute_cluster_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cluster_atom.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute cluster/atom command");
compute_cluster_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cluster_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cluster_atom.cpp:    error->all(FLERR,"Cannot use compute cluster/atom unless atoms have IDs");
compute_cluster_atom.cpp:    error->all(FLERR,"Compute cluster/atom requires a pair style be defined");
compute_cluster_atom.cpp:               "Compute cluster/atom cutoff is longer than pairwise cutoff");
compute_cluster_atom.cpp:  // need an occasional full neighbor list
compute_cluster_atom.cpp:  // full required so that pair of atoms on 2 procs both set their clusterID
compute_cluster_atom.cpp:    if (strcmp(modify->compute[i]->style,"cluster/atom") == 0) count++;
compute_cluster_atom.cpp:    error->warning(FLERR,"More than one compute cluster/atom");
compute_cluster_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cluster_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cluster_atom.cpp:  // grow clusterID array if necessary
compute_cluster_atom.cpp:    memory->create(clusterID,nmax,"cluster/atom:clusterID");
compute_cluster_atom.cpp:  // invoke full neighbor list (will copy or build if necessary)
compute_cluster_atom.cpp:  // if group is dynamic, insure ghost atom masks are current
compute_cluster_atom.cpp:  // every atom starts in its own cluster, with clusterID = atomID
compute_cluster_atom.cpp:  // loop until no more changes on any proc:
compute_cluster_atom.cpp:  // acquire clusterIDs of ghost atoms
compute_cluster_atom.cpp:  // loop over my atoms, checking distance to neighbors
compute_cluster_atom.cpp:  // if both atoms are in cluster, assign lowest clusterID to both
compute_cluster_atom.cpp:  // iterate until no changes in my atoms
compute_cluster_atom.cpp:  // then check if any proc made changes
compute_cluster_atom.cpp:    // stop if all procs are done
compute_cluster_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cluster_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cluster_atom.cpp:/* ----------------------------------------------------------------------
compute_cluster_atom.cpp:------------------------------------------------------------------------- */
compute_cna_atom.cpp:/* ----------------------------------------------------------------------
compute_cna_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_cna_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_cna_atom.cpp:------------------------------------------------------------------------- */
compute_cna_atom.cpp:/* ----------------------------------------------------------------------
compute_cna_atom.cpp:------------------------------------------------------------------------- */
compute_cna_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cna_atom.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute cna/atom command");
compute_cna_atom.cpp:  if (cutoff < 0.0) error->all(FLERR,"Illegal compute cna/atom command");
compute_cna_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cna_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cna_atom.cpp:    error->all(FLERR,"Compute cna/atom requires a pair style be defined");
compute_cna_atom.cpp:    error->all(FLERR,"Compute cna/atom cutoff is longer than pairwise cutoff");
compute_cna_atom.cpp:  // cannot use neighbor->cutneighmax b/c neighbor has not yet been init
compute_cna_atom.cpp:    error->warning(FLERR,"Compute cna/atom cutoff may be too large to find "
compute_cna_atom.cpp:    if (strcmp(modify->compute[i]->style,"cna/atom") == 0) count++;
compute_cna_atom.cpp:    error->warning(FLERR,"More than one compute cna/atom defined");
compute_cna_atom.cpp:  // need an occasional full neighbor list
compute_cna_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cna_atom.cpp:/* ---------------------------------------------------------------------- */
compute_cna_atom.cpp:  // grow arrays if necessary
compute_cna_atom.cpp:  // invoke full neighbor list (will copy or build if necessary)
compute_cna_atom.cpp:  // find the neigbours of each atom within cutoff using full neighbor list
compute_cna_atom.cpp:  // nearest[] = atom indices of nearest neighbors, up to MAXNEAR
compute_cna_atom.cpp:  // do this for all atoms, not just compute group
compute_cna_atom.cpp:  // since CNA calculation requires neighbors of neighbors
compute_cna_atom.cpp:  // warning message
compute_cna_atom.cpp:  // compute CNA for each atom in group
compute_cna_atom.cpp:  // only performed if # of nearest neighbors = 12 or 14 (fcc,hcp)
compute_cna_atom.cpp:    // loop over near neighbors of I to build cna data structure
compute_cna_atom.cpp:    // cna[k][NCOMMON] = # of common neighbors of I with each of its neighs
compute_cna_atom.cpp:    // cna[k][NBONDS] = # of bonds between those common neighbors
compute_cna_atom.cpp:    // cna[k][MAXBOND] = max # of bonds of any common neighbor
compute_cna_atom.cpp:    // cna[k][MINBOND] = min # of bonds of any common neighbor
compute_cna_atom.cpp:      // common = list of neighbors common to atom I and atom J
compute_cna_atom.cpp:      // if J is an owned atom, use its near neighbor list to find them
compute_cna_atom.cpp:      // if J is a ghost atom, use full neighbor list of I to find them
compute_cna_atom.cpp:      // in latter case, must exclude J from I's neighbor list
compute_cna_atom.cpp:      // calculate total # of bonds between common neighbor atoms
compute_cna_atom.cpp:      // also max and min # of common atoms any common atom is bonded to
compute_cna_atom.cpp:      // bond = pair of atoms within cutoff
compute_cna_atom.cpp:    // detect CNA pattern of the atom
compute_cna_atom.cpp:  // warning message
compute_cna_atom.cpp:/* ----------------------------------------------------------------------
compute_cna_atom.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_com_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_com_chunk.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute com/chunk command");
compute_com_chunk.cpp:  // ID of compute chunk/atom
compute_com_chunk.cpp:  // chunk-based data
compute_com_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_com_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for compute com/chunk");
compute_com_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_com_chunk.cpp:    error->all(FLERR,"Compute com/chunk does not use chunk/atom compute");
compute_com_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_com_chunk.cpp:  // one-time calculation of per-chunk mass
compute_com_chunk.cpp:  // done in setup, so that ComputeChunkAtom::setup() is already called
compute_com_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_com_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_com_chunk.cpp:  // extract ichunk index vector from compute
compute_com_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_com_chunk.cpp:  // zero local per-chunk values
compute_com_chunk.cpp:  // compute COM for each chunk
compute_com_chunk.cpp:      comall[i][0] /= masstotal[i];
compute_com_chunk.cpp:      comall[i][1] /= masstotal[i];
compute_com_chunk.cpp:      comall[i][2] /= masstotal[i];
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:   lock methods: called by fix ave/time
compute_com_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_com_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com_chunk.cpp:  memory->create(massproc,maxchunk,"com/chunk:massproc");
compute_com_chunk.cpp:  memory->create(masstotal,maxchunk,"com/chunk:masstotal");
compute_com_chunk.cpp:  memory->create(com,maxchunk,3,"com/chunk:com");
compute_com_chunk.cpp:  memory->create(comall,maxchunk,3,"com/chunk:comall");
compute_com_chunk.cpp:/* ----------------------------------------------------------------------
compute_com_chunk.cpp:------------------------------------------------------------------------- */
compute_com.cpp:/* ----------------------------------------------------------------------
compute_com.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_com.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_com.cpp:------------------------------------------------------------------------- */
compute_com.cpp:/* ---------------------------------------------------------------------- */
compute_com.cpp:/* ---------------------------------------------------------------------- */
compute_com.cpp:/* ---------------------------------------------------------------------- */
compute_com.cpp:/* ---------------------------------------------------------------------- */
compute_contact_atom.cpp:/* ----------------------------------------------------------------------
compute_contact_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_contact_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_contact_atom.cpp:------------------------------------------------------------------------- */
compute_contact_atom.cpp:/* ---------------------------------------------------------------------- */
compute_contact_atom.cpp:  if (narg != 3) error->all(FLERR,"Illegal compute contact/atom command");
compute_contact_atom.cpp:  // error checks
compute_contact_atom.cpp:    error->all(FLERR,"Compute contact/atom requires atom style sphere");
compute_contact_atom.cpp:/* ---------------------------------------------------------------------- */
compute_contact_atom.cpp:/* ---------------------------------------------------------------------- */
compute_contact_atom.cpp:    error->all(FLERR,"Compute contact/atom requires a pair style be defined");
compute_contact_atom.cpp:    if (strcmp(modify->compute[i]->style,"contact/atom") == 0) count++;
compute_contact_atom.cpp:    error->warning(FLERR,"More than one compute contact/atom");
compute_contact_atom.cpp:  // need an occasional neighbor list
compute_contact_atom.cpp:/* ---------------------------------------------------------------------- */
compute_contact_atom.cpp:/* ---------------------------------------------------------------------- */
compute_contact_atom.cpp:  // grow contact array if necessary
compute_contact_atom.cpp:    memory->create(contact,nmax,"contact/atom:contact");
compute_contact_atom.cpp:  // invoke neighbor list (will copy or build if necessary)
compute_contact_atom.cpp:  // compute number of contacts for each atom in group
compute_contact_atom.cpp:  // contact if distance <= sum of radii
compute_contact_atom.cpp:  // tally for both I and J
compute_contact_atom.cpp:  // communicate ghost atom counts between neighbor procs if necessary
compute_contact_atom.cpp:/* ---------------------------------------------------------------------- */
compute_contact_atom.cpp:/* ---------------------------------------------------------------------- */
compute_contact_atom.cpp:/* ----------------------------------------------------------------------
compute_contact_atom.cpp:------------------------------------------------------------------------- */
compute_coord_atom.cpp:/* ----------------------------------------------------------------------
compute_coord_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_coord_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_coord_atom.cpp:------------------------------------------------------------------------- */
compute_coord_atom.cpp:/* ---------------------------------------------------------------------- */
compute_coord_atom.cpp:  if (narg < 5) error->all(FLERR,"Illegal compute coord/atom command");
compute_coord_atom.cpp:          error->all(FLERR,"Illegal compute coord/atom command");
compute_coord_atom.cpp:    if (narg != 6) error->all(FLERR,"Illegal compute coord/atom command");
compute_coord_atom.cpp:      error->all(FLERR,"Could not find compute coord/atom compute ID");
compute_coord_atom.cpp:    if (strcmp(modify->compute[iorientorder]->style,"orientorder/atom") != 0)
compute_coord_atom.cpp:      error->all(FLERR,"Compute coord/atom compute ID is not orientorder/atom");
compute_coord_atom.cpp:      error->all(FLERR,"Compute coord/atom threshold not between -1 and 1");
compute_coord_atom.cpp:  } else error->all(FLERR,"Invalid cstyle in compute coord/atom");
compute_coord_atom.cpp:/* ---------------------------------------------------------------------- */
compute_coord_atom.cpp:/* ---------------------------------------------------------------------- */
compute_coord_atom.cpp:    //  communicate real and imaginary 2*l+1 components of the normalized vector
compute_coord_atom.cpp:      error->all(FLERR,"Compute coord/atom requires components "
compute_coord_atom.cpp:                 "option in compute orientorder/atom");
compute_coord_atom.cpp:    error->all(FLERR,"Compute coord/atom requires a pair style be defined");
compute_coord_atom.cpp:               "Compute coord/atom cutoff is longer than pairwise cutoff");
compute_coord_atom.cpp:  // need an occasional full neighbor list
compute_coord_atom.cpp:    if (strcmp(modify->compute[i]->style,"coord/atom") == 0) count++;
compute_coord_atom.cpp:    error->warning(FLERR,"More than one compute coord/atom");
compute_coord_atom.cpp:/* ---------------------------------------------------------------------- */
compute_coord_atom.cpp:/* ---------------------------------------------------------------------- */
compute_coord_atom.cpp:  // grow coordination array if necessary
compute_coord_atom.cpp:      memory->create(cvec,nmax,"coord/atom:cvec");
compute_coord_atom.cpp:      memory->create(carray,nmax,ncol,"coord/atom:carray");
compute_coord_atom.cpp:  // invoke full neighbor list (will copy or build if necessary)
compute_coord_atom.cpp:  // compute coordination number(s) for each atom in group
compute_coord_atom.cpp:  // use full neighbor list to count atoms less than cutoff
compute_coord_atom.cpp:/* ---------------------------------------------------------------------- */
compute_coord_atom.cpp:/* ---------------------------------------------------------------------- */
compute_coord_atom.cpp:/* ----------------------------------------------------------------------
compute_coord_atom.cpp:------------------------------------------------------------------------- */
compute.cpp:/* ----------------------------------------------------------------------
compute.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute.cpp:------------------------------------------------------------------------- */
compute.cpp:// allocate space for static class instance variable and initialize it
compute.cpp:/* ---------------------------------------------------------------------- */
compute.cpp:  // compute ID, group, and style
compute.cpp:  // ID must be all alphanumeric chars or underscores
compute.cpp:  // set child class defaults
compute.cpp:  // set modify defaults
compute.cpp:  // setup list of timesteps
compute.cpp:  // data masks
compute.cpp:/* ---------------------------------------------------------------------- */
compute.cpp:/* ---------------------------------------------------------------------- */
compute.cpp:    // added more specific keywords in Mar17
compute.cpp:    // at some point, remove generic extra and dynamic
compute.cpp:        strcmp(arg[iarg],"extra/dof") == 0) {
compute.cpp:               strcmp(arg[iarg],"dynamic/dof") == 0) {
compute.cpp:/* ----------------------------------------------------------------------
compute.cpp:------------------------------------------------------------------------- */
compute.cpp:/* ----------------------------------------------------------------------
compute.cpp:------------------------------------------------------------------------- */
compute.cpp:/* ---------------------------------------------------------------------- */
compute.cpp:/* ----------------------------------------------------------------------
compute.cpp:------------------------------------------------------------------------- */
compute.cpp:  // i = location in list to insert ntimestep
compute.cpp:  // extend list as needed
compute.cpp:  // move remainder of list upward and insert ntimestep
compute.cpp:/* ----------------------------------------------------------------------
compute.cpp:   return 1/0 if ntimestep is or is not in list of calling timesteps
compute.cpp:------------------------------------------------------------------------- */
compute.cpp:/* ----------------------------------------------------------------------
compute.cpp:------------------------------------------------------------------------- */
compute_dihedral.cpp:/* ----------------------------------------------------------------------
compute_dihedral.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_dihedral.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_dihedral.cpp:------------------------------------------------------------------------- */
compute_dihedral.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral.cpp:  // check if dihedral style hybrid exists
compute_dihedral.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral.cpp:  // recheck dihedral style in case it has been changed
compute_dihedral.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral_local.cpp:/* ----------------------------------------------------------------------
compute_dihedral_local.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_dihedral_local.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_dihedral_local.cpp:------------------------------------------------------------------------- */
compute_dihedral_local.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral_local.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute dihedral/local command");
compute_dihedral_local.cpp:               "Compute dihedral/local used when dihedrals are not allowed");
compute_dihedral_local.cpp:    else error->all(FLERR,"Invalid keyword in compute dihedral/local command");
compute_dihedral_local.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral_local.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral_local.cpp:    error->all(FLERR,"No dihedral style is defined for compute dihedral/local");
compute_dihedral_local.cpp:  // do initial memory allocation so that memory_usage() is correct
compute_dihedral_local.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral_local.cpp:  // count local entries and compute dihedral info
compute_dihedral_local.cpp:/* ----------------------------------------------------------------------
compute_dihedral_local.cpp:------------------------------------------------------------------------- */
compute_dihedral_local.cpp:        // phi calculation from dihedral style harmonic
compute_dihedral_local.cpp:          if (rasq > 0) ra2inv = 1.0/rasq;
compute_dihedral_local.cpp:          if (rbsq > 0) rb2inv = 1.0/rbsq;
compute_dihedral_local.cpp:          pbuf[n] = 180.0*atan2(s,c)/MY_PI;
compute_dihedral_local.cpp:/* ---------------------------------------------------------------------- */
compute_dihedral_local.cpp:  // grow vector_local or array_local
compute_dihedral_local.cpp:    memory->create(vlocal,nmax,"dihedral/local:vector_local");
compute_dihedral_local.cpp:    memory->create(alocal,nmax,nvalues,"dihedral/local:array_local");
compute_dihedral_local.cpp:/* ----------------------------------------------------------------------
compute_dihedral_local.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_dipole_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_dipole_chunk.cpp:    error->all(FLERR,"Illegal compute dipole/chunk command");
compute_dipole_chunk.cpp:  // ID of compute chunk/atom
compute_dipole_chunk.cpp:    else error->all(FLERR,"Illegal compute dipole/chunk command");
compute_dipole_chunk.cpp:  // chunk-based data
compute_dipole_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_dipole_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for "
compute_dipole_chunk.cpp:               "compute dipole/chunk");
compute_dipole_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_dipole_chunk.cpp:    error->all(FLERR,"Compute dipole/chunk does not use chunk/atom compute");
compute_dipole_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_dipole_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_dipole_chunk.cpp:  // extract ichunk index vector from compute
compute_dipole_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_dipole_chunk.cpp:  // zero local per-chunk values
compute_dipole_chunk.cpp:  // compute COM for each chunk
compute_dipole_chunk.cpp:      } else massone = 1.0;     // usecenter == GEOMCENTER
compute_dipole_chunk.cpp:      comall[i][0] /= masstotal[i];
compute_dipole_chunk.cpp:      comall[i][1] /= masstotal[i];
compute_dipole_chunk.cpp:      comall[i][2] /= masstotal[i];
compute_dipole_chunk.cpp:  // compute dipole for each chunk
compute_dipole_chunk.cpp:    // correct for position dependence with charged chunks
compute_dipole_chunk.cpp:    // compute total dipole moment
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:   lock methods: called by fix ave/time
compute_dipole_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_dipole_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_dipole_chunk.cpp:  memory->create(massproc,maxchunk,"dipole/chunk:massproc");
compute_dipole_chunk.cpp:  memory->create(masstotal,maxchunk,"dipole/chunk:masstotal");
compute_dipole_chunk.cpp:  memory->create(chrgproc,maxchunk,"dipole/chunk:chrgproc");
compute_dipole_chunk.cpp:  memory->create(chrgtotal,maxchunk,"dipole/chunk:chrgtotal");
compute_dipole_chunk.cpp:  memory->create(com,maxchunk,3,"dipole/chunk:com");
compute_dipole_chunk.cpp:  memory->create(comall,maxchunk,3,"dipole/chunk:comall");
compute_dipole_chunk.cpp:  memory->create(dipole,maxchunk,4,"dipole/chunk:dipole");
compute_dipole_chunk.cpp:  memory->create(dipoleall,maxchunk,4,"dipole/chunk:dipoleall");
compute_dipole_chunk.cpp:/* ----------------------------------------------------------------------
compute_dipole_chunk.cpp:------------------------------------------------------------------------- */
compute_displace_atom.cpp:/* ----------------------------------------------------------------------
compute_displace_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_displace_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_displace_atom.cpp:------------------------------------------------------------------------- */
compute_displace_atom.cpp:/* ---------------------------------------------------------------------- */
compute_displace_atom.cpp:  if (narg != 3) error->all(FLERR,"Illegal compute displace/atom command");
compute_displace_atom.cpp:  // create a new fix STORE style
compute_displace_atom.cpp:  // id = compute-ID + COMPUTE_STORE, fix group = compute group
compute_displace_atom.cpp:  // calculate xu,yu,zu for fix store array
compute_displace_atom.cpp:  // skip if reset from restart file
compute_displace_atom.cpp:  // per-atom displacement array
compute_displace_atom.cpp:/* ---------------------------------------------------------------------- */
compute_displace_atom.cpp:  // check nfix in case all fixes have already been deleted
compute_displace_atom.cpp:/* ---------------------------------------------------------------------- */
compute_displace_atom.cpp:  // set fix which stores original atom coords
compute_displace_atom.cpp:  if (ifix < 0) error->all(FLERR,"Could not find compute displace/atom fix ID");
compute_displace_atom.cpp:/* ---------------------------------------------------------------------- */
compute_displace_atom.cpp:  // grow local displacement array if necessary
compute_displace_atom.cpp:    memory->create(displace,nmax,4,"displace/atom:displace");
compute_displace_atom.cpp:  // dx,dy,dz = displacement of atom from original position
compute_displace_atom.cpp:  // original unwrapped position is stored by fix
compute_displace_atom.cpp:  // for triclinic, need to unwrap current atom coord via h matrix
compute_displace_atom.cpp:/* ----------------------------------------------------------------------
compute_displace_atom.cpp:------------------------------------------------------------------------- */
compute_displace_atom.cpp:/* ----------------------------------------------------------------------
compute_displace_atom.cpp:------------------------------------------------------------------------- */
compute_erotate_sphere_atom.cpp:/* ----------------------------------------------------------------------
compute_erotate_sphere_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_erotate_sphere_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_erotate_sphere_atom.cpp:------------------------------------------------------------------------- */
compute_erotate_sphere_atom.cpp:#define INERTIA 0.4          // moment of inertia prefactor for sphere
compute_erotate_sphere_atom.cpp:/* ---------------------------------------------------------------------- */
compute_erotate_sphere_atom.cpp:    error->all(FLERR,"Illegal compute erotate/sphere//atom command");
compute_erotate_sphere_atom.cpp:  // error check
compute_erotate_sphere_atom.cpp:    error->all(FLERR,"Compute erotate/sphere/atom requires atom style sphere");
compute_erotate_sphere_atom.cpp:/* ---------------------------------------------------------------------- */
compute_erotate_sphere_atom.cpp:/* ---------------------------------------------------------------------- */
compute_erotate_sphere_atom.cpp:    if (strcmp(modify->compute[i]->style,"erotate/sphere/atom") == 0) count++;
compute_erotate_sphere_atom.cpp:    error->warning(FLERR,"More than one compute erotate/sphere/atom");
compute_erotate_sphere_atom.cpp:/* ---------------------------------------------------------------------- */
compute_erotate_sphere_atom.cpp:  // grow erot array if necessary
compute_erotate_sphere_atom.cpp:    memory->create(erot,nmax,"erotate/sphere/atom:erot");
compute_erotate_sphere_atom.cpp:  // compute rotational kinetic energy for each atom in group
compute_erotate_sphere_atom.cpp:  // point particles will have erot = 0.0, due to radius = 0.0
compute_erotate_sphere_atom.cpp:/* ----------------------------------------------------------------------
compute_erotate_sphere_atom.cpp:------------------------------------------------------------------------- */
compute_erotate_sphere.cpp:/* ----------------------------------------------------------------------
compute_erotate_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_erotate_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_erotate_sphere.cpp:------------------------------------------------------------------------- */
compute_erotate_sphere.cpp:#define INERTIA 0.4          // moment of inertia prefactor for sphere
compute_erotate_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_erotate_sphere.cpp:  if (narg != 3) error->all(FLERR,"Illegal compute erotate/sphere command");
compute_erotate_sphere.cpp:  // error check
compute_erotate_sphere.cpp:    error->all(FLERR,"Compute erotate/sphere requires atom style sphere");
compute_erotate_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_erotate_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_erotate_sphere.cpp:  // sum rotational energy for each particle
compute_erotate_sphere.cpp:  // point particles will not contribute, due to radius = 0.0
compute_global_atom.cpp:/* ----------------------------------------------------------------------
compute_global_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_global_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_global_atom.cpp:------------------------------------------------------------------------- */
compute_global_atom.cpp:/* ---------------------------------------------------------------------- */
compute_global_atom.cpp:  if (narg < 5) error->all(FLERR,"Illegal compute global/atom command");
compute_global_atom.cpp:  // process index arg
compute_global_atom.cpp:        error->all(FLERR,"Illegal compute global/atom command");
compute_global_atom.cpp:  } else error->all(FLERR,"Illegal compute global/atom command");
compute_global_atom.cpp:  // expand args if any have wildcard character "*"
compute_global_atom.cpp:  // parse values until one isn't recognized
compute_global_atom.cpp:          error->all(FLERR,"Illegal compute global/atom command");
compute_global_atom.cpp:    } else error->all(FLERR,"Illegal compute global/atom command");
compute_global_atom.cpp:  // if wildcard expansion occurred, free earg memory from expand_args()
compute_global_atom.cpp:  // setup and error check both index arg and values
compute_global_atom.cpp:      error->all(FLERR,"Compute ID for compute global/atom does not exist");
compute_global_atom.cpp:      error->all(FLERR,"Compute global/atom compute does not "
compute_global_atom.cpp:      error->all(FLERR,"Compute global/atom compute does not "
compute_global_atom.cpp:      error->all(FLERR,"Compute global/atom compute does not "
compute_global_atom.cpp:                 "Compute global/atom compute array is accessed out-of-range");
compute_global_atom.cpp:      error->all(FLERR,"Fix ID for compute global/atom does not exist");
compute_global_atom.cpp:      error->all(FLERR,"Compute global/atom fix does not "
compute_global_atom.cpp:      error->all(FLERR,"Compute global/atom fix does not "
compute_global_atom.cpp:      error->all(FLERR,"Compute global/atom fix does not "
compute_global_atom.cpp:                 "Compute global/atom fix array is accessed out-of-range");
compute_global_atom.cpp:      error->all(FLERR,"Variable name for compute global/atom does not exist");
compute_global_atom.cpp:      error->all(FLERR,"Compute global/atom variable is not "
compute_global_atom.cpp:        error->all(FLERR,"Compute ID for compute global/atom does not exist");
compute_global_atom.cpp:          error->all(FLERR,"Compute global/atom compute does not "
compute_global_atom.cpp:          error->all(FLERR,"Compute global/atom compute does not "
compute_global_atom.cpp:          error->all(FLERR,"Compute global/atom compute array is "
compute_global_atom.cpp:        error->all(FLERR,"Fix ID for compute global/atom does not exist");
compute_global_atom.cpp:          error->all(FLERR,"Compute global/atom fix does not "
compute_global_atom.cpp:          error->all(FLERR,"Compute global/atom fix does not "
compute_global_atom.cpp:          error->all(FLERR,"Compute global/atom fix array is "
compute_global_atom.cpp:        error->all(FLERR,"Variable name for compute global/atom "
compute_global_atom.cpp:        error->all(FLERR,"Compute global/atom variable is not "
compute_global_atom.cpp:  // this compute produces either a peratom vector or array
compute_global_atom.cpp:/* ---------------------------------------------------------------------- */
compute_global_atom.cpp:/* ---------------------------------------------------------------------- */
compute_global_atom.cpp:  // set indices of all computes,fixes,variables
compute_global_atom.cpp:      error->all(FLERR,"Compute ID for compute global/atom does not exist");
compute_global_atom.cpp:      error->all(FLERR,"Fix ID for compute global/atom does not exist");
compute_global_atom.cpp:      error->all(FLERR,"Variable name for compute global/atom does not exist");
compute_global_atom.cpp:        error->all(FLERR,"Compute ID for compute global/atom does not exist");
compute_global_atom.cpp:        error->all(FLERR,"Fix ID for compute global/atom does not exist");
compute_global_atom.cpp:        error->all(FLERR,"Variable name for compute global/atom "
compute_global_atom.cpp:/* ---------------------------------------------------------------------- */
compute_global_atom.cpp:  // grow indices and output vector or array if necessary
compute_global_atom.cpp:    memory->create(indices,nmax,"global/atom:indices");
compute_global_atom.cpp:      memory->create(vector_atom,nmax,"global/atom:vector_atom");
compute_global_atom.cpp:      memory->create(array_atom,nmax,nvalues,"global/atom:array_atom");
compute_global_atom.cpp:  // setup current peratom indices
compute_global_atom.cpp:  // integer indices are rounded down from double values
compute_global_atom.cpp:  // indices are decremented from 1 to N -> 0 to N-1
compute_global_atom.cpp:      error->all(FLERR,"Fix used in compute global/atom not "
compute_global_atom.cpp:      memory->create(varatom,nmax,"global/atom:varatom");
compute_global_atom.cpp:  // loop over values to fill output vector or array
compute_global_atom.cpp:    // output = vector
compute_global_atom.cpp:          error->all(FLERR,"Fix used in compute global/atom not "
compute_global_atom.cpp:          memory->create(vecglobal,maxvector,"global/atom:vecglobal");
compute_global_atom.cpp:    // output = array
compute_global_atom.cpp:          memory->create(vecglobal,maxvector,"global/atom:vecglobal");
compute_global_atom.cpp:          error->all(FLERR,"Fix used in compute global/atom not "
compute_global_atom.cpp:          memory->create(vecglobal,maxvector,"global/atom:vecglobal");
compute_global_atom.cpp:/* ----------------------------------------------------------------------
compute_global_atom.cpp:------------------------------------------------------------------------- */
compute_global_atom.cpp:  bytes += nmax * sizeof(int);                    // indices
compute_global_atom.cpp:  if (varatom) bytes += nmax * sizeof(double);    // varatom
compute_global_atom.cpp:  bytes += maxvector * sizeof(double);            // vecglobal
compute_group_group.cpp:/* ----------------------------------------------------------------------
compute_group_group.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_group_group.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_group_group.cpp:------------------------------------------------------------------------- */
compute_group_group.cpp:/* ----------------------------------------------------------------------
compute_group_group.cpp:------------------------------------------------------------------------- */
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:    error->all(FLERR,"Compute group/group group ID does not exist");
compute_group_group.cpp:        error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:      else error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:        error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:      else error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:        error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:      else error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:        error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:      else error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:        error->all(FLERR,"Compute group/group molecule requires molecule IDs");
compute_group_group.cpp:    } else error->all(FLERR,"Illegal compute group/group command");
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:  // if non-hybrid, then error if single_enable = 0
compute_group_group.cpp:  // if hybrid, let hybrid determine if sub-style sets single_enable = 0
compute_group_group.cpp:    error->all(FLERR,"No pair style defined for compute group/group");
compute_group_group.cpp:    error->all(FLERR,"Pair style does not support compute group/group");
compute_group_group.cpp:  // error if Kspace style does not compute group/group interactions
compute_group_group.cpp:    error->all(FLERR,"No Kspace style defined for compute group/group");
compute_group_group.cpp:    error->all(FLERR,"Kspace style does not support compute group/group");
compute_group_group.cpp:  // compute Kspace correction terms
compute_group_group.cpp:      sprintf(str,"Both groups in compute group/group have a net charge; "
compute_group_group.cpp:  // recheck that group 2 has not been deleted
compute_group_group.cpp:    error->all(FLERR,"Compute group/group group ID does not exist");
compute_group_group.cpp:  // need an occasional half neighbor list
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:  // invoke half neighbor list (will copy or build if necessary)
compute_group_group.cpp:  // loop over neighbors of my atoms
compute_group_group.cpp:  // skip if I,J are not in 2 groups
compute_group_group.cpp:    // skip if atom I is not in either group
compute_group_group.cpp:      // skip if atom J is not in either group
compute_group_group.cpp:      // skip if atoms I,J are only in the same group
compute_group_group.cpp:      // skip if molecule IDs of atoms I,J do not satisfy molflag setting
compute_group_group.cpp:        // energy only computed once so tally full amount
compute_group_group.cpp:        // force tally is jgroup acting on igroup
compute_group_group.cpp:        // energy computed twice so tally half amount
compute_group_group.cpp:        // only tally force if I own igroup atom
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:  // subtract extra A <--> A Kspace interaction so energy matches
compute_group_group.cpp:  //   real-space style of compute group-group
compute_group_group.cpp:  // add extra Kspace term to energy
compute_group_group.cpp:  // self energy correction term
compute_group_group.cpp:  // k=0 boundary correction term
compute_group_group.cpp:    // adjustment of z dimension for 2d slab Ewald
compute_group_group.cpp:    // 3d Ewald just uses zprd since slab_volfactor = 1.0
compute_group_group.cpp:    scalar -= e_correction/volume;
compute_group_group.cpp:/* ---------------------------------------------------------------------- */
compute_group_group.cpp:  // total charge of groups A & B, needed for correction term
compute_group_group.cpp:  // self-energy correction
compute_group_group.cpp:  e_self = qscale * g_ewald*qsqsum_group/MY_PIS;
compute_group_group.cpp:  // subtract extra AA terms
compute_group_group.cpp:  // k=0 energy correction term (still need to divide by volume above)
compute_group_group.cpp:  e_correction *= qscale * MY_PI2 / (g_ewald*g_ewald);
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_gyration_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_gyration_chunk.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute gyration/chunk command");
compute_gyration_chunk.cpp:  // ID of compute chunk/atom
compute_gyration_chunk.cpp:  // optional args
compute_gyration_chunk.cpp:    } else error->all(FLERR,"Illegal compute gyration/chunk command");
compute_gyration_chunk.cpp:  // chunk-based data
compute_gyration_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_gyration_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_gyration_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for "
compute_gyration_chunk.cpp:               "compute gyration/chunk");
compute_gyration_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_gyration_chunk.cpp:    error->all(FLERR,"Compute gyration/chunk does not use chunk/atom compute");
compute_gyration_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_gyration_chunk.cpp:  // compute Rg for each chunk
compute_gyration_chunk.cpp:      rgall[i] = sqrt(rgall[i]/masstotal[i]);
compute_gyration_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_gyration_chunk.cpp:        rgtall[i][j] = rgtall[i][j]/masstotal[i];
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_gyration_chunk.cpp:  // extract ichunk index vector from compute
compute_gyration_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_gyration_chunk.cpp:  // zero local per-chunk values
compute_gyration_chunk.cpp:  // compute COM for each chunk
compute_gyration_chunk.cpp:      comall[i][0] /= masstotal[i];
compute_gyration_chunk.cpp:      comall[i][1] /= masstotal[i];
compute_gyration_chunk.cpp:      comall[i][2] /= masstotal[i];
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:   lock methods: called by fix ave/time
compute_gyration_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_gyration_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration_chunk.cpp:  memory->create(massproc,maxchunk,"gyration/chunk:massproc");
compute_gyration_chunk.cpp:  memory->create(masstotal,maxchunk,"gyration/chunk:masstotal");
compute_gyration_chunk.cpp:  memory->create(com,maxchunk,3,"gyration/chunk:com");
compute_gyration_chunk.cpp:  memory->create(comall,maxchunk,3,"gyration/chunk:comall");
compute_gyration_chunk.cpp:    memory->create(rgt,maxchunk,6,"gyration/chunk:rgt");
compute_gyration_chunk.cpp:    memory->create(rgtall,maxchunk,6,"gyration/chunk:rgtall");
compute_gyration_chunk.cpp:    memory->create(rg,maxchunk,"gyration/chunk:rg");
compute_gyration_chunk.cpp:    memory->create(rgall,maxchunk,"gyration/chunk:rgall");
compute_gyration_chunk.cpp:/* ----------------------------------------------------------------------
compute_gyration_chunk.cpp:------------------------------------------------------------------------- */
compute_gyration.cpp:/* ----------------------------------------------------------------------
compute_gyration.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_gyration.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_gyration.cpp:------------------------------------------------------------------------- */
compute_gyration.cpp:/* ---------------------------------------------------------------------- */
compute_gyration.cpp:/* ---------------------------------------------------------------------- */
compute_gyration.cpp:/* ---------------------------------------------------------------------- */
compute_gyration.cpp:/* ---------------------------------------------------------------------- */
compute_gyration.cpp:/* ----------------------------------------------------------------------
compute_gyration.cpp:------------------------------------------------------------------------- */
compute_gyration.cpp:      vector[i] /= masstotal;
compute_heat_flux.cpp:/* ----------------------------------------------------------------------
compute_heat_flux.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_heat_flux.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_heat_flux.cpp:------------------------------------------------------------------------- */
compute_heat_flux.cpp:/* ----------------------------------------------------------------------
compute_heat_flux.cpp:------------------------------------------------------------------------- */
compute_heat_flux.cpp:/* ---------------------------------------------------------------------- */
compute_heat_flux.cpp:  if (narg != 6) error->all(FLERR,"Illegal compute heat/flux command");
compute_heat_flux.cpp:  // store ke/atom, pe/atom, stress/atom IDs used by heat flux computation
compute_heat_flux.cpp:  // insure they are valid for these computations
compute_heat_flux.cpp:    error->all(FLERR,"Could not find compute heat/flux compute ID");
compute_heat_flux.cpp:  if (strcmp(modify->compute[ike]->style,"ke/atom") != 0)
compute_heat_flux.cpp:    error->all(FLERR,"Compute heat/flux compute ID does not compute ke/atom");
compute_heat_flux.cpp:    error->all(FLERR,"Compute heat/flux compute ID does not compute pe/atom");
compute_heat_flux.cpp:               "Compute heat/flux compute ID does not compute stress/atom");
compute_heat_flux.cpp:/* ---------------------------------------------------------------------- */
compute_heat_flux.cpp:/* ---------------------------------------------------------------------- */
compute_heat_flux.cpp:  // error checks
compute_heat_flux.cpp:    error->all(FLERR,"Could not find compute heat/flux compute ID");
compute_heat_flux.cpp:/* ---------------------------------------------------------------------- */
compute_heat_flux.cpp:  // invoke 3 computes if they haven't been already
compute_heat_flux.cpp:  // heat flux vector = jc[3] + jv[3]
compute_heat_flux.cpp:  // jc[3] = convective portion of heat flux = sum_i (ke_i + pe_i) v_i[3]
compute_heat_flux.cpp:  // jv[3] = virial portion of heat flux = sum_i (stress_tensor_i . v_i[3])
compute_heat_flux.cpp:  // normalization by volume is not included
compute_heat_flux.cpp:  // convert jv from stress*volume to energy units via nktv2p factor
compute_heat_flux.cpp:  jv[0] /= nktv2p;
compute_heat_flux.cpp:  jv[1] /= nktv2p;
compute_heat_flux.cpp:  jv[2] /= nktv2p;
compute_heat_flux.cpp:  // sum across all procs
compute_heat_flux.cpp:  // 1st 3 terms are total heat flux
compute_heat_flux.cpp:  // 2nd 3 terms are just conductive portion
compute_hexorder_atom.cpp:/* ----------------------------------------------------------------------
compute_hexorder_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_hexorder_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_hexorder_atom.cpp:------------------------------------------------------------------------- */
compute_hexorder_atom.cpp:/* ----------------------------------------------------------------------
compute_hexorder_atom.cpp:------------------------------------------------------------------------- */
compute_hexorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_hexorder_atom.cpp:  if (narg < 3 ) error->all(FLERR,"Illegal compute hexorder/atom command");
compute_hexorder_atom.cpp:  // process optional args
compute_hexorder_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute hexorder/atom command");
compute_hexorder_atom.cpp:        error->all(FLERR,"Illegal compute hexorder/atom command");
compute_hexorder_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute hexorder/atom command");
compute_hexorder_atom.cpp:	  error->all(FLERR,"Illegal compute hexorder/atom command");
compute_hexorder_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute hexorder/atom command");
compute_hexorder_atom.cpp:        error->all(FLERR,"Illegal compute hexorder/atom command");
compute_hexorder_atom.cpp:    } else error->all(FLERR,"Illegal compute hexorder/atom command");
compute_hexorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_hexorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_hexorder_atom.cpp:    error->all(FLERR,"Compute hexorder/atom requires a pair style be defined");
compute_hexorder_atom.cpp:               "Compute hexorder/atom cutoff is longer than pairwise cutoff");
compute_hexorder_atom.cpp:  // need an occasional full neighbor list
compute_hexorder_atom.cpp:    if (strcmp(modify->compute[i]->style,"hexorder/atom") == 0) count++;
compute_hexorder_atom.cpp:    error->warning(FLERR,"More than one compute hexorder/atom");
compute_hexorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_hexorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_hexorder_atom.cpp:  // grow order parameter array if necessary
compute_hexorder_atom.cpp:    memory->create(qnarray,nmax,ncol,"hexorder/atom:qnarray");
compute_hexorder_atom.cpp:  // invoke full neighbor list (will copy or build if necessary)
compute_hexorder_atom.cpp:  // compute order parameter for each atom in group
compute_hexorder_atom.cpp:  // use full neighbor list to count atoms less than cutoff
compute_hexorder_atom.cpp:      // insure distsq and nearest arrays are long enough
compute_hexorder_atom.cpp:        memory->create(distsq,maxneigh,"hexorder/atom:distsq");
compute_hexorder_atom.cpp:        memory->create(nearest,maxneigh,"hexorder/atom:nearest");
compute_hexorder_atom.cpp:      // loop over list of all neighbors within force cutoff
compute_hexorder_atom.cpp:      // distsq[] = distance sq to each
compute_hexorder_atom.cpp:      // nearest[] = atom indices of neighbors
compute_hexorder_atom.cpp:      // if not nnn neighbors, order parameter = 0;
compute_hexorder_atom.cpp:      // if nnn > 0, use only nearest nnn neighbors
compute_hexorder_atom.cpp:      qn[0] = usum/nnn;
compute_hexorder_atom.cpp:      qn[1] = vsum/nnn;
compute_hexorder_atom.cpp:// calculate order parameter using std::complex::pow function
compute_hexorder_atom.cpp:  double rinv = 1.0/sqrt(delx*delx+dely*dely);
compute_hexorder_atom.cpp:// calculate order parameter using trig functions
compute_hexorder_atom.cpp:// this is usually slower, but can be used if <complex> not available
compute_hexorder_atom.cpp:    if(dely > 0.0) ntheta = nnn * MY_PI / 2.0;
compute_hexorder_atom.cpp:    else ntheta = nnn * 3.0 * MY_PI / 2.0;
compute_hexorder_atom.cpp:  } else ntheta = nnn * atan(dely / delx);
compute_hexorder_atom.cpp:/* ----------------------------------------------------------------------
compute_hexorder_atom.cpp:------------------------------------------------------------------------- */
compute_hexorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_hexorder_atom.cpp:/* ----------------------------------------------------------------------
compute_hexorder_atom.cpp:------------------------------------------------------------------------- */
compute_improper.cpp:/* ----------------------------------------------------------------------
compute_improper.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_improper.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_improper.cpp:------------------------------------------------------------------------- */
compute_improper.cpp:/* ---------------------------------------------------------------------- */
compute_improper.cpp:  // check if improper style hybrid exists
compute_improper.cpp:/* ---------------------------------------------------------------------- */
compute_improper.cpp:/* ---------------------------------------------------------------------- */
compute_improper.cpp:  // recheck improper style in case it has been changed
compute_improper.cpp:/* ---------------------------------------------------------------------- */
compute_improper_local.cpp:/* ----------------------------------------------------------------------
compute_improper_local.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_improper_local.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_improper_local.cpp:------------------------------------------------------------------------- */
compute_improper_local.cpp:/* ---------------------------------------------------------------------- */
compute_improper_local.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute improper/local command");
compute_improper_local.cpp:               "Compute improper/local used when impropers are not allowed");
compute_improper_local.cpp:    else error->all(FLERR,"Invalid keyword in compute improper/local command");
compute_improper_local.cpp:/* ---------------------------------------------------------------------- */
compute_improper_local.cpp:/* ---------------------------------------------------------------------- */
compute_improper_local.cpp:    error->all(FLERR,"No improper style is defined for compute improper/local");
compute_improper_local.cpp:  // do initial memory allocation so that memory_usage() is correct
compute_improper_local.cpp:/* ---------------------------------------------------------------------- */
compute_improper_local.cpp:  // count local entries and compute improper info
compute_improper_local.cpp:/* ----------------------------------------------------------------------
compute_improper_local.cpp:------------------------------------------------------------------------- */
compute_improper_local.cpp:        // chi calculation from improper style harmonic
compute_improper_local.cpp:          ss1 = 1.0 / (vb1x*vb1x + vb1y*vb1y + vb1z*vb1z);
compute_improper_local.cpp:          ss2 = 1.0 / (vb2x*vb2x + vb2y*vb2y + vb2z*vb2z);
compute_improper_local.cpp:          ss3 = 1.0 / (vb3x*vb3x + vb3y*vb3y + vb3z*vb3z);
compute_improper_local.cpp:          s1 = 1.0 / s1;
compute_improper_local.cpp:          s2 = 1.0 / s2;
compute_improper_local.cpp:          cbuf[n] = 180.0*acos(c)/MY_PI;
compute_improper_local.cpp:/* ---------------------------------------------------------------------- */
compute_improper_local.cpp:  // grow vector_local or array_local
compute_improper_local.cpp:    memory->create(vlocal,nmax,"improper/local:vector_local");
compute_improper_local.cpp:    memory->create(alocal,nmax,nvalues,"improper/local:array_local");
compute_improper_local.cpp:/* ----------------------------------------------------------------------
compute_improper_local.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_inertia_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_inertia_chunk.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute inertia/chunk command");
compute_inertia_chunk.cpp:  // ID of compute chunk/atom
compute_inertia_chunk.cpp:  // chunk-based data
compute_inertia_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_inertia_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for "
compute_inertia_chunk.cpp:               "compute inertia/chunk");
compute_inertia_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_inertia_chunk.cpp:    error->all(FLERR,"Compute inertia/chunk does not use chunk/atom compute");
compute_inertia_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_inertia_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_inertia_chunk.cpp:  // extract ichunk index vector from compute
compute_inertia_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_inertia_chunk.cpp:  // zero local per-chunk values
compute_inertia_chunk.cpp:  // compute COM for each chunk
compute_inertia_chunk.cpp:      comall[i][0] /= masstotal[i];
compute_inertia_chunk.cpp:      comall[i][1] /= masstotal[i];
compute_inertia_chunk.cpp:      comall[i][2] /= masstotal[i];
compute_inertia_chunk.cpp:  // compute inertia tensor for each chunk
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:   lock methods: called by fix ave/time
compute_inertia_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_inertia_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_inertia_chunk.cpp:  memory->create(massproc,maxchunk,"inertia/chunk:massproc");
compute_inertia_chunk.cpp:  memory->create(masstotal,maxchunk,"inertia/chunk:masstotal");
compute_inertia_chunk.cpp:  memory->create(com,maxchunk,3,"inertia/chunk:com");
compute_inertia_chunk.cpp:  memory->create(comall,maxchunk,3,"inertia/chunk:comall");
compute_inertia_chunk.cpp:  memory->create(inertia,maxchunk,6,"inertia/chunk:inertia");
compute_inertia_chunk.cpp:  memory->create(inertiaall,maxchunk,6,"inertia/chunk:inertiaall");
compute_inertia_chunk.cpp:/* ----------------------------------------------------------------------
compute_inertia_chunk.cpp:------------------------------------------------------------------------- */
compute_ke_atom.cpp:/* ----------------------------------------------------------------------
compute_ke_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_ke_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_ke_atom.cpp:------------------------------------------------------------------------- */
compute_ke_atom.cpp:/* ---------------------------------------------------------------------- */
compute_ke_atom.cpp:  if (narg != 3) error->all(FLERR,"Illegal compute ke/atom command");
compute_ke_atom.cpp:/* ---------------------------------------------------------------------- */
compute_ke_atom.cpp:/* ---------------------------------------------------------------------- */
compute_ke_atom.cpp:    if (strcmp(modify->compute[i]->style,"ke/atom") == 0) count++;
compute_ke_atom.cpp:    error->warning(FLERR,"More than one compute ke/atom");
compute_ke_atom.cpp:/* ---------------------------------------------------------------------- */
compute_ke_atom.cpp:  // grow ke array if necessary
compute_ke_atom.cpp:    memory->create(ke,nmax,"ke/atom:ke");
compute_ke_atom.cpp:  // compute kinetic energy for each atom in group
compute_ke_atom.cpp:/* ----------------------------------------------------------------------
compute_ke_atom.cpp:------------------------------------------------------------------------- */
compute_ke.cpp:/* ----------------------------------------------------------------------
compute_ke.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_ke.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_ke.cpp:------------------------------------------------------------------------- */
compute_ke.cpp:/* ---------------------------------------------------------------------- */
compute_ke.cpp:/* ---------------------------------------------------------------------- */
compute_ke.cpp:/* ---------------------------------------------------------------------- */
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_msd_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_msd_chunk.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute msd/chunk command");
compute_msd_chunk.cpp:  // ID of compute chunk/atom
compute_msd_chunk.cpp:  // create a new fix STORE style for reference positions
compute_msd_chunk.cpp:  // id = compute-ID + COMPUTE_STORE, fix group = compute group
compute_msd_chunk.cpp:  // do not know size of array at this point, just allocate 1x3 array
compute_msd_chunk.cpp:  // fix creation must be done now so that a restart run can
compute_msd_chunk.cpp:  //   potentially re-populate the fix array (and change it to correct size)
compute_msd_chunk.cpp:  // otherwise size reset and init will be done in setup()
compute_msd_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_msd_chunk.cpp:  // check nfix in case all fixes have already been deleted
compute_msd_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_msd_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for compute msd/chunk");
compute_msd_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_msd_chunk.cpp:    error->all(FLERR,"Compute msd/chunk does not use chunk/atom compute");
compute_msd_chunk.cpp:  // set fix which stores reference atom coords
compute_msd_chunk.cpp:  // if firstflag, will be created in setup()
compute_msd_chunk.cpp:    if (ifix < 0) error->all(FLERR,"Could not find compute msd/chunk fix ID");
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:  // if fix->astore is already correct size, restart file set it up
compute_msd_chunk.cpp:  // otherwise reset its size now and initialize to current COM
compute_msd_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_msd_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_msd_chunk.cpp:  // extract ichunk index vector from compute
compute_msd_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_msd_chunk.cpp:  // first time call, allocate per-chunk arrays
compute_msd_chunk.cpp:  // thereafter, require nchunk remain the same
compute_msd_chunk.cpp:    error->all(FLERR,"Compute msd/chunk nchunk is not static");
compute_msd_chunk.cpp:  // zero local per-chunk values
compute_msd_chunk.cpp:  // compute current COM for each chunk
compute_msd_chunk.cpp:      comall[i][0] /= masstotal[i];
compute_msd_chunk.cpp:      comall[i][1] /= masstotal[i];
compute_msd_chunk.cpp:      comall[i][2] /= masstotal[i];
compute_msd_chunk.cpp:  // MSD is difference between current and initial COM
compute_msd_chunk.cpp:  // cominit is initilialized by setup() when firstflag is set
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:   lock methods: called by fix ave/time
compute_msd_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_msd_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd_chunk.cpp:  memory->create(massproc,nchunk,"msd/chunk:massproc");
compute_msd_chunk.cpp:  memory->create(masstotal,nchunk,"msd/chunk:masstotal");
compute_msd_chunk.cpp:  memory->create(com,nchunk,3,"msd/chunk:com");
compute_msd_chunk.cpp:  memory->create(comall,nchunk,3,"msd/chunk:comall");
compute_msd_chunk.cpp:  memory->create(msd,nchunk,4,"msd/chunk:msd");
compute_msd_chunk.cpp:/* ----------------------------------------------------------------------
compute_msd_chunk.cpp:------------------------------------------------------------------------- */
compute_msd.cpp:/* ----------------------------------------------------------------------
compute_msd.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_msd.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_msd.cpp:------------------------------------------------------------------------- */
compute_msd.cpp:/* ---------------------------------------------------------------------- */
compute_msd.cpp:  // optional args
compute_msd.cpp:  // create a new fix STORE style for reference positions
compute_msd.cpp:  // id = compute-ID + COMPUTE_STORE, fix group = compute group
compute_msd.cpp:  // calculate xu,yu,zu for fix store array
compute_msd.cpp:  // skip if reset from restart file
compute_msd.cpp:    // adjust for COM if requested
compute_msd.cpp:    // initialize counter for average positions if requested
compute_msd.cpp:  // displacement vector
compute_msd.cpp:/* ---------------------------------------------------------------------- */
compute_msd.cpp:  // check nfix in case all fixes have already been deleted
compute_msd.cpp:/* ---------------------------------------------------------------------- */
compute_msd.cpp:  // set fix which stores reference atom coords
compute_msd.cpp:  // nmsd = # of atoms in group
compute_msd.cpp:/* ---------------------------------------------------------------------- */
compute_msd.cpp:  // cm = current center of mass
compute_msd.cpp:  // dx,dy,dz = displacement of atom from reference position
compute_msd.cpp:  // reference unwrapped position is stored by fix
compute_msd.cpp:  // relative to center of mass if comflag is set
compute_msd.cpp:  // for triclinic, need to unwrap current atom coord via h matrix
compute_msd.cpp:  // update number of averages if requested
compute_msd.cpp:    navfac = 1.0/(naverage+1);
compute_msd.cpp:	// use running average position for reference if requested
compute_msd.cpp:	// use running average position for reference if requested
compute_msd.cpp:    vector[0] /= nmsd;
compute_msd.cpp:    vector[1] /= nmsd;
compute_msd.cpp:    vector[2] /= nmsd;
compute_msd.cpp:    vector[3] /= nmsd;
compute_msd.cpp:/* ----------------------------------------------------------------------
compute_msd.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_omega_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_omega_chunk.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute omega/chunk command");
compute_omega_chunk.cpp:  // ID of compute chunk/atom
compute_omega_chunk.cpp:  // chunk-based data
compute_omega_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_omega_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for "
compute_omega_chunk.cpp:               "compute omega/chunk");
compute_omega_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_omega_chunk.cpp:    error->all(FLERR,"Compute omega/chunk does not use chunk/atom compute");
compute_omega_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_omega_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_omega_chunk.cpp:  // extract ichunk index vector from compute
compute_omega_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_omega_chunk.cpp:  // zero local per-chunk values
compute_omega_chunk.cpp:  // compute COM for each chunk
compute_omega_chunk.cpp:      comall[i][0] /= masstotal[i];
compute_omega_chunk.cpp:      comall[i][1] /= masstotal[i];
compute_omega_chunk.cpp:      comall[i][2] /= masstotal[i];
compute_omega_chunk.cpp:  // compute inertia tensor for each chunk
compute_omega_chunk.cpp:  // compute angmom for each chunk
compute_omega_chunk.cpp:  // compute omega for each chunk
compute_omega_chunk.cpp:    // determinant = triple product of rows of inertia matrix
compute_omega_chunk.cpp:    // non-singular I matrix
compute_omega_chunk.cpp:    // use L = Iw, inverting I to solve for w
compute_omega_chunk.cpp:      invdeterminant = 1.0/determinant;
compute_omega_chunk.cpp:    // handle each (nearly) singular I matrix
compute_omega_chunk.cpp:    // due to 2-atom chunk or linear molecule
compute_omega_chunk.cpp:    // use jacobi() and angmom_to_omega() to calculate valid omega
compute_omega_chunk.cpp:                             "Insufficient Jacobi rotations for omega/chunk");
compute_omega_chunk.cpp:      // enforce 3 evectors as a right-handed coordinate system
compute_omega_chunk.cpp:      // flip 3rd vector if needed
compute_omega_chunk.cpp:      // if any principal moment < scaled EPSILON, set to 0.0
compute_omega_chunk.cpp:      // calculate omega using diagonalized inertia matrix
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:   lock methods: called by fix ave/time
compute_omega_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_omega_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_omega_chunk.cpp:  memory->create(massproc,maxchunk,"omega/chunk:massproc");
compute_omega_chunk.cpp:  memory->create(masstotal,maxchunk,"omega/chunk:masstotal");
compute_omega_chunk.cpp:  memory->create(com,maxchunk,3,"omega/chunk:com");
compute_omega_chunk.cpp:  memory->create(comall,maxchunk,3,"omega/chunk:comall");
compute_omega_chunk.cpp:  memory->create(inertia,maxchunk,6,"omega/chunk:inertia");
compute_omega_chunk.cpp:  memory->create(inertiaall,maxchunk,6,"omega/chunk:inertiaall");
compute_omega_chunk.cpp:  memory->create(angmom,maxchunk,3,"omega/chunk:angmom");
compute_omega_chunk.cpp:  memory->create(angmomall,maxchunk,3,"omega/chunk:angmomall");
compute_omega_chunk.cpp:  memory->create(omega,maxchunk,3,"omega/chunk:omega");
compute_omega_chunk.cpp:/* ----------------------------------------------------------------------
compute_omega_chunk.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:/* ----------------------------------------------------------------------
compute_orientorder_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_orientorder_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_orientorder_atom.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:/* ----------------------------------------------------------------------
compute_orientorder_atom.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_orientorder_atom.cpp:  if (narg < 3 ) error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:  // set default values for optional args
compute_orientorder_atom.cpp:  // specify which orders to request
compute_orientorder_atom.cpp:  memory->create(qlist,nqlist,"orientorder/atom:qlist");
compute_orientorder_atom.cpp:  // process optional args
compute_orientorder_atom.cpp:        error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:          error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:        error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:        error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:      memory->create(qlist,nqlist,"orientorder/atom:qlist");
compute_orientorder_atom.cpp:        error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:          error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:          error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:          error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:          error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:        error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:        error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:    } else error->all(FLERR,"Illegal compute orientorder/atom command");
compute_orientorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_orientorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_orientorder_atom.cpp:    error->all(FLERR,"Compute orientorder/atom requires a "
compute_orientorder_atom.cpp:    error->all(FLERR,"Compute orientorder/atom cutoff is "
compute_orientorder_atom.cpp:  memory->create(qnm_r,qmax,2*qmax+1,"orientorder/atom:qnm_r");
compute_orientorder_atom.cpp:  memory->create(qnm_i,qmax,2*qmax+1,"orientorder/atom:qnm_i");
compute_orientorder_atom.cpp:  // need an occasional full neighbor list
compute_orientorder_atom.cpp:    if (strcmp(modify->compute[i]->style,"orientorder/atom") == 0) count++;
compute_orientorder_atom.cpp:    error->warning(FLERR,"More than one compute orientorder/atom");
compute_orientorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_orientorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_orientorder_atom.cpp:  // grow order parameter array if necessary
compute_orientorder_atom.cpp:    memory->create(qnarray,nmax,ncol,"orientorder/atom:qnarray");
compute_orientorder_atom.cpp:  // invoke full neighbor list (will copy or build if necessary)
compute_orientorder_atom.cpp:  // compute order parameter for each atom in group
compute_orientorder_atom.cpp:  // use full neighbor list to count atoms less than cutoff
compute_orientorder_atom.cpp:      // insure distsq and nearest arrays are long enough
compute_orientorder_atom.cpp:        memory->create(distsq,maxneigh,"orientorder/atom:distsq");
compute_orientorder_atom.cpp:        memory->create(rlist,maxneigh,3,"orientorder/atom:rlist");
compute_orientorder_atom.cpp:        memory->create(nearest,maxneigh,"orientorder/atom:nearest");
compute_orientorder_atom.cpp:      // loop over list of all neighbors within force cutoff
compute_orientorder_atom.cpp:      // distsq[] = distance sq to each
compute_orientorder_atom.cpp:      // rlist[] = distance vector to each
compute_orientorder_atom.cpp:      // nearest[] = atom indices of neighbors
compute_orientorder_atom.cpp:      // if not nnn neighbors, order parameter = 0;
compute_orientorder_atom.cpp:      // if nnn > 0, use only nearest nnn neighbors
compute_orientorder_atom.cpp:/* ----------------------------------------------------------------------
compute_orientorder_atom.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:/* ----------------------------------------------------------------------
compute_orientorder_atom.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:// Use no-op do while to create single statement
compute_orientorder_atom.cpp:/* ---------------------------------------------------------------------- */
compute_orientorder_atom.cpp:/* ----------------------------------------------------------------------
compute_orientorder_atom.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:    double costheta = r[2] / rmag;
compute_orientorder_atom.cpp:      double rxymaginv = 1.0/rxymag;
compute_orientorder_atom.cpp:  double fac = sqrt(MY_4PI) / ncount;
compute_orientorder_atom.cpp:      //      printf("Ylm^2 = %d %d %g\n",n,m,
compute_orientorder_atom.cpp:      //     qnm_r[iw][m]*qnm_r[iw][m] + qnm_i[iw][m]*qnm_i[iw][m]);
compute_orientorder_atom.cpp:    qn[iw] = fac * sqrt(qm_sum / (2*n+1));
compute_orientorder_atom.cpp:    if (qlcompflag && iqlcomp == iw) normfac = 1.0/sqrt(qm_sum);
compute_orientorder_atom.cpp:  // output of the complex vector
compute_orientorder_atom.cpp:/* ----------------------------------------------------------------------
compute_orientorder_atom.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:/* ----------------------------------------------------------------------
compute_orientorder_atom.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:  prefactor = sqrt(static_cast<double>(2*l+1)/(MY_4PI*prefactor))
compute_orientorder_atom.cpp:/* ----------------------------------------------------------------------
compute_orientorder_atom.cpp:------------------------------------------------------------------------- */
compute_orientorder_atom.cpp:         - static_cast<double>(i+m-1)*pm2) / static_cast<double>(i-m);
compute_pair.cpp:/* ----------------------------------------------------------------------
compute_pair.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_pair.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_pair.cpp:------------------------------------------------------------------------- */
compute_pair.cpp:/* ---------------------------------------------------------------------- */
compute_pair.cpp:  // check if pair style with and without suffix exists
compute_pair.cpp:    strcat(pstyle,"/");
compute_pair.cpp:/* ---------------------------------------------------------------------- */
compute_pair.cpp:/* ---------------------------------------------------------------------- */
compute_pair.cpp:  // recheck for pair style in case it has been deleted
compute_pair.cpp:/* ---------------------------------------------------------------------- */
compute_pair.cpp:/* ---------------------------------------------------------------------- */
compute_pair_local.cpp:/* ----------------------------------------------------------------------
compute_pair_local.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_pair_local.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_pair_local.cpp:------------------------------------------------------------------------- */
compute_pair_local.cpp:/* ---------------------------------------------------------------------- */
compute_pair_local.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute pair/local command");
compute_pair_local.cpp:                             "Invalid keyword in compute pair/local command");
compute_pair_local.cpp:  // optional args
compute_pair_local.cpp:        error->all(FLERR,"Illegal compute pair/local command");
compute_pair_local.cpp:      else error->all(FLERR,"Illegal compute pair/local command");
compute_pair_local.cpp:    } else error->all(FLERR,"Illegal compute pair/local command");
compute_pair_local.cpp:  // error check
compute_pair_local.cpp:    error->all(FLERR,"Compute pair/local requires atom attribute radius");
compute_pair_local.cpp:  // set singleflag if need to call pair->single()
compute_pair_local.cpp:/* ---------------------------------------------------------------------- */
compute_pair_local.cpp:/* ---------------------------------------------------------------------- */
compute_pair_local.cpp:    error->all(FLERR,"No pair style is defined for compute pair/local");
compute_pair_local.cpp:    error->all(FLERR,"Pair style does not support compute pair/local");
compute_pair_local.cpp:                 " requested by compute pair/local");
compute_pair_local.cpp:  // need an occasional half neighbor list
compute_pair_local.cpp:/* ---------------------------------------------------------------------- */
compute_pair_local.cpp:/* ---------------------------------------------------------------------- */
compute_pair_local.cpp:  // count local entries and compute pair info
compute_pair_local.cpp:/* ----------------------------------------------------------------------
compute_pair_local.cpp:------------------------------------------------------------------------- */
compute_pair_local.cpp:  // invoke half neighbor list (will copy or build if necessary)
compute_pair_local.cpp:  // loop over neighbors of my atoms
compute_pair_local.cpp:  // skip if I or J are not in group
compute_pair_local.cpp:  // for newton = 0 and J = ghost atom,
compute_pair_local.cpp:  //   need to insure I,J pair is only output by one proc
compute_pair_local.cpp:  //   use same itag,jtag logic as in Neighbor::neigh_half_nsq()
compute_pair_local.cpp:  // for flag = 0, just count pair interactions within force cutoff
compute_pair_local.cpp:  // for flag = 1, calculate requested output fields
compute_pair_local.cpp:      // itag = jtag is possible for long cutoffs that include images of self
compute_pair_local.cpp:/* ---------------------------------------------------------------------- */
compute_pair_local.cpp:  // grow vector_local or array_local
compute_pair_local.cpp:    memory->create(vlocal,nmax,"pair/local:vector_local");
compute_pair_local.cpp:    memory->create(alocal,nmax,nvalues,"pair/local:array_local");
compute_pair_local.cpp:/* ----------------------------------------------------------------------
compute_pair_local.cpp:------------------------------------------------------------------------- */
compute_pe_atom.cpp:/* ----------------------------------------------------------------------
compute_pe_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_pe_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_pe_atom.cpp:------------------------------------------------------------------------- */
compute_pe_atom.cpp:/* ---------------------------------------------------------------------- */
compute_pe_atom.cpp:  if (narg < 3) error->all(FLERR,"Illegal compute pe/atom command");
compute_pe_atom.cpp:      else error->all(FLERR,"Illegal compute pe/atom command");
compute_pe_atom.cpp:/* ---------------------------------------------------------------------- */
compute_pe_atom.cpp:/* ---------------------------------------------------------------------- */
compute_pe_atom.cpp:  // grow local energy array if necessary
compute_pe_atom.cpp:  // needs to be atom->nmax in length
compute_pe_atom.cpp:    memory->create(energy,nmax,"pe/atom:energy");
compute_pe_atom.cpp:  // npair includes ghosts if either newton flag is set
compute_pe_atom.cpp:  //   b/c some bonds/dihedrals call pair::ev_tally with pairwise info
compute_pe_atom.cpp:  // nbond includes ghosts if newton_bond is set
compute_pe_atom.cpp:  // ntotal includes ghosts if either newton flag is set
compute_pe_atom.cpp:  // KSpace includes ghosts if tip4pflag is set
compute_pe_atom.cpp:  // clear local energy array
compute_pe_atom.cpp:  // add in per-atom contributions from each force
compute_pe_atom.cpp:  // add in per-atom contributions from relevant fixes
compute_pe_atom.cpp:  // always only for owned atoms, not ghost
compute_pe_atom.cpp:  // communicate ghost energy between neighbor procs
compute_pe_atom.cpp:  // zero energy of atoms not in group
compute_pe_atom.cpp:  // only do this after comm since ghost contributions must be included
compute_pe_atom.cpp:/* ---------------------------------------------------------------------- */
compute_pe_atom.cpp:/* ---------------------------------------------------------------------- */
compute_pe_atom.cpp:/* ----------------------------------------------------------------------
compute_pe_atom.cpp:------------------------------------------------------------------------- */
compute_pe.cpp:/* ----------------------------------------------------------------------
compute_pe.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_pe.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_pe.cpp:------------------------------------------------------------------------- */
compute_pe.cpp:/* ---------------------------------------------------------------------- */
compute_pe.cpp:/* ---------------------------------------------------------------------- */
compute_pe.cpp:    scalar += force->pair->etail / volume;
compute_pressure.cpp:/* ----------------------------------------------------------------------
compute_pressure.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_pressure.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_pressure.cpp:------------------------------------------------------------------------- */
compute_pressure.cpp:/* ---------------------------------------------------------------------- */
compute_pressure.cpp:  // store temperature ID used by pressure computation
compute_pressure.cpp:  // insure it is valid for temperature computation
compute_pressure.cpp:  // process optional args
compute_pressure.cpp:  // error check
compute_pressure.cpp:/* ---------------------------------------------------------------------- */
compute_pressure.cpp:/* ---------------------------------------------------------------------- */
compute_pressure.cpp:  // set temperature compute, must be done in init()
compute_pressure.cpp:  // fixes could have changed or compute_modify could have changed it
compute_pressure.cpp:  // detect contributions to virial
compute_pressure.cpp:  // vptr points to all virial[6] contributions
compute_pressure.cpp:  // flag Kspace contribution separately, since not summed across procs
compute_pressure.cpp:/* ----------------------------------------------------------------------
compute_pressure.cpp:------------------------------------------------------------------------- */
compute_pressure.cpp:  // invoke temperature if it hasn't been already
compute_pressure.cpp:    inv_volume = 1.0 / (domain->xprd * domain->yprd * domain->zprd);
compute_pressure.cpp:                virial[0] + virial[1] + virial[2]) / 3.0 * inv_volume * nktv2p;
compute_pressure.cpp:      scalar = (virial[0] + virial[1] + virial[2]) / 3.0 * inv_volume * nktv2p;
compute_pressure.cpp:    inv_volume = 1.0 / (domain->xprd * domain->yprd);
compute_pressure.cpp:                virial[0] + virial[1]) / 2.0 * inv_volume * nktv2p;
compute_pressure.cpp:      scalar = (virial[0] + virial[1]) / 2.0 * inv_volume * nktv2p;
compute_pressure.cpp:/* ----------------------------------------------------------------------
compute_pressure.cpp:------------------------------------------------------------------------- */
compute_pressure.cpp:    error->all(FLERR,"Must use 'kspace_modify pressure/scalar no' for "
compute_pressure.cpp:  // invoke temperature if it hasn't been already
compute_pressure.cpp:    inv_volume = 1.0 / (domain->xprd * domain->yprd * domain->zprd);
compute_pressure.cpp:    inv_volume = 1.0 / (domain->xprd * domain->yprd);
compute_pressure.cpp:/* ---------------------------------------------------------------------- */
compute_pressure.cpp:  // sum contributions to virial from forces and fixes
compute_pressure.cpp:  // sum virial across procs
compute_pressure.cpp:  // KSpace virial contribution is already summed across procs
compute_pressure.cpp:  // LJ long-range tail correction, only if pair contributions are included
compute_pressure.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ----------------------------------------------------------------------
compute_property_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_property_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_property_atom.cpp:------------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute property/atom command");
compute_property_atom.cpp:  // parse input values
compute_property_atom.cpp:  // customize a new keyword by adding to if statement
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_ellipsoid) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_ellipsoid) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_ellipsoid) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_line) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_line) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_line) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_line) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_line) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_line) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:      if (!avec_tri) error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom for "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom integer "
compute_property_atom.cpp:        error->all(FLERR,"Compute property/atom floating point "
compute_property_atom.cpp:    // check if atom style recognizes keyword
compute_property_atom.cpp:        error->all(FLERR,"Invalid keyword in compute property/atom command");
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:  // grow vector or array if necessary
compute_property_atom.cpp:      memory->create(vector_atom,nmax,"property/atom:vector");
compute_property_atom.cpp:      memory->create(array_atom,nmax,nvalues,"property/atom:array");
compute_property_atom.cpp:  // fill vector or array with per-atom values
compute_property_atom.cpp:/* ----------------------------------------------------------------------
compute_property_atom.cpp:------------------------------------------------------------------------- */
compute_property_atom.cpp:/* ----------------------------------------------------------------------
compute_property_atom.cpp:   one method for every keyword compute property/atom can output
compute_property_atom.cpp:------------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:  double invxprd = 1.0/domain->xprd;
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:  double invyprd = 1.0/domain->yprd;
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:  double invzprd = 1.0/domain->zprd;
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_atom.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_property_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:  if (narg < 5) error->all(FLERR,"Illegal compute property/chunk command");
compute_property_chunk.cpp:  // ID of compute chunk/atom
compute_property_chunk.cpp:  // parse values
compute_property_chunk.cpp:	error->all(FLERR,"Compute chunk/atom stores no IDs for "
compute_property_chunk.cpp:                   "compute property/chunk");
compute_property_chunk.cpp:	error->all(FLERR,"Compute chunk/atom stores no coord1 for "
compute_property_chunk.cpp:                   "compute property/chunk");
compute_property_chunk.cpp:	error->all(FLERR,"Compute chunk/atom stores no coord2 for "
compute_property_chunk.cpp:                   "compute property/chunk");
compute_property_chunk.cpp:	error->all(FLERR,"Compute chunk/atom stores no coord3 for "
compute_property_chunk.cpp:                   "compute property/chunk");
compute_property_chunk.cpp:                    "Invalid keyword in compute property/chunk command");
compute_property_chunk.cpp:  // initialization
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for "
compute_property_chunk.cpp:               "compute property/chunk");
compute_property_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_property_chunk.cpp:    error->all(FLERR,"Compute property/chunk does not use chunk/atom compute");
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_property_chunk.cpp:  // if need count, extract ichunk index vector from compute
compute_property_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_property_chunk.cpp:  // fill vector
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_property_chunk.cpp:  // if need count, extract ichunk index vector from compute
compute_property_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_property_chunk.cpp:  // fill array
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:   lock methods: called by fix ave/time
compute_property_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_property_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:  if (nvalues == 1) memory->create(vector,maxchunk,"property/chunk:vector");
compute_property_chunk.cpp:  else memory->create(array,maxchunk,nvalues,"property/chunk:array");
compute_property_chunk.cpp:    memory->create(count_one,maxchunk,"property/chunk:count_one");
compute_property_chunk.cpp:    memory->create(count_all,maxchunk,"property/chunk:count_all");
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ----------------------------------------------------------------------
compute_property_chunk.cpp:   one method for every keyword compute property/chunk can output
compute_property_chunk.cpp:------------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ----------------------------------------------------------------------
compute_property_local.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_property_local.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_property_local.cpp:------------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute property/local command");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:                   "Compute property/local cannot use these inputs together");
compute_property_local.cpp:  // optional args
compute_property_local.cpp:        error->all(FLERR,"Illegal compute property/local command");
compute_property_local.cpp:      else error->all(FLERR,"Illegal compute property/local command");
compute_property_local.cpp:    } else error->all(FLERR,"Illegal compute property/local command");
compute_property_local.cpp:  // error check
compute_property_local.cpp:    error->all(FLERR,"Compute property/local does not (yet) work "
compute_property_local.cpp:               "Compute property/local for property that isn't allocated");
compute_property_local.cpp:               "Compute property/local for property that isn't allocated");
compute_property_local.cpp:               "Compute property/local for property that isn't allocated");
compute_property_local.cpp:               "Compute property/local for property that isn't allocated");
compute_property_local.cpp:    error->all(FLERR,"Compute property/local requires atom attribute radius");
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:      error->all(FLERR,"No pair style is defined for compute property/local");
compute_property_local.cpp:      error->all(FLERR,"Pair style does not support compute property/local");
compute_property_local.cpp:  // for NEIGH/PAIR need an occasional half neighbor list
compute_property_local.cpp:  // do initial memory allocation so that memory_usage() is correct
compute_property_local.cpp:  // cannot be done yet for NEIGH/PAIR, since neigh list does not exist
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:  // count local entries and generate list of indices
compute_property_local.cpp:  // fill vector or array with local values
compute_property_local.cpp:/* ----------------------------------------------------------------------
compute_property_local.cpp:------------------------------------------------------------------------- */
compute_property_local.cpp:  // invoke half neighbor list (will copy or build if necessary)
compute_property_local.cpp:  // loop over neighbors of my atoms
compute_property_local.cpp:  // skip if I or J are not in group
compute_property_local.cpp:  // for newton = 0 and J = ghost atom,
compute_property_local.cpp:  //   need to insure I,J pair is only output by one proc
compute_property_local.cpp:  //   use same itag,jtag logic as in Neighbor::neigh_half_nsq()
compute_property_local.cpp:      // itag = jtag is possible for long cutoffs that include images of self
compute_property_local.cpp:/* ----------------------------------------------------------------------
compute_property_local.cpp:------------------------------------------------------------------------- */
compute_property_local.cpp:/* ----------------------------------------------------------------------
compute_property_local.cpp:------------------------------------------------------------------------- */
compute_property_local.cpp:/* ----------------------------------------------------------------------
compute_property_local.cpp:------------------------------------------------------------------------- */
compute_property_local.cpp:/* ----------------------------------------------------------------------
compute_property_local.cpp:------------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:  // grow vector_local or array_local, also indices
compute_property_local.cpp:    memory->create(vlocal,nmax,"property/local:vector_local");
compute_property_local.cpp:    memory->create(alocal,nmax,nvalues,"property/local:array_local");
compute_property_local.cpp:  memory->create(indices,nmax,2,"property/local:indices");
compute_property_local.cpp:/* ----------------------------------------------------------------------
compute_property_local.cpp:------------------------------------------------------------------------- */
compute_property_local.cpp:/* ----------------------------------------------------------------------
compute_property_local.cpp:   one method for every keyword compute property/local can output
compute_property_local.cpp:------------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_property_local.cpp:/* ---------------------------------------------------------------------- */
compute_rdf.cpp:/* ----------------------------------------------------------------------
compute_rdf.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_rdf.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_rdf.cpp:------------------------------------------------------------------------- */
compute_rdf.cpp:/* ----------------------------------------------------------------------
compute_rdf.cpp:------------------------------------------------------------------------- */
compute_rdf.cpp:/* ---------------------------------------------------------------------- */
compute_rdf.cpp:  // optional args
compute_rdf.cpp:  // nargpair = # of pairwise args, starting at iarg = 4
compute_rdf.cpp:  // pairwise args
compute_rdf.cpp:  else npairs = nargpair/2;
compute_rdf.cpp:/* ---------------------------------------------------------------------- */
compute_rdf.cpp:/* ---------------------------------------------------------------------- */
compute_rdf.cpp:    double cutghost;            // as computed by Neighbor and Comm
compute_rdf.cpp:    delr = cutoff_user / nbin;
compute_rdf.cpp:  } else delr = force->pair->cutforce / nbin;
compute_rdf.cpp:  delrinv = 1.0/delr;
compute_rdf.cpp:  // set 1st column of output array to bin coords
compute_rdf.cpp:  // count atoms of each type that are also in group
compute_rdf.cpp:  // icount = # of I atoms participating in I,J pairs for each histogram
compute_rdf.cpp:  // jcount = # of J atoms participating in I,J pairs for each histogram
compute_rdf.cpp:  // duplicates = # of atoms in both groups I and J for each histogram
compute_rdf.cpp:  // need an occasional half neighbor list
compute_rdf.cpp:  // if user specified, request a cutoff = cutoff_user + skin
compute_rdf.cpp:  // skin is included b/c Neighbor uses this value similar
compute_rdf.cpp:  //   to its cutneighmax = force cutoff + skin
compute_rdf.cpp:  // also, this NeighList may be used by this compute for multiple steps
compute_rdf.cpp:  //   (until next reneighbor), so it needs to contain atoms further
compute_rdf.cpp:  //   than cutoff_user apart, just like a normal neighbor list does
compute_rdf.cpp:/* ---------------------------------------------------------------------- */
compute_rdf.cpp:/* ---------------------------------------------------------------------- */
compute_rdf.cpp:  // invoke half neighbor list (will copy or build if necessary)
compute_rdf.cpp:  // zero the histogram counts
compute_rdf.cpp:  // tally the RDF
compute_rdf.cpp:  // both atom i and j must be in fix group
compute_rdf.cpp:  // itype,jtype must have been specified by user
compute_rdf.cpp:  // consider I,J as one interaction even if neighbor pair is stored on 2 procs
compute_rdf.cpp:  // tally I,J pair each time I is central atom, and each time J is central
compute_rdf.cpp:      // if both weighting factors are 0, skip this pair
compute_rdf.cpp:      // could be 0 and still be in neigh list for long-range Coulombics
compute_rdf.cpp:      // want consistency with non-charged pairs which wouldn't be in list
compute_rdf.cpp:  // sum histograms across procs
compute_rdf.cpp:  // convert counts to g(r) and coord(r) and copy into output array
compute_rdf.cpp:  // vfrac = fraction of volume in shell m
compute_rdf.cpp:  // npairs = number of pairs, corrected for duplicates
compute_rdf.cpp:  // duplicates = pairs in which both atoms are the same
compute_rdf.cpp:    constant = 4.0*MY_PI / (3.0*domain->xprd*domain->yprd*domain->zprd);
compute_rdf.cpp:                - static_cast<double>(duplicates[m])/icount[m] : 0.0;
compute_rdf.cpp:          gr = histall[m][ibin] / (vfrac * normfac * icount[m]);
compute_rdf.cpp:    constant = MY_PI / (domain->xprd*domain->yprd);
compute_rdf.cpp:                - static_cast<double>(duplicates[m])/icount[m] : 0.0;
compute_rdf.cpp:          gr = histall[m][ibin] / (vfrac * normfac * icount[m]);
compute_reduce.cpp:/* ----------------------------------------------------------------------
compute_reduce.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_reduce.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_reduce.cpp:------------------------------------------------------------------------- */
compute_reduce.cpp:enum{SUM,SUMSQ,MINN,MAXX,AVE,AVESQ};             // also in ReduceRegion
compute_reduce.cpp:/* ---------------------------------------------------------------------- */
compute_reduce.cpp:  } else if (strcmp(style,"reduce/region") == 0) {
compute_reduce.cpp:    if (narg < 6) error->all(FLERR,"Illegal compute reduce/region command");
compute_reduce.cpp:      error->all(FLERR,"Region ID for compute reduce/region does not exist");
compute_reduce.cpp:  // expand args if any have wildcard character "*"
compute_reduce.cpp:  // parse values until one isn't recognized
compute_reduce.cpp:  // optional args
compute_reduce.cpp:  // delete replace if not set
compute_reduce.cpp:  // if wildcard expansion occurred, free earg memory from expand_args()
compute_reduce.cpp:  // setup and error check
compute_reduce.cpp:  // this compute produces either a scalar or vector
compute_reduce.cpp:/* ---------------------------------------------------------------------- */
compute_reduce.cpp:/* ---------------------------------------------------------------------- */
compute_reduce.cpp:  // set indices of all computes,fixes,variables
compute_reduce.cpp:  // set index and check validity of region
compute_reduce.cpp:      error->all(FLERR,"Region ID for compute reduce/region does not exist");
compute_reduce.cpp:/* ---------------------------------------------------------------------- */
compute_reduce.cpp:    if (n) scalar /= n;
compute_reduce.cpp:/* ---------------------------------------------------------------------- */
compute_reduce.cpp:      if (n) vector[m] /= n;
compute_reduce.cpp:/* ----------------------------------------------------------------------
compute_reduce.cpp:     sum/min/max/ave all values in vector
compute_reduce.cpp:------------------------------------------------------------------------- */
compute_reduce.cpp:  // invoke the appropriate attribute,compute,fix,variable
compute_reduce.cpp:  // for flag = -1, compute scalar quantity by scanning over atom properties
compute_reduce.cpp:  // only include atoms in group for atom properties and per-atom quantities
compute_reduce.cpp:  // invoke compute if not previously invoked
compute_reduce.cpp:  // access fix fields, check if fix frequency is a match
compute_reduce.cpp:  // evaluate atom-style variable
compute_reduce.cpp:/* ---------------------------------------------------------------------- */
compute_reduce.cpp:/* ----------------------------------------------------------------------
compute_reduce.cpp:   for MIN/MAX, also update index with winner
compute_reduce.cpp:------------------------------------------------------------------------- */
compute_reduce.cpp:/* ----------------------------------------------------------------------
compute_reduce.cpp:------------------------------------------------------------------------- */
compute_reduce_region.cpp:/* ----------------------------------------------------------------------
compute_reduce_region.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_reduce_region.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_reduce_region.cpp:------------------------------------------------------------------------- */
compute_reduce_region.cpp:enum{SUM,SUMSQ,MINN,MAXX,AVE,AVESQ};          // also in ComputeReduce
compute_reduce_region.cpp:/* ---------------------------------------------------------------------- */
compute_reduce_region.cpp:/* ----------------------------------------------------------------------
compute_reduce_region.cpp:     sum/min/max/ave all values in vector
compute_reduce_region.cpp:------------------------------------------------------------------------- */
compute_reduce_region.cpp:  // invoke the appropriate attribute,compute,fix,variable
compute_reduce_region.cpp:  // compute scalar quantity by summing over atom scalars
compute_reduce_region.cpp:  // only include atoms in group
compute_reduce_region.cpp:  // invoke compute if not previously invoked
compute_reduce_region.cpp:  // check if fix frequency is a match
compute_reduce_region.cpp:  // evaluate atom-style variable
compute_reduce_region.cpp:      memory->create(varatom,maxatom,"reduce/region:varatom");
compute_reduce_region.cpp:/* ---------------------------------------------------------------------- */
compute_slice.cpp:/* ----------------------------------------------------------------------
compute_slice.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_slice.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_slice.cpp:------------------------------------------------------------------------- */
compute_slice.cpp:/* ---------------------------------------------------------------------- */
compute_slice.cpp:  // parse remaining values until one isn't recognized
compute_slice.cpp:  // setup and error check
compute_slice.cpp:  // this compute produces either a vector or array
compute_slice.cpp:  // for vector, set intensive/extensive to mirror input values
compute_slice.cpp:  // for array, set intensive if all input values are intensive, else extensive
compute_slice.cpp:    size_vector = (nstop-nstart) / nskip;
compute_slice.cpp:    size_array_rows = (nstop-nstart) / nskip;
compute_slice.cpp:        // variable is always intensive, does not change extarray
compute_slice.cpp:/* ---------------------------------------------------------------------- */
compute_slice.cpp:/* ---------------------------------------------------------------------- */
compute_slice.cpp:  // set indices and check validity of all computes,fixes
compute_slice.cpp:/* ---------------------------------------------------------------------- */
compute_slice.cpp:/* ---------------------------------------------------------------------- */
compute_slice.cpp:/* ----------------------------------------------------------------------
compute_slice.cpp:------------------------------------------------------------------------- */
compute_slice.cpp:  // invoke the appropriate compute if needed
compute_slice.cpp:  // access fix fields, check if fix frequency is a match
compute_slice.cpp:    // invoke vector-style variable
compute_spin.cpp:/* ----------------------------------------------------------------------
compute_spin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_spin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_spin.cpp:------------------------------------------------------------------------- */
compute_spin.cpp:/* ---------------------------------------------------------------------- */
compute_spin.cpp:  if ((narg != 3) && (narg != 4)) error->all(FLERR,"Illegal compute compute/spin command");
compute_spin.cpp:/* ---------------------------------------------------------------------- */
compute_spin.cpp:/* ---------------------------------------------------------------------- */
compute_spin.cpp:  hbar = force->hplanck/MY_2PI;
compute_spin.cpp:/* ---------------------------------------------------------------------- */
compute_spin.cpp:  // compute total magnetization and magnetic energy 
compute_spin.cpp:  // compute spin temperature; See Nurdin et al., Phys. Rev. E 61, 2000
compute_spin.cpp:      else error->all(FLERR,"Compute spin/compute declared magnetic quantities (sp and mumag flags)");
compute_spin.cpp:  double scale = 1.0/countsptot;
compute_spin.cpp:  spintemperature = hbar*tempnumtot/2.0/kb/tempdenomtot;    
compute_spin.cpp:/* ----------------------------------------------------------------------
compute_spin.cpp:------------------------------------------------------------------------- */
compute_spin.cpp:  memory->create(mag,4,"compute/spin:mag");
compute_spin.cpp:  memory->create(magtot,5,"compute/spin:mag");
compute_spin.cpp:  memory->create(vector,7,"compute/spin:vector");
compute_stress_atom.cpp:/* ----------------------------------------------------------------------
compute_stress_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_stress_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_stress_atom.cpp:------------------------------------------------------------------------- */
compute_stress_atom.cpp:/* ---------------------------------------------------------------------- */
compute_stress_atom.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute stress/atom command");
compute_stress_atom.cpp:  // store temperature ID used by stress computation
compute_stress_atom.cpp:  // insure it is valid for temperature computation
compute_stress_atom.cpp:      error->all(FLERR,"Could not find compute stress/atom temperature ID");
compute_stress_atom.cpp:		 "Compute stress/atom temperature ID does not "
compute_stress_atom.cpp:  // process optional args
compute_stress_atom.cpp:      } else error->all(FLERR,"Illegal compute stress/atom command");
compute_stress_atom.cpp:/* ---------------------------------------------------------------------- */
compute_stress_atom.cpp:/* ---------------------------------------------------------------------- */
compute_stress_atom.cpp:  // set temperature compute, must be done in init()
compute_stress_atom.cpp:  // fixes could have changed or compute_modify could have changed it
compute_stress_atom.cpp:      error->all(FLERR,"Could not find compute stress/atom temperature ID");
compute_stress_atom.cpp:/* ---------------------------------------------------------------------- */
compute_stress_atom.cpp:  // grow local stress array if necessary
compute_stress_atom.cpp:  // needs to be atom->nmax in length
compute_stress_atom.cpp:    memory->create(stress,nmax,6,"stress/atom:stress");
compute_stress_atom.cpp:  // npair includes ghosts if either newton flag is set
compute_stress_atom.cpp:  //   b/c some bonds/dihedrals call pair::ev_tally with pairwise info
compute_stress_atom.cpp:  // nbond includes ghosts if newton_bond is set
compute_stress_atom.cpp:  // ntotal includes ghosts if either newton flag is set
compute_stress_atom.cpp:  // KSpace includes ghosts if tip4pflag is set
compute_stress_atom.cpp:  // clear local stress array
compute_stress_atom.cpp:  // add in per-atom contributions from each force
compute_stress_atom.cpp:  // add in per-atom contributions from relevant fixes
compute_stress_atom.cpp:  // skip if vatom = NULL
compute_stress_atom.cpp:  // possible during setup phase if fix has not initialized its vatom yet
compute_stress_atom.cpp:  // e.g. fix ave/spatial defined before fix shake,
compute_stress_atom.cpp:  //   and fix ave/spatial uses a per-atom stress from this compute as input
compute_stress_atom.cpp:  // communicate ghost virials between neighbor procs
compute_stress_atom.cpp:  // zero virial of atoms not in group
compute_stress_atom.cpp:  // only do this after comm since ghost contributions must be included
compute_stress_atom.cpp:  // include kinetic energy term for each atom in group
compute_stress_atom.cpp:  // apply temperature bias is applicable
compute_stress_atom.cpp:  // mvv2e converts mv^2 to energy
compute_stress_atom.cpp:      // invoke temperature if it hasn't been already
compute_stress_atom.cpp:      // this insures bias factor is pre-computed
compute_stress_atom.cpp:  // convert to stress*volume units = -pressure*volume
compute_stress_atom.cpp:/* ---------------------------------------------------------------------- */
compute_stress_atom.cpp:/* ---------------------------------------------------------------------- */
compute_stress_atom.cpp:/* ----------------------------------------------------------------------
compute_stress_atom.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_temp_chunk.cpp:  if (narg < 4) error->all(FLERR,"Illegal compute temp/chunk command");
compute_temp_chunk.cpp:  // ID of compute chunk/atom
compute_temp_chunk.cpp:  // optional per-chunk values
compute_temp_chunk.cpp:  // optional args
compute_temp_chunk.cpp:        error->all(FLERR,"Illegal compute temp/chunk command");
compute_temp_chunk.cpp:      else error->all(FLERR,"Illegal compute temp/chunk command");
compute_temp_chunk.cpp:        error->all(FLERR,"Illegal compute temp/chunk command");
compute_temp_chunk.cpp:        error->all(FLERR,"Illegal compute temp/chunk command");
compute_temp_chunk.cpp:        error->all(FLERR,"Illegal compute temp/chunk command");
compute_temp_chunk.cpp:    } else error->all(FLERR,"Illegal compute temp/chunk command");
compute_temp_chunk.cpp:  // error check on bias compute
compute_temp_chunk.cpp:  // this compute only calculates a bias, if comflag is set
compute_temp_chunk.cpp:  // won't be two biases since comflag and biasflag cannot both be set
compute_temp_chunk.cpp:    error->all(FLERR,"Cannot use both com and bias with compute temp/chunk");
compute_temp_chunk.cpp:  // vector data
compute_temp_chunk.cpp:  // chunk-based data
compute_temp_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_temp_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for "
compute_temp_chunk.cpp:               "compute temp/chunk");
compute_temp_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_temp_chunk.cpp:    error->all(FLERR,"Compute temp/chunk does not use chunk/atom compute");
compute_temp_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_temp_chunk.cpp:  // calculate chunk assignments,
compute_temp_chunk.cpp:  //   since only atoms in chunks contribute to global temperature
compute_temp_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_temp_chunk.cpp:  // extract ichunk index vector from compute
compute_temp_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_temp_chunk.cpp:  // remove velocity bias
compute_temp_chunk.cpp:  // calculate COM velocity for each chunk
compute_temp_chunk.cpp:  // won't be invoked with bias also removed = 2 biases
compute_temp_chunk.cpp:  // calculate global temperature, optionally removing COM velocity
compute_temp_chunk.cpp:  // restore velocity bias
compute_temp_chunk.cpp:  // final temperature
compute_temp_chunk.cpp:  if (dof > 0.0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_temp_chunk.cpp:  // calculate chunk assignments,
compute_temp_chunk.cpp:  //   since only atoms in chunks contribute to global temperature
compute_temp_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_temp_chunk.cpp:  // extract ichunk index vector from compute
compute_temp_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_temp_chunk.cpp:  // remove velocity bias
compute_temp_chunk.cpp:  // calculate COM velocity for each chunk
compute_temp_chunk.cpp:  // won't be invoked with bias also removed = 2 biases
compute_temp_chunk.cpp:  // calculate KE tensor, optionally removing COM velocity
compute_temp_chunk.cpp:  // restore velocity bias
compute_temp_chunk.cpp:  // final KE
compute_temp_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_temp_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_temp_chunk.cpp:  // extract ichunk index vector from compute
compute_temp_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_temp_chunk.cpp:  // remove velocity bias
compute_temp_chunk.cpp:  // calculate COM velocity for each chunk whether comflag set or not
compute_temp_chunk.cpp:  //   needed by some values even if comflag not set
compute_temp_chunk.cpp:  // important to do this after velocity bias is removed
compute_temp_chunk.cpp:  //   otherwise per-chunk values that use both v and vcm will be inconsistent
compute_temp_chunk.cpp:  // compute each value
compute_temp_chunk.cpp:  // restore velocity bias
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:  // avoid re-computing VCM more than once per step
compute_temp_chunk.cpp:      vcmall[i][0] /= masstotal[i];
compute_temp_chunk.cpp:      vcmall[i][1] /= masstotal[i];
compute_temp_chunk.cpp:      vcmall[i][2] /= masstotal[i];
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:  // zero local per-chunk values
compute_temp_chunk.cpp:  // per-chunk temperature, option for removing COM velocity
compute_temp_chunk.cpp:  // sum across procs
compute_temp_chunk.cpp:  // normalize temperatures by per-chunk DOF
compute_temp_chunk.cpp:    if (dof > 0.0) tfactor = mvv2e / (dof * boltz);
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:  // zero local per-chunk values
compute_temp_chunk.cpp:  // per-chunk COM KE
compute_temp_chunk.cpp:  // sum across procs
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:  // zero local per-chunk values
compute_temp_chunk.cpp:  // per-chunk internal KE
compute_temp_chunk.cpp:  // sum across procs
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:   lock methods: called by fix ave/time
compute_temp_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_temp_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_chunk.cpp:  memory->create(sum,maxchunk,"temp/chunk:sum");
compute_temp_chunk.cpp:  memory->create(sumall,maxchunk,"temp/chunk:sumall");
compute_temp_chunk.cpp:  memory->create(count,maxchunk,"temp/chunk:count");
compute_temp_chunk.cpp:  memory->create(countall,maxchunk,"temp/chunk:countall");
compute_temp_chunk.cpp:  memory->create(array,maxchunk,nvalues,"temp/chunk:array");
compute_temp_chunk.cpp:    memory->create(massproc,maxchunk,"vcm/chunk:massproc");
compute_temp_chunk.cpp:    memory->create(masstotal,maxchunk,"vcm/chunk:masstotal");
compute_temp_chunk.cpp:    memory->create(vcm,maxchunk,3,"vcm/chunk:vcm");
compute_temp_chunk.cpp:    memory->create(vcmall,maxchunk,3,"vcm/chunk:vcmall");
compute_temp_chunk.cpp:/* ----------------------------------------------------------------------
compute_temp_chunk.cpp:------------------------------------------------------------------------- */
compute_temp_com.cpp:/* ----------------------------------------------------------------------
compute_temp_com.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp_com.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp_com.cpp:------------------------------------------------------------------------- */
compute_temp_com.cpp:/* ---------------------------------------------------------------------- */
compute_temp_com.cpp:/* ---------------------------------------------------------------------- */
compute_temp_com.cpp:/* ---------------------------------------------------------------------- */
compute_temp_com.cpp:/* ---------------------------------------------------------------------- */
compute_temp_com.cpp:/* ---------------------------------------------------------------------- */
compute_temp_com.cpp:  if (dof > 0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp_com.cpp:/* ---------------------------------------------------------------------- */
compute_temp_com.cpp:/* ---------------------------------------------------------------------- */
compute_temp_com.cpp:/* ----------------------------------------------------------------------
compute_temp_com.cpp:------------------------------------------------------------------------- */
compute_temp_com.cpp:/* ----------------------------------------------------------------------
compute_temp_com.cpp:------------------------------------------------------------------------- */
compute_temp_com.cpp:/* ----------------------------------------------------------------------
compute_temp_com.cpp:------------------------------------------------------------------------- */
compute_temp_com.cpp:/* ----------------------------------------------------------------------
compute_temp_com.cpp:------------------------------------------------------------------------- */
compute_temp.cpp:/* ----------------------------------------------------------------------
compute_temp.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp.cpp:------------------------------------------------------------------------- */
compute_temp.cpp:/* ---------------------------------------------------------------------- */
compute_temp.cpp:/* ---------------------------------------------------------------------- */
compute_temp.cpp:/* ---------------------------------------------------------------------- */
compute_temp.cpp:/* ---------------------------------------------------------------------- */
compute_temp.cpp:  if (dof > 0.0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp.cpp:/* ---------------------------------------------------------------------- */
compute_temp.cpp:/* ---------------------------------------------------------------------- */
compute_temp_deform.cpp:/* ----------------------------------------------------------------------
compute_temp_deform.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp_deform.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp_deform.cpp:------------------------------------------------------------------------- */
compute_temp_deform.cpp:/* ----------------------------------------------------------------------
compute_temp_deform.cpp:------------------------------------------------------------------------- */
compute_temp_deform.cpp:enum{NO_REMAP,X_REMAP,V_REMAP};                   // same as fix_deform.cpp
compute_temp_deform.cpp:/* ---------------------------------------------------------------------- */
compute_temp_deform.cpp:  if (narg != 3) error->all(FLERR,"Illegal compute temp/deform command");
compute_temp_deform.cpp:/* ---------------------------------------------------------------------- */
compute_temp_deform.cpp:/* ---------------------------------------------------------------------- */
compute_temp_deform.cpp:  // check fix deform remap settings
compute_temp_deform.cpp:        error->warning(FLERR,"Using compute temp/deform with inconsistent "
compute_temp_deform.cpp:                   "Using compute temp/deform with no fix deform defined");
compute_temp_deform.cpp:/* ---------------------------------------------------------------------- */
compute_temp_deform.cpp:/* ---------------------------------------------------------------------- */
compute_temp_deform.cpp:  if (dof > 0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp_deform.cpp:/* ---------------------------------------------------------------------- */
compute_temp_deform.cpp:  // lamda = 0-1 triclinic lamda coords
compute_temp_deform.cpp:  // vstream = streaming velocity = Hrate*lamda + Hratelo
compute_temp_deform.cpp:  // vthermal = thermal velocity = v - vstream
compute_temp_deform.cpp:/* ---------------------------------------------------------------------- */
compute_temp_deform.cpp:/* ----------------------------------------------------------------------
compute_temp_deform.cpp:------------------------------------------------------------------------- */
compute_temp_deform.cpp:/* ----------------------------------------------------------------------
compute_temp_deform.cpp:------------------------------------------------------------------------- */
compute_temp_deform.cpp:    memory->create(vbiasall,maxbias,3,"temp/deform:vbiasall");
compute_temp_deform.cpp:/* ----------------------------------------------------------------------
compute_temp_deform.cpp:------------------------------------------------------------------------- */
compute_temp_deform.cpp:/* ----------------------------------------------------------------------
compute_temp_deform.cpp:------------------------------------------------------------------------- */
compute_temp_deform.cpp:/* ---------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ----------------------------------------------------------------------
compute_temp_partial.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp_partial.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp_partial.cpp:------------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ---------------------------------------------------------------------- */
compute_temp_partial.cpp:  if (narg != 6) error->all(FLERR,"Illegal compute temp/partial command");
compute_temp_partial.cpp:    error->all(FLERR,"Illegal compute temp/partial command");
compute_temp_partial.cpp:    error->all(FLERR,"Compute temp/partial cannot use vz for 2d systemx");
compute_temp_partial.cpp:/* ---------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ---------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ----------------------------------------------------------------------
compute_temp_partial.cpp:   DOF = nper/dim (dim*N - S), where dim = dimensionality = 2 or 3
compute_temp_partial.cpp:------------------------------------------------------------------------- */
compute_temp_partial.cpp:  // distribute extra dofs evenly across active dimensions
compute_temp_partial.cpp:  dof -= (1.0*nper/domain->dimension)*(fix_dof + extra_dof);
compute_temp_partial.cpp:  if (dof > 0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp_partial.cpp:/* ---------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ---------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ---------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ----------------------------------------------------------------------
compute_temp_partial.cpp:------------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ----------------------------------------------------------------------
compute_temp_partial.cpp:------------------------------------------------------------------------- */
compute_temp_partial.cpp:    memory->create(vbiasall,maxbias,3,"temp/partial:vbiasall");
compute_temp_partial.cpp:/* ----------------------------------------------------------------------
compute_temp_partial.cpp:------------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ----------------------------------------------------------------------
compute_temp_partial.cpp:------------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ----------------------------------------------------------------------
compute_temp_partial.cpp:------------------------------------------------------------------------- */
compute_temp_partial.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ----------------------------------------------------------------------
compute_temp_profile.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp_profile.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp_profile.cpp:------------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:  if (narg < 7) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:    error->all(FLERR,"Compute temp/profile cannot use vz for 2d systemx");
compute_temp_profile.cpp:    if (iarg+2 > narg) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:    if (iarg+2 > narg) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:    if (iarg+2 > narg) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:      error->all(FLERR,"Compute temp/profile cannot bin z for 2d systems");
compute_temp_profile.cpp:    if (iarg+3 > narg) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:    if (iarg+3 > narg) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:      error->all(FLERR,"Compute temp/profile cannot bin z for 2d systems");
compute_temp_profile.cpp:    if (iarg+3 > narg) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:      error->all(FLERR,"Compute temp/profile cannot bin z for 2d systems");
compute_temp_profile.cpp:    if (iarg+4 > narg) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:      error->all(FLERR,"Compute temp/profile cannot bin z for 2d systems");
compute_temp_profile.cpp:  } else error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:  // optional keywords
compute_temp_profile.cpp:        error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:      else error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:    } else error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:  // setup
compute_temp_profile.cpp:  if (nbins <= 0) error->all(FLERR,"Illegal compute temp/profile command");
compute_temp_profile.cpp:  memory->create(vbin,nbins,ncount,"temp/profile:vbin");
compute_temp_profile.cpp:  memory->create(binave,nbins,ncount,"temp/profile:binave");
compute_temp_profile.cpp:    memory->create(tbin,nbins,"temp/profile:tbin");
compute_temp_profile.cpp:    memory->create(tbinall,nbins,"temp/profile:tbinall");
compute_temp_profile.cpp:    memory->create(array,nbins,2,"temp/profile:array");
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:  // ptrs to domain data
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:  // subtract additional d*Nbins DOF, as in Evans and Morriss paper
compute_temp_profile.cpp:  if (dof > 0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_profile.cpp:      if (dof > 0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp_profile.cpp:/* ----------------------------------------------------------------------
compute_temp_profile.cpp:------------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ----------------------------------------------------------------------
compute_temp_profile.cpp:------------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ----------------------------------------------------------------------
compute_temp_profile.cpp:------------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ----------------------------------------------------------------------
compute_temp_profile.cpp:------------------------------------------------------------------------- */
compute_temp_profile.cpp:/* ----------------------------------------------------------------------
compute_temp_profile.cpp:------------------------------------------------------------------------- */
compute_temp_profile.cpp:  // clear bins, including particle mass and count
compute_temp_profile.cpp:  // sum each particle's mass-weighted velocity, mass, count to appropriate bin
compute_temp_profile.cpp:  // sum bins across processors
compute_temp_profile.cpp:  // compute ave COM velocity in each bin, checking for no particles
compute_temp_profile.cpp:        binave[i][j] /= binave[i][nc2];
compute_temp_profile.cpp:/* ----------------------------------------------------------------------
compute_temp_profile.cpp:------------------------------------------------------------------------- */
compute_temp_profile.cpp:  invdelta[0] = nbinx / prd[0];
compute_temp_profile.cpp:  invdelta[1] = nbiny / prd[1];
compute_temp_profile.cpp:  invdelta[2] = nbinz / prd[2];
compute_temp_profile.cpp:/* ----------------------------------------------------------------------
compute_temp_profile.cpp:------------------------------------------------------------------------- */
compute_temp_profile.cpp:  // reallocate bin array if necessary
compute_temp_profile.cpp:    memory->create(bin,maxatom,"temp/profile:bin");
compute_temp_profile.cpp:  // assign each atom to a bin, accounting for PBC
compute_temp_profile.cpp:  // if triclinic, do this in lamda space
compute_temp_profile.cpp:/* ---------------------------------------------------------------------- */
compute_temp_ramp.cpp:/* ----------------------------------------------------------------------
compute_temp_ramp.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp_ramp.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp_ramp.cpp:------------------------------------------------------------------------- */
compute_temp_ramp.cpp:/* ---------------------------------------------------------------------- */
compute_temp_ramp.cpp:  // parse optional args
compute_temp_ramp.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal compute temp/ramp command");
compute_temp_ramp.cpp:      else error->all(FLERR,"Illegal compute temp/ramp command");
compute_temp_ramp.cpp:    } else error->all(FLERR,"Illegal compute temp/ramp command");
compute_temp_ramp.cpp:  // setup scaling
compute_temp_ramp.cpp:  // read standard args and apply scaling
compute_temp_ramp.cpp:  else error->all(FLERR,"Illegal compute temp/ramp command");
compute_temp_ramp.cpp:  else error->all(FLERR,"Illegal compute temp/ramp command");
compute_temp_ramp.cpp:/* ---------------------------------------------------------------------- */
compute_temp_ramp.cpp:/* ---------------------------------------------------------------------- */
compute_temp_ramp.cpp:/* ---------------------------------------------------------------------- */
compute_temp_ramp.cpp:  if (dof > 0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp_ramp.cpp:/* ---------------------------------------------------------------------- */
compute_temp_ramp.cpp:      fraction = (x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
compute_temp_ramp.cpp:/* ---------------------------------------------------------------------- */
compute_temp_ramp.cpp:      fraction = (x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
compute_temp_ramp.cpp:/* ----------------------------------------------------------------------
compute_temp_ramp.cpp:------------------------------------------------------------------------- */
compute_temp_ramp.cpp:  double fraction = (atom->x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
compute_temp_ramp.cpp:/* ----------------------------------------------------------------------
compute_temp_ramp.cpp:------------------------------------------------------------------------- */
compute_temp_ramp.cpp:    memory->create(vbiasall,maxbias,3,"temp/ramp:vbiasall");
compute_temp_ramp.cpp:      fraction = (atom->x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
compute_temp_ramp.cpp:/* ----------------------------------------------------------------------
compute_temp_ramp.cpp:------------------------------------------------------------------------- */
compute_temp_ramp.cpp:/* ----------------------------------------------------------------------
compute_temp_ramp.cpp:------------------------------------------------------------------------- */
compute_temp_ramp.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:/* ----------------------------------------------------------------------
compute_temp_region.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp_region.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp_region.cpp:------------------------------------------------------------------------- */
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute temp/region command");
compute_temp_region.cpp:    error->all(FLERR,"Region ID for compute temp/region does not exist");
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:  // set index and check validity of region
compute_temp_region.cpp:    error->all(FLERR,"Region ID for compute temp/region does not exist");
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:  if (dof > 0) scalar = force->mvv2e * tarray_all[1] / (dof * force->boltz);
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_region.cpp:/* ----------------------------------------------------------------------
compute_temp_region.cpp:------------------------------------------------------------------------- */
compute_temp_region.cpp:/* ----------------------------------------------------------------------
compute_temp_region.cpp:------------------------------------------------------------------------- */
compute_temp_region.cpp:    memory->create(vbiasall,maxbias,3,"temp/region:vbiasall");
compute_temp_region.cpp:/* ----------------------------------------------------------------------
compute_temp_region.cpp:------------------------------------------------------------------------- */
compute_temp_region.cpp:/* ----------------------------------------------------------------------
compute_temp_region.cpp:------------------------------------------------------------------------- */
compute_temp_region.cpp:/* ---------------------------------------------------------------------- */
compute_temp_sphere.cpp:/* ----------------------------------------------------------------------
compute_temp_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_temp_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_temp_sphere.cpp:------------------------------------------------------------------------- */
compute_temp_sphere.cpp:#define INERTIA 0.4          // moment of inertia prefactor for sphere
compute_temp_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_temp_sphere.cpp:  if (narg < 3) error->all(FLERR,"Illegal compute temp/sphere command");
compute_temp_sphere.cpp:        error->all(FLERR,"Illegal compute temp/sphere command");
compute_temp_sphere.cpp:        error->all(FLERR,"Illegal compute temp/sphere command");
compute_temp_sphere.cpp:      else error->all(FLERR,"Illegal compute temp/sphere command");
compute_temp_sphere.cpp:    } else error->all(FLERR,"Illegal compute temp/sphere command");
compute_temp_sphere.cpp:  // when computing only the rotational temperature,
compute_temp_sphere.cpp:  // do not remove DOFs for translation as set by default
compute_temp_sphere.cpp:  // error checks
compute_temp_sphere.cpp:    error->all(FLERR,"Compute temp/sphere requires atom style sphere");
compute_temp_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_temp_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_temp_sphere.cpp:    if (strcmp(tbias->style,"temp/region") == 0) tempbias = 2;
compute_temp_sphere.cpp:    // init and setup bias compute because
compute_temp_sphere.cpp:    // this compute's setup()->dof_compute() may be called first
compute_temp_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_temp_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_temp_sphere.cpp:  // 6 or 3 dof for extended/point particles for 3d
compute_temp_sphere.cpp:  // 3 or 2 dof for extended/point particles for 2d
compute_temp_sphere.cpp:  // which dof are included also depends on mode
compute_temp_sphere.cpp:  // assume full rotation of extended particles
compute_temp_sphere.cpp:  // user should correct this via compute_modify if needed
compute_temp_sphere.cpp:  // additional adjustments to dof
compute_temp_sphere.cpp:  if (dof > 0) tfactor = force->mvv2e / (dof * force->boltz);
compute_temp_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_temp_sphere.cpp:  // point particles will not contribute rotation due to radius = 0
compute_temp_sphere.cpp:/* ---------------------------------------------------------------------- */
compute_temp_sphere.cpp:  // point particles will not contribute rotation due to radius = 0
compute_temp_sphere.cpp:/* ----------------------------------------------------------------------
compute_temp_sphere.cpp:------------------------------------------------------------------------- */
compute_temp_sphere.cpp:/* ----------------------------------------------------------------------
compute_temp_sphere.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_torque_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_torque_chunk.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute torque/chunk command");
compute_torque_chunk.cpp:  // ID of compute chunk/atom
compute_torque_chunk.cpp:  // chunk-based data
compute_torque_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_torque_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for "
compute_torque_chunk.cpp:               "compute torque/chunk");
compute_torque_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_torque_chunk.cpp:    error->all(FLERR,"Compute torque/chunk does not use chunk/atom compute");
compute_torque_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_torque_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_torque_chunk.cpp:  // extract ichunk index vector from compute
compute_torque_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_torque_chunk.cpp:  // zero local per-chunk values
compute_torque_chunk.cpp:  // compute COM for each chunk
compute_torque_chunk.cpp:      comall[i][0] /= masstotal[i];
compute_torque_chunk.cpp:      comall[i][1] /= masstotal[i];
compute_torque_chunk.cpp:      comall[i][2] /= masstotal[i];
compute_torque_chunk.cpp:  // compute torque on each chunk
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:   lock methods: called by fix ave/time
compute_torque_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_torque_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_torque_chunk.cpp:  memory->create(massproc,maxchunk,"torque/chunk:massproc");
compute_torque_chunk.cpp:  memory->create(masstotal,maxchunk,"torque/chunk:masstotal");
compute_torque_chunk.cpp:  memory->create(com,maxchunk,3,"torque/chunk:com");
compute_torque_chunk.cpp:  memory->create(comall,maxchunk,3,"torque/chunk:comall");
compute_torque_chunk.cpp:  memory->create(torque,maxchunk,3,"torque/chunk:torque");
compute_torque_chunk.cpp:  memory->create(torqueall,maxchunk,3,"torque/chunk:torqueall");
compute_torque_chunk.cpp:/* ----------------------------------------------------------------------
compute_torque_chunk.cpp:------------------------------------------------------------------------- */
compute_vacf.cpp:/* ----------------------------------------------------------------------
compute_vacf.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_vacf.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_vacf.cpp:------------------------------------------------------------------------- */
compute_vacf.cpp:/* ---------------------------------------------------------------------- */
compute_vacf.cpp:  // create a new fix STORE style
compute_vacf.cpp:  // id = compute-ID + COMPUTE_STORE, fix group = compute group
compute_vacf.cpp:  // store current velocities in fix store array
compute_vacf.cpp:  // skip if reset from restart file
compute_vacf.cpp:  // displacement vector
compute_vacf.cpp:/* ---------------------------------------------------------------------- */
compute_vacf.cpp:  // check nfix in case all fixes have already been deleted
compute_vacf.cpp:/* ---------------------------------------------------------------------- */
compute_vacf.cpp:  // set fix which stores original atom velocities
compute_vacf.cpp:  // nvacf = # of atoms in group
compute_vacf.cpp:/* ---------------------------------------------------------------------- */
compute_vacf.cpp:    vector[0] /= nvacf;
compute_vacf.cpp:    vector[1] /= nvacf;
compute_vacf.cpp:    vector[2] /= nvacf;
compute_vacf.cpp:    vector[3] /= nvacf;
compute_vacf.cpp:/* ----------------------------------------------------------------------
compute_vacf.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
compute_vcm_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_vcm_chunk.cpp:  if (narg != 4) error->all(FLERR,"Illegal compute vcm/chunk command");
compute_vcm_chunk.cpp:  // ID of compute chunk/atom
compute_vcm_chunk.cpp:  // chunk-based data
compute_vcm_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_vcm_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for compute vcm/chunk");
compute_vcm_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
compute_vcm_chunk.cpp:    error->all(FLERR,"Compute vcm/chunk does not use chunk/atom compute");
compute_vcm_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_vcm_chunk.cpp:  // one-time calculation of per-chunk mass
compute_vcm_chunk.cpp:  // done in setup, so that ComputeChunkAtom::setup() is already called
compute_vcm_chunk.cpp:/* ---------------------------------------------------------------------- */
compute_vcm_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
compute_vcm_chunk.cpp:  // extract ichunk index vector from compute
compute_vcm_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
compute_vcm_chunk.cpp:  // zero local per-chunk values
compute_vcm_chunk.cpp:  // compute VCM for each chunk
compute_vcm_chunk.cpp:      vcmall[i][0] /= masstotal[i];
compute_vcm_chunk.cpp:      vcmall[i][1] /= masstotal[i];
compute_vcm_chunk.cpp:      vcmall[i][2] /= masstotal[i];
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:   lock methods: called by fix ave/time
compute_vcm_chunk.cpp:   these methods insure vector/array size is locked for Nfreq epoch
compute_vcm_chunk.cpp:     by passing lock info along to compute chunk/atom
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:   decrement lock counter in compute chunk/atom, it if still exists
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:   calculate and return # of chunks = length of vector/array
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
compute_vcm_chunk.cpp:  memory->create(massproc,maxchunk,"vcm/chunk:massproc");
compute_vcm_chunk.cpp:  memory->create(masstotal,maxchunk,"vcm/chunk:masstotal");
compute_vcm_chunk.cpp:  memory->create(vcm,maxchunk,3,"vcm/chunk:vcm");
compute_vcm_chunk.cpp:  memory->create(vcmall,maxchunk,3,"vcm/chunk:vcmall");
compute_vcm_chunk.cpp:/* ----------------------------------------------------------------------
compute_vcm_chunk.cpp:------------------------------------------------------------------------- */
create_atoms.cpp:/* ----------------------------------------------------------------------
create_atoms.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
create_atoms.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
create_atoms.cpp:------------------------------------------------------------------------- */
create_atoms.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
create_atoms.cpp:/* ---------------------------------------------------------------------- */
create_atoms.cpp:/* ---------------------------------------------------------------------- */
create_atoms.cpp:  // parse arguments
create_atoms.cpp:  // process optional keywords
create_atoms.cpp:  // error checks
create_atoms.cpp:  // error check and further setup for mode = MOLECULE
create_atoms.cpp:    // create_atoms uses geoemetric center of molecule for insertion
create_atoms.cpp:    // molecule random number generator, different for each proc
create_atoms.cpp:  // error check and further setup for variable test
create_atoms.cpp:  // demand non-none lattice be defined for BOX and REGION
create_atoms.cpp:  // else setup scaling for SINGLE and RANDOM
create_atoms.cpp:  // could use domain->lattice->lattice2box() to do conversion of
create_atoms.cpp:  //   lattice to box, but not consistent with other uses of units=lattice
create_atoms.cpp:  // triclinic remapping occurs in add_single()
create_atoms.cpp:  // set bounds for my proc in sublo[3] & subhi[3]
create_atoms.cpp:  // if periodic and style = BOX or REGION, i.e. using lattice:
create_atoms.cpp:  //   should create exactly 1 atom when 2 images are both "on" the boundary
create_atoms.cpp:  //   either image may be slightly inside/outside true box due to round-off
create_atoms.cpp:  //   if I am lo proc, decrement lower bound by EPSILON
create_atoms.cpp:  //     this will insure lo image is created
create_atoms.cpp:  //   if I am hi proc, decrement upper bound by 2.0*EPSILON
create_atoms.cpp:  //     this will insure hi image is not created
create_atoms.cpp:  //   thus insertion box is EPSILON smaller than true box
create_atoms.cpp:  //     and is shifted away from true boundary
create_atoms.cpp:  //     which is where atoms are likely to be generated
create_atoms.cpp:  // clear ghost count and any ghost bonus data internal to AtomVec
create_atoms.cpp:  // same logic as beginning of Comm::exchange()
create_atoms.cpp:  // do it now b/c creating atoms will overwrite ghost atoms
create_atoms.cpp:  // add atoms/molecules in one of 3 ways
create_atoms.cpp:  // init per-atom fix/compute/variable values for created atoms
create_atoms.cpp:  // set new total # of atoms and error check
create_atoms.cpp:  // add IDs for newly created atoms
create_atoms.cpp:  // check that atom IDs are valid
create_atoms.cpp:  // if global map exists, reset it
create_atoms.cpp:  // invoke map_init() b/c atom count has grown
create_atoms.cpp:  // for MOLECULE mode:
create_atoms.cpp:  // molecule can mean just a mol ID or bonds/angles/etc or mol templates
create_atoms.cpp:  // set molecule IDs for created atoms if atom->molecule_flag is set
create_atoms.cpp:  // reset new molecule bond,angle,etc and special values if defined
create_atoms.cpp:  // send atoms to new owning procs via irregular comm
create_atoms.cpp:  //   since not all atoms I created will be within my sub-domain
create_atoms.cpp:  // perform special list build if needed
create_atoms.cpp:    // molcreate = # of molecules I created
create_atoms.cpp:    int molcreate = (atom->nlocal - nlocal_previous) / onemol->natoms;
create_atoms.cpp:    // increment total bonds,angles,etc
create_atoms.cpp:    // if atom style template
create_atoms.cpp:    // maxmol = max molecule ID across all procs, for previous atoms
create_atoms.cpp:    // moloffset = max molecule ID for all molecules owned by previous procs
create_atoms.cpp:    //             including molecules existing before this creation
create_atoms.cpp:    // loop over molecules I created
create_atoms.cpp:    // set their molecule ID
create_atoms.cpp:    // reset their bond,angle,etc and special values
create_atoms.cpp:    // perform irregular comm to migrate atoms to new owning procs
create_atoms.cpp:  // clean up
create_atoms.cpp:  // print status
create_atoms.cpp:  // for MOLECULE mode:
create_atoms.cpp:  // create special bond lists for molecular systems,
create_atoms.cpp:  //   but not for atom style template
create_atoms.cpp:  // only if onemol added bonds but not special info
create_atoms.cpp:/* ----------------------------------------------------------------------
create_atoms.cpp:------------------------------------------------------------------------- */
create_atoms.cpp:  // remap atom if requested
create_atoms.cpp:  // if triclinic, convert to lamda coords (0-1)
create_atoms.cpp:  // if atom/molecule is in my subbox, create it
create_atoms.cpp:/* ----------------------------------------------------------------------
create_atoms.cpp:------------------------------------------------------------------------- */
create_atoms.cpp:  // random number generator, same for all procs
create_atoms.cpp:  // bounding box for atom creation
create_atoms.cpp:  // in real units, even if triclinic
create_atoms.cpp:  // only limit bbox by region if its bboxflag is set (interior region)
create_atoms.cpp:  // generate random positions for each new atom/molecule within bounding box
create_atoms.cpp:  // iterate until atom is within region, variable, and triclinic simulation box
create_atoms.cpp:  // if final atom position is in my subbox, create it
create_atoms.cpp:    // if triclinic, coord is now in lamda units
create_atoms.cpp:  // clean-up
create_atoms.cpp:/* ----------------------------------------------------------------------
create_atoms.cpp:------------------------------------------------------------------------- */
create_atoms.cpp:  // convert 8 corners of my subdomain from box coords to lattice coords
create_atoms.cpp:  // for orthogonal, use corner pts of my subbox
create_atoms.cpp:  // for triclinic, use bounding box of my subbox
create_atoms.cpp:  // xyz min to max = bounding box around the domain corners in lattice space
create_atoms.cpp:  // ilo:ihi,jlo:jhi,klo:khi = loop bounds for lattice overlap of my subbox
create_atoms.cpp:  // overlap = any part of a unit cell (face,edge,pt) in common with my subbox
create_atoms.cpp:  // in lattice space, subbox is a tilted box
create_atoms.cpp:  // but bbox of subbox is aligned with lattice axes
create_atoms.cpp:  // so ilo:khi unit cells should completely tile bounding box
create_atoms.cpp:  // decrement lo, increment hi to avoid round-off issues in lattice->bbox(),
create_atoms.cpp:  //   which can lead to missing atoms in rare cases
create_atoms.cpp:  // extra decrement of lo if min < 0, since static_cast(-1.5) = -1
create_atoms.cpp:  // iterate on 3d periodic lattice of unit cells using loop bounds
create_atoms.cpp:  // iterate on nbasis atoms in each unit cell
create_atoms.cpp:  // convert lattice coords to box coords
create_atoms.cpp:  // add atom or molecule (on each basis point) if it meets all criteria
create_atoms.cpp:          // convert from lattice coords to box coords
create_atoms.cpp:          // if a region was specified, test if atom is in it
create_atoms.cpp:          // if variable test specified, eval variable
create_atoms.cpp:          // test if atom/molecule position is in my subbox
create_atoms.cpp:          // add the atom or entire molecule to my list of atoms
create_atoms.cpp:/* ----------------------------------------------------------------------
create_atoms.cpp:------------------------------------------------------------------------- */
create_atoms.cpp:  // create atoms in molecule with atom ID = 0 and mol ID = 0
create_atoms.cpp:  // reset in caller after all molecules created by all procs
create_atoms.cpp:  // pass add_molecule_atom an offset of 0 since don't know
create_atoms.cpp:  //   max tag of atoms in previous molecules at this point
create_atoms.cpp:/* ----------------------------------------------------------------------
create_atoms.cpp:------------------------------------------------------------------------- */
create_bonds.cpp:/* ----------------------------------------------------------------------
create_bonds.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
create_bonds.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
create_bonds.cpp:------------------------------------------------------------------------- */
create_bonds.cpp:/* ---------------------------------------------------------------------- */
create_bonds.cpp:/* ---------------------------------------------------------------------- */
create_bonds.cpp:  // parse args
create_bonds.cpp:  // store state before bond creation
create_bonds.cpp:  // request a full neighbor list for use by this command
create_bonds.cpp:  // init entire system since comm->borders and neighbor->build is done
create_bonds.cpp:  // comm::init needs neighbor::init needs pair::init needs kspace::init, etc
create_bonds.cpp:  // error check on cutoff
create_bonds.cpp:  // if no pair style, neighbor list will be empty
create_bonds.cpp:  // require special_bonds 1-2 weights = 0.0 and KSpace = NULL
create_bonds.cpp:  // so that already bonded atom pairs do not appear in neighbor list
create_bonds.cpp:  // otherwise with newton_bond = 1,
create_bonds.cpp:  //   would be hard to check if I-J bond already existed
create_bonds.cpp:  // note that with KSpace, pair with weight = 0 could still be in neigh list
create_bonds.cpp:  // setup domain, communication and neighboring
create_bonds.cpp:  // acquire ghosts and build standard neighbor lists
create_bonds.cpp:  // build neighbor list this command needs based on earlier request
create_bonds.cpp:  // loop over all neighs of each atom
create_bonds.cpp:  // compute distance between two atoms consistently on both procs
create_bonds.cpp:  // add bond if group and distance criteria are met
create_bonds.cpp:  // check that bond list does not overflow
create_bonds.cpp:      // only consider bond creation if I,J distance between 2 cutoffs
create_bonds.cpp:      // compute rsq identically on both I,J loop iterations
create_bonds.cpp:      // if I,J tags equal, do not bond atom to itself
create_bonds.cpp:      // only consider bond creation if igroup and jgroup match I,J atoms
create_bonds.cpp:      // create bond, check for overflow
create_bonds.cpp:      // on I,J loop iterations, store with 1 or 2 atoms based on newton_bond
create_bonds.cpp:  // recount bonds
create_bonds.cpp:  if (!force->newton_bond) atom->nbonds /= 2;
create_bonds.cpp:  // print new bond count
create_bonds.cpp:  // re-trigger special list build
create_box.cpp:/* ----------------------------------------------------------------------
create_box.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
create_box.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
create_box.cpp:------------------------------------------------------------------------- */
create_box.cpp:/* ---------------------------------------------------------------------- */
create_box.cpp:/* ---------------------------------------------------------------------- */
create_box.cpp:  // region check
create_box.cpp:  // if region not prism:
create_box.cpp:  //   setup orthogonal domain
create_box.cpp:  //   set simulation domain from region extent
create_box.cpp:  // if region is prism:
create_box.cpp:  //   seutp triclinic domain
create_box.cpp:  //   set simulation domain params from prism params
create_box.cpp:  // if molecular, zero out topology info
create_box.cpp:  // set atom and topology type quantities
create_box.cpp:  // process optional args that can overwrite default settings
create_box.cpp:    if (strcmp(arg[iarg],"bond/types") == 0) {
create_box.cpp:    } else if (strcmp(arg[iarg],"angle/types") == 0) {
create_box.cpp:    } else if (strcmp(arg[iarg],"dihedral/types") == 0) {
create_box.cpp:    } else if (strcmp(arg[iarg],"improper/types") == 0) {
create_box.cpp:    } else if (strcmp(arg[iarg],"extra/bond/per/atom") == 0) {
create_box.cpp:    } else if (strcmp(arg[iarg],"extra/angle/per/atom") == 0) {
create_box.cpp:    } else if (strcmp(arg[iarg],"extra/dihedral/per/atom") == 0) {
create_box.cpp:    } else if (strcmp(arg[iarg],"extra/improper/per/atom") == 0) {
create_box.cpp:    } else if (strcmp(arg[iarg],"extra/special/per/atom") == 0) {
create_box.cpp:  // problem setup using info from header
create_box.cpp:  // deallocate/grow insures any extra settings are used for topology arrays
create_box.cpp:  // necessary in case no create_atoms is performed
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
delete_atoms.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:// allocate space for static class variable
delete_atoms.cpp:/* ---------------------------------------------------------------------- */
delete_atoms.cpp:/* ---------------------------------------------------------------------- */
delete_atoms.cpp:  // store state before delete
delete_atoms.cpp:  // flag atoms for deletion
delete_atoms.cpp:  // if allflag = 1, just reset atom->nlocal
delete_atoms.cpp:  // else delete atoms one by one
delete_atoms.cpp:    // optionally delete additional bonds or atoms in molecules
delete_atoms.cpp:    // delete local atoms flagged in dlist
delete_atoms.cpp:    // reset nlocal
delete_atoms.cpp:  // if non-molecular system and compress flag set,
delete_atoms.cpp:  // reset atom tags to be contiguous
delete_atoms.cpp:  // set all atom IDs to 0, call tag_extend()
delete_atoms.cpp:  // reset atom->natoms and also topology counts
delete_atoms.cpp:  // reset atom->map if it exists
delete_atoms.cpp:  // set nghost to 0 so old ghosts of deleted atoms won't be mapped
delete_atoms.cpp:  // print before and after atom and topology counts
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:  // check for special case of group = all
delete_atoms.cpp:  // allocate and initialize deletion list
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:  // allocate and initialize deletion list
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:  // read args
delete_atoms.cpp:  // request a full neighbor list for use by this command
delete_atoms.cpp:  // init entire system since comm->borders and neighbor->build is done
delete_atoms.cpp:  // comm::init needs neighbor::init needs pair::init needs kspace::init, etc
delete_atoms.cpp:  // error check on cutoff
delete_atoms.cpp:  // if no pair style, neighbor list will be empty
delete_atoms.cpp:  // setup domain, communication and neighboring
delete_atoms.cpp:  // acquire ghosts and build standard neighbor lists
delete_atoms.cpp:  // build neighbor list this command needs based on earlier request
delete_atoms.cpp:  // allocate and initialize deletion list
delete_atoms.cpp:  // must be after exchange potentially changes nlocal
delete_atoms.cpp:  // double loop over owned atoms and their full neighbor list
delete_atoms.cpp:  // at end of loop, there are no more overlaps
delete_atoms.cpp:  // only ever delete owned atom I in I loop iteration, never J even if owned
delete_atoms.cpp:      // if both weighting factors are 0, skip this pair
delete_atoms.cpp:      // could be 0 and still be in neigh list for long-range Coulombics
delete_atoms.cpp:      // want consistency with non-charged pairs which wouldn't be in list
delete_atoms.cpp:      // only consider deletion if I,J distance < cutoff
delete_atoms.cpp:      // compute rsq identically on both I,J loop iterations
delete_atoms.cpp:      // ignoring possibility that I,J tags are equal
delete_atoms.cpp:      // only consider deletion if I,J are in groups 1,2 respectively
delete_atoms.cpp:      // true whether J is owned or ghost atom
delete_atoms.cpp:      // J is owned atom:
delete_atoms.cpp:      //   delete atom I if atom J has not already been deleted
delete_atoms.cpp:      // J is ghost atom:
delete_atoms.cpp:      //   delete atom I if J,I is not a candidate deletion pair
delete_atoms.cpp:      //     due to being in groups 1,2 respectively
delete_atoms.cpp:      //   if they are candidate pair, then either:
delete_atoms.cpp:      //      another proc owns J and could delete J
delete_atoms.cpp:      //      J is a ghost of another of my owned atoms, and I could delete J
delete_atoms.cpp:      //   test on tags of I,J insures that only I or J is deleted
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:  // allocate and initialize deletion list
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:  // hash = for atom IDs being deleted by one processor
delete_atoms.cpp:  // list of these IDs is sent around ring
delete_atoms.cpp:  // at each stage of ring pass, hash is re-populated with received IDs
delete_atoms.cpp:  // list = set of unique molecule IDs from which I deleted atoms
delete_atoms.cpp:  // pass list to all other procs via comm->ring()
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:  // hash = unique molecule IDs from which I deleted atoms
delete_atoms.cpp:  // list = set of unique molecule IDs from which I deleted atoms
delete_atoms.cpp:  // pass list to all other procs via comm->ring()
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:    if (!force->newton_bond) atom->nbonds /= 2;
delete_atoms.cpp:    if (!force->newton_bond) atom->nangles /= 3;
delete_atoms.cpp:    if (!force->newton_bond) atom->ndihedrals /= 4;
delete_atoms.cpp:    if (!force->newton_bond) atom->nimpropers /= 4;
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:  // cbuf = list of N deleted atom IDs from other proc, put them in hash
delete_atoms.cpp:  // loop over my atoms and their bond topology lists
delete_atoms.cpp:  // if any atom in an interaction matches atom ID in hash, delete interaction
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_atoms.cpp:  // cbuf = list of N molecule IDs from other proc, put them in hash
delete_atoms.cpp:  // loop over my atoms, if matches molecule ID in hash, delete that atom
delete_atoms.cpp:/* ----------------------------------------------------------------------
delete_atoms.cpp:------------------------------------------------------------------------- */
delete_bonds.cpp:/* ----------------------------------------------------------------------
delete_bonds.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
delete_bonds.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
delete_bonds.cpp:------------------------------------------------------------------------- */
delete_bonds.cpp:/* ---------------------------------------------------------------------- */
delete_bonds.cpp:/* ---------------------------------------------------------------------- */
delete_bonds.cpp:  // init entire system since comm->borders is done
delete_bonds.cpp:  // comm::init needs neighbor::init needs pair::init needs kspace::init, etc
delete_bonds.cpp:  // identify group
delete_bonds.cpp:  // set style and which = type value
delete_bonds.cpp:  // setup list of types (atom,bond,etc) to consider
delete_bonds.cpp:  // use force->bounds(FLERR,) to allow setting of range of types
delete_bonds.cpp:  // range can be 0 to ntypes inclusive
delete_bonds.cpp:  // grab optional keywords
delete_bonds.cpp:  // border swap to insure type and mask is current for off-proc atoms
delete_bonds.cpp:  // enforce PBC before in case atoms are outside box
delete_bonds.cpp:  // set topology interactions either off or on
delete_bonds.cpp:  // criteria for an interaction to potentially be changed (set flag = 1)
delete_bonds.cpp:  //   all atoms or any atom in interaction must be in group, based on any_flag
delete_bonds.cpp:  //   for style = MULTI, all bond/angle/dihedral/improper, no other criteria
delete_bonds.cpp:  //   for style = ATOM, same as MULTI, plus at least one atom is specified type
delete_bonds.cpp:  //   for style = BOND/ANGLE/DIHEDRAL/IMPROPER, interaction is specified type
delete_bonds.cpp:  //   for style = STATS only compute stats, flag is always 0
delete_bonds.cpp:  // if flag = 1
delete_bonds.cpp:  //   set interaction type negative if undo_flag = 0
delete_bonds.cpp:  //   set interaction type positive if undo_flag = 1
delete_bonds.cpp:  // induce turn off of angles, dihedral, impropers due to turned off bonds
delete_bonds.cpp:  // induce turn off of dihedrals due to turned off angles
delete_bonds.cpp:  // all atoms or any atom in interaction must be in group, based on any_flag
delete_bonds.cpp:    // circulate list of turned off bonds around ring of procs
delete_bonds.cpp:    // circulate list of turned off angles around ring of procs
delete_bonds.cpp:  // remove interactions if requested
delete_bonds.cpp:  // all atoms or any atom in interaction must be in group, based on any_flag
delete_bonds.cpp:  // if interactions were removed, recompute global counts
delete_bonds.cpp:      if (force->newton_bond == 0) atom->nbonds /= 2;
delete_bonds.cpp:      if (force->newton_bond == 0) atom->nangles /= 3;
delete_bonds.cpp:      if (force->newton_bond == 0) atom->ndihedrals /= 4;
delete_bonds.cpp:      if (force->newton_bond == 0) atom->nimpropers /= 4;
delete_bonds.cpp:  // compute and print stats
delete_bonds.cpp:      bond_on /= 2;
delete_bonds.cpp:      bond_off /= 2;
delete_bonds.cpp:      angle_on /= 3;
delete_bonds.cpp:      angle_off /= 3;
delete_bonds.cpp:      dihedral_on /= 4;
delete_bonds.cpp:      dihedral_off /= 4;
delete_bonds.cpp:      improper_on /= 4;
delete_bonds.cpp:      improper_off /= 4;
delete_bonds.cpp:  // re-compute special list if requested
dihedral.cpp:/* ----------------------------------------------------------------------
dihedral.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dihedral.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dihedral.cpp:------------------------------------------------------------------------- */
dihedral.cpp:/* ----------------------------------------------------------------------
dihedral.cpp:------------------------------------------------------------------------- */
dihedral.cpp:/* ---------------------------------------------------------------------- */
dihedral.cpp:/* ----------------------------------------------------------------------
dihedral.cpp:------------------------------------------------------------------------- */
dihedral.cpp:/* ----------------------------------------------------------------------
dihedral.cpp:------------------------------------------------------------------------- */
dihedral.cpp:  eflag_atom = eflag / 2;
dihedral.cpp:  vflag_atom = vflag / 4;
dihedral.cpp:  // reallocate per-atom arrays if necessary
dihedral.cpp:  // zero accumulators
dihedral.cpp:/* ----------------------------------------------------------------------
dihedral.cpp:------------------------------------------------------------------------- */
dihedral.cpp:/* ---------------------------------------------------------------------- */
dihedral_hybrid.cpp:/* ----------------------------------------------------------------------
dihedral_hybrid.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dihedral_hybrid.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dihedral_hybrid.cpp:------------------------------------------------------------------------- */
dihedral_hybrid.cpp:/* ---------------------------------------------------------------------- */
dihedral_hybrid.cpp:/* ---------------------------------------------------------------------- */
dihedral_hybrid.cpp:/* ---------------------------------------------------------------------- */
dihedral_hybrid.cpp:  // save ptrs to original dihedrallist
dihedral_hybrid.cpp:  // if this is re-neighbor step, create sub-style dihedrallists
dihedral_hybrid.cpp:  // ndihedrallist[] = length of each sub-style list
dihedral_hybrid.cpp:  // realloc sub-style dihedrallist if necessary
dihedral_hybrid.cpp:  // load sub-style dihedrallist with 5 values from original dihedrallist
dihedral_hybrid.cpp:  // call each sub-style's compute function
dihedral_hybrid.cpp:  // set neighbor->dihedrallist to sub-style dihedrallist before call
dihedral_hybrid.cpp:  // accumulate sub-style global/peratom energy/virial in hybrid
dihedral_hybrid.cpp:  // restore ptrs to original dihedrallist
dihedral_hybrid.cpp:/* ---------------------------------------------------------------------- */
dihedral_hybrid.cpp:/* ----------------------------------------------------------------------
dihedral_hybrid.cpp:------------------------------------------------------------------------- */
dihedral_hybrid.cpp:  // delete old lists, since cannot just change settings
dihedral_hybrid.cpp:  // count sub-styles by skipping numeric args
dihedral_hybrid.cpp:  // one exception is 1st arg of style "table", which is non-numeric word
dihedral_hybrid.cpp:  // need a better way to skip these exceptions
dihedral_hybrid.cpp:  // allocate list of sub-styles
dihedral_hybrid.cpp:  // allocate each sub-style and call its settings() with subset of args
dihedral_hybrid.cpp:  // allocate uses suffix, but don't store suffix version in keywords,
dihedral_hybrid.cpp:  //   else syntax in coeff() will not match
dihedral_hybrid.cpp:  // define subset of args for a sub-style by skipping numeric args
dihedral_hybrid.cpp:  // one exception is 1st arg of style "table", which is non-numeric
dihedral_hybrid.cpp:  // need a better way to skip these exceptions
dihedral_hybrid.cpp:/* ----------------------------------------------------------------------
dihedral_hybrid.cpp:---------------------------------------------------------------------- */
dihedral_hybrid.cpp:  // 2nd arg = dihedral sub-style name
dihedral_hybrid.cpp:  // allow for "none" or "skip" as valid sub-style name
dihedral_hybrid.cpp:  // move 1st arg to 2nd arg
dihedral_hybrid.cpp:  // just copy ptrs, since arg[] points into original input line
dihedral_hybrid.cpp:  // invoke sub-style coeff() starting with 1st arg
dihedral_hybrid.cpp:  // set setflag and which type maps to which sub-style
dihedral_hybrid.cpp:  // if sub-style is skip: auxiliary class2 setting in data file so ignore
dihedral_hybrid.cpp:  // if sub-style is none and not skip: set hybrid setflag, wipe out map
dihedral_hybrid.cpp:/* ---------------------------------------------------------------------- */
dihedral_hybrid.cpp:/* ----------------------------------------------------------------------
dihedral_hybrid.cpp:------------------------------------------------------------------------- */
dihedral_hybrid.cpp:/* ----------------------------------------------------------------------
dihedral_hybrid.cpp:------------------------------------------------------------------------- */
dihedral_hybrid.cpp:/* ----------------------------------------------------------------------
dihedral_hybrid.cpp:------------------------------------------------------------------------- */
dihedral_zero.cpp:/* ----------------------------------------------------------------------
dihedral_zero.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dihedral_zero.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dihedral_zero.cpp:------------------------------------------------------------------------- */
dihedral_zero.cpp:/* ----------------------------------------------------------------------
dihedral_zero.cpp:------------------------------------------------------------------------- */
dihedral_zero.cpp:/* ---------------------------------------------------------------------- */
dihedral_zero.cpp:/* ---------------------------------------------------------------------- */
dihedral_zero.cpp:/* ---------------------------------------------------------------------- */
dihedral_zero.cpp:/* ---------------------------------------------------------------------- */
dihedral_zero.cpp:/* ---------------------------------------------------------------------- */
dihedral_zero.cpp:/* ----------------------------------------------------------------------
dihedral_zero.cpp:------------------------------------------------------------------------- */
dihedral_zero.cpp:/* ----------------------------------------------------------------------
dihedral_zero.cpp:------------------------------------------------------------------------- */
dihedral_zero.cpp:/* ----------------------------------------------------------------------
dihedral_zero.cpp:------------------------------------------------------------------------- */
dihedral_zero.cpp:/* ----------------------------------------------------------------------
dihedral_zero.cpp:------------------------------------------------------------------------- */
displace_atoms.cpp:/* ----------------------------------------------------------------------
displace_atoms.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
displace_atoms.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
displace_atoms.cpp:------------------------------------------------------------------------- */
displace_atoms.cpp:/* ---------------------------------------------------------------------- */
displace_atoms.cpp:/* ---------------------------------------------------------------------- */
displace_atoms.cpp:/* ---------------------------------------------------------------------- */
displace_atoms.cpp:  // group and style
displace_atoms.cpp:  // set option defaults
displace_atoms.cpp:  // read options from end of input line
displace_atoms.cpp:  // setup scaling
displace_atoms.cpp:  // move atoms by 3-vector or specified variable(s)
displace_atoms.cpp:  // move atoms in ramped fashion
displace_atoms.cpp:        fraction = (x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
displace_atoms.cpp:  // move atoms randomly
displace_atoms.cpp:  // makes atom result independent of what proc owns it via random->reset()
displace_atoms.cpp:  // rotate atoms by right-hand rule by theta around R
displace_atoms.cpp:  // P = point = vector = point of rotation
displace_atoms.cpp:  // R = vector = axis of rotation
displace_atoms.cpp:  // R0 = runit = unit vector for R
displace_atoms.cpp:  // D = X - P = vector from P to X
displace_atoms.cpp:  // C = (D dot R0) R0 = projection of atom coord onto R line
displace_atoms.cpp:  // A = D - C = vector from R line to X
displace_atoms.cpp:  // B = R0 cross A = vector perp to A in plane of rotation
displace_atoms.cpp:  // A,B define plane of circular rotation around R line
displace_atoms.cpp:  // X = P + C + A cos(theta) + B sin(theta)
displace_atoms.cpp:    runit[0] = axis[0]/len;
displace_atoms.cpp:    runit[1] = axis[1]/len;
displace_atoms.cpp:    runit[2] = axis[2]/len;
displace_atoms.cpp:    double angle = MY_PI*theta/180.0;
displace_atoms.cpp:    // flags for additional orientation info stored by some atom styles
displace_atoms.cpp:    // AtomVec pointers to retrieve per-atom storage of extra quantities
displace_atoms.cpp:        // theta for lines
displace_atoms.cpp:        // quats for ellipsoids, tris, and bodies
displace_atoms.cpp:  // move atoms back inside simulation box and to new processors
displace_atoms.cpp:  // use remap() instead of pbc() in case atoms moved a long distance
displace_atoms.cpp:  // use irregular() in case atoms moved a long distance
displace_atoms.cpp:  // check if any atoms were lost
displace_atoms.cpp:/* ----------------------------------------------------------------------
displace_atoms.cpp:------------------------------------------------------------------------- */
displace_atoms.cpp:/* ----------------------------------------------------------------------
displace_atoms.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
domain.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:enum{NO_REMAP,X_REMAP,V_REMAP};    // same as fix_deform.cpp
domain.cpp:enum{IGNORE,WARN,ERROR};           // same as thermo.cpp
domain.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ---------------------------------------------------------------------- */
domain.cpp:/* ---------------------------------------------------------------------- */
domain.cpp:  // set box_change flags if box size/shape/sub-domains ever change
domain.cpp:  // due to shrink-wrapping or fixes that change box size/shape/sub-domains
domain.cpp:  // check for fix deform
domain.cpp:  // region inits
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   assumes boxlo/hi and triclinic tilts are already set
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  // error checks for orthogonal and triclinic domains
domain.cpp:  // error check or warning on triclinic tilt factors
domain.cpp:    if ((fabs(xy/(boxhi[0]-boxlo[0])) > 0.5 && xperiodic) ||
domain.cpp:        (fabs(xz/(boxhi[0]-boxlo[0])) > 0.5 && xperiodic) ||
domain.cpp:        (fabs(yz/(boxhi[1]-boxlo[1])) > 0.5 && yperiodic)) {
domain.cpp:  // set small based on box size and SMALL
domain.cpp:  // this works for any unit system
domain.cpp:  // if expandflag, adjust box lo/hi for shrink-wrapped dims
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   assumes boxlo/hi and triclinic tilts are already set
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  h_inv[0] = 1.0/h[0];
domain.cpp:  h_inv[1] = 1.0/h[1];
domain.cpp:  h_inv[2] = 1.0/h[2];
domain.cpp:    h_inv[3] = -h[3] / (h[1]*h[2]);
domain.cpp:    h_inv[4] = (h[3]*h[5] - h[1]*h[4]) / (h[0]*h[1]*h[2]);
domain.cpp:    h_inv[5] = -h[5] / (h[0]*h[1]);
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   if shrink-wrapped, determine atom extent and reset boxlo/hi
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  // perform shrink-wrapping
domain.cpp:  // compute extent of atoms on this proc
domain.cpp:  // for triclinic, this is done in lamda space
domain.cpp:    // compute extent across all procs
domain.cpp:    // flip sign of MIN to do it in one Allreduce MAX
domain.cpp:    // for triclinic, convert back to box coords before changing box
domain.cpp:    // in shrink-wrapped dims, set box by atom extent
domain.cpp:    // if minimum set, enforce min box size settings
domain.cpp:    // for triclinic, convert lamda extent to box coords, then set box lo/hi
domain.cpp:    // decided NOT to do the next comment - don't want to sneakily change tilt
domain.cpp:    // for triclinic, adjust tilt factors if 2nd dim is shrink-wrapped,
domain.cpp:    //   so that displacement in 1st dim stays the same
domain.cpp:        //xy *= (boxhi[1]-boxlo[1]) / yprd;
domain.cpp:        //xz *= (boxhi[2]-boxlo[2]) / xprd;
domain.cpp:        //yz *= (boxhi[2]-boxlo[2]) / yprd;
domain.cpp:  // reset box whether shrink-wrapping or not
domain.cpp:  // if shrink-wrapped & kspace is defined (i.e. using MSM), call setup()
domain.cpp:  // also call init() (to test for compatibility) ?
domain.cpp:    //force->kspace->init();
domain.cpp:  // if shrink-wrapped & triclinic, re-convert to lamda coords for new box
domain.cpp:  // re-invoke pbc() b/c x2lamda result can be outside [0,1] due to roundoff
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   increment/decrement in wrap-around fashion
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  // verify owned atoms have valid numerical coords
domain.cpp:  // may not if computed pairwise force between 2 atoms at same location
domain.cpp:  coord = &x[0][0];  // note: x is always initialized to at least one element.
domain.cpp:  // setup for PBC checks
domain.cpp:  // apply PBC to each owned atom
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  // only need to check if system is molecular and some dimension is periodic
domain.cpp:  // if running verlet/split, don't check on KSpace partition since
domain.cpp:  //    it has no ghost atoms and thus bond partners won't exist
domain.cpp:  if (strncmp(update->integrate_style,"verlet/split",12) == 0 &&
domain.cpp:  // communicate unwrapped position of owned atoms to ghost atoms
domain.cpp:  // compute unwrapped extent of each bond
domain.cpp:  // flag if any bond component is longer than 1/2 of periodic box length
domain.cpp:  // flag if any bond component is longer than non-periodic box length
domain.cpp:  //   which means image flags in that dimension were different
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  // only need to check if system is molecular and some dimension is periodic
domain.cpp:  // if running verlet/split, don't check on KSpace partition since
domain.cpp:  //    it has no ghost atoms and thus bond partners won't exist
domain.cpp:  if (strncmp(update->integrate_style,"verlet/split",12) == 0 &&
domain.cpp:  // maxbondall = longest current bond length
domain.cpp:  // if periodic box dim is tiny (less than 2 * bond-length),
domain.cpp:  //   minimum_image() itself may compute bad bond lengths
domain.cpp:  // in this case, image_check() should warn,
domain.cpp:  //   assuming 2 atoms have consistent image flags
domain.cpp:  // maxdelta = furthest apart 2 atoms in a bonded interaction can be
domain.cpp:  // include BONDSTRETCH factor to account for dynamics
domain.cpp:  // warn if maxdelta > than half any periodic box length
domain.cpp:  // since atoms in the interaction could rotate into that dimension
domain.cpp:                   "Bond/angle/dihedral extent > half of periodic box length");
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   use 1/2 of box size as test
domain.cpp:   for triclinic, also add/subtract tilt factors in other dims as needed
domain.cpp:     b/c while could iterate forever
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   use 1/2 of box size as test
domain.cpp:   for triclinic, also add/subtract tilt factors in other dims as needed
domain.cpp:     b/c while could iterate forever
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   use 1/2 of box size as test
domain.cpp:   for triclinic, also add/subtract tilt factors in other dims as needed
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   for triclinic, add/subtract tilt factors in other dims as needed
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   increment/decrement in wrap-around fashion
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  // iterative form
domain.cpp:  // if (xperiodic) {
domain.cpp:  //   while (coordnew[0]-coordold[0] > half[0]) coordnew[0] -= period[0];
domain.cpp:  //   while (coordold[0]-coordnew[0] > half[0]) coordnew[0] += period[0];
domain.cpp:  // }
domain.cpp:      n = static_cast<int> ((coordnew[0]-coordold[0])/period[0]);
domain.cpp:      n = static_cast<int> ((coordold[0]-coordnew[0])/period[0]);
domain.cpp:      n = static_cast<int> ((coordnew[1]-coordold[1])/period[1]);
domain.cpp:      n = static_cast<int> ((coordold[1]-coordnew[1])/period[1]);
domain.cpp:      n = static_cast<int> ((coordnew[2]-coordold[2])/period[2]);
domain.cpp:      n = static_cast<int> ((coordold[2]-coordnew[2])/period[2]);
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:     C' = C + pB + nA    (C shifted by B and/or A)
domain.cpp:   so that x_unwrap for each atom is same before/after
domain.cpp:   this is b/c the xy flip dramatically changes which tiled image of
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  // box and subbox bounds for orthogonal vs triclinic
domain.cpp:  // check if atom did not return 1 only b/c it was 
domain.cpp:  //   outside a shrink-wrapped boundary
domain.cpp:    // newcoord = coords pushed back to be on shrink-wrapped boundary
domain.cpp:    // newcoord is a copy, so caller's x[] is not affected
domain.cpp:    // re-test for newcoord inside my sub-domain
domain.cpp:    // use <= test for upper-boundary since may have just put atom at boxhi
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:  // extend Region list if necessary
domain.cpp:  // create the Region
domain.cpp:      sprintf(estyle,"%s/%s",arg[1],lmp->suffix);
domain.cpp:      sprintf(estyle,"%s/%s",arg[1],lmp->suffix2);
domain.cpp:  // initialize any region variables via init()
domain.cpp:  // in case region is used between runs, e.g. to print a variable
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   convert 8 lamda corner pts of lo/hi box to box coords
domain.cpp:   return bboxlo/hi = bounding box around 8 corner pts in box coords
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:------------------------------------------------------------------------- */
domain.cpp:/* ----------------------------------------------------------------------
domain.cpp:   compute 8 corner pts of any triclinic box with lo/hi in lamda coords
domain.cpp:------------------------------------------------------------------------- */
dump_atom.cpp:/* ----------------------------------------------------------------------
dump_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump_atom.cpp:------------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:  // format = copy of default or user-specified line format
dump_atom.cpp:  // default depends on image flags
dump_atom.cpp:  // setup boundary string
dump_atom.cpp:  // setup column string
dump_atom.cpp:  // setup function ptrs
dump_atom.cpp:  // open single file, one time only
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:  double invxprd = 1.0/domain->xprd;
dump_atom.cpp:  double invyprd = 1.0/domain->yprd;
dump_atom.cpp:  double invzprd = 1.0/domain->zprd;
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:  double invxprd = 1.0/domain->xprd;
dump_atom.cpp:  double invyprd = 1.0/domain->yprd;
dump_atom.cpp:  double invzprd = 1.0/domain->zprd;
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ----------------------------------------------------------------------
dump_atom.cpp:------------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_atom.cpp:/* ---------------------------------------------------------------------- */
dump_cfg.cpp:/* ----------------------------------------------------------------------
dump_cfg.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump_cfg.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump_cfg.cpp:------------------------------------------------------------------------- */
dump_cfg.cpp:/* ----------------------------------------------------------------------
dump_cfg.cpp:------------------------------------------------------------------------- */
dump_cfg.cpp:enum{INT,DOUBLE,STRING,BIGINT};   // same as in DumpCustom
dump_cfg.cpp:/* ---------------------------------------------------------------------- */
dump_cfg.cpp:  // use earg instead of original arg since it includes expanded wildcards
dump_cfg.cpp:  // earg was created by parent DumpCustom
dump_cfg.cpp:  // setup auxiliary property name strings
dump_cfg.cpp:  // convert 'X_ID[m]' (X=c,f,v) to 'X_ID_m'
dump_cfg.cpp:/* ---------------------------------------------------------------------- */
dump_cfg.cpp:/* ---------------------------------------------------------------------- */
dump_cfg.cpp:  // setup function ptrs
dump_cfg.cpp:/* ---------------------------------------------------------------------- */
dump_cfg.cpp:  // set scale factor used by AtomEye for CFG viz
dump_cfg.cpp:  // default = 1.0
dump_cfg.cpp:  // for peridynamics, set to pre-computed PD scale factor
dump_cfg.cpp:  //   so PD particles mimic C atoms
dump_cfg.cpp:  // for unwrapped coords, set to UNWRAPEXPAND (10.0)
dump_cfg.cpp:  //   so molecules are not split across periodic box boundaries
dump_cfg.cpp:/* ----------------------------------------------------------------------
dump_cfg.cpp:------------------------------------------------------------------------- */
dump_cfg.cpp:          unwrap_coord = (mybuf[m] - 0.5)/UNWRAPEXPAND + 0.5;
dump_cfg.cpp:/* ---------------------------------------------------------------------- */
dump_cfg.cpp:/* ---------------------------------------------------------------------- */
dump_cfg.cpp:/* ---------------------------------------------------------------------- */
dump_cfg.cpp:          unwrap_coord = (mybuf[m] - 0.5)/UNWRAPEXPAND + 0.5;
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump.cpp:------------------------------------------------------------------------- */
dump.cpp:// allocate space for static class variable
dump.cpp:/* ---------------------------------------------------------------------- */
dump.cpp:  // parse filename for special syntax
dump.cpp:  // if contains '%', write one file per proc and replace % with proc-ID
dump.cpp:  // if contains '*', write one file per timestep and replace * with timestep
dump.cpp:  // check file suffixes
dump.cpp:  //   if ends in .bin = binary file
dump.cpp:  //   else if ends in .gz = gzipped text file
dump.cpp:  //   else ASCII text file
dump.cpp:/* ---------------------------------------------------------------------- */
dump.cpp:  // format_column_user is deallocated by child classes that use it
dump.cpp:  // XTC style sets fp to NULL since it closes file in its destructor
dump.cpp:/* ---------------------------------------------------------------------- */
dump.cpp:    // set reorderflag = 1 if can simply reorder local atoms rather than sort
dump.cpp:    // criteria: sorting by ID, atom IDs are consecutive from 1 to Natoms
dump.cpp:    //           min/max IDs of group match size of group
dump.cpp:    // compute ntotal_reorder, nme_reorder, idlo/idhi to test against later
dump.cpp:        idlo = static_cast<tagint> (range*me/nprocs + minall);
dump.cpp:        tagint idhi = static_cast<tagint> (range*(me+1)/nprocs + minall);
dump.cpp:        tagint lom1 = static_cast<tagint> ((idlo-1-minall)/range * nprocs);
dump.cpp:        tagint lo = static_cast<tagint> ((idlo-minall)/range * nprocs);
dump.cpp:        tagint him1 = static_cast<tagint> ((idhi-1-minall)/range * nprocs);
dump.cpp:        tagint hi = static_cast<tagint> ((idhi-minall)/range * nprocs);
dump.cpp:  // preallocation for PBC copies if requested
dump.cpp:/* ---------------------------------------------------------------------- */
dump.cpp:/* ---------------------------------------------------------------------- */
dump.cpp:  // if file per timestep, open new file
dump.cpp:  // simulation box bounds
dump.cpp:  // nme = # of dump lines this proc contributes to dump
dump.cpp:  // ntotal = total # of dump lines in snapshot
dump.cpp:  // nmax = max # of dump lines on any proc
dump.cpp:  // write timestep header
dump.cpp:  // for multiproc,
dump.cpp:  //   nheader = # of lines in this file via Allreduce on clustercomm
dump.cpp:  // insure buf is sized for packing and communicating
dump.cpp:  // use nmax to insure filewriter proc can receive info from others
dump.cpp:  // limit nmax*size_one to int since used as arg in MPI calls
dump.cpp:  // insure ids buffer is sized for sorting
dump.cpp:  // apply PBC on copy of x,v,image if requested
dump.cpp:  // pack my data into buf
dump.cpp:  // if sorting on IDs also request ID list from pack()
dump.cpp:  // sort buf as needed
dump.cpp:  // if buffering, convert doubles into strings
dump.cpp:  // insure sbuf is sized for communicating
dump.cpp:  // cannot buffer if output is to binary file
dump.cpp:  // filewriter = 1 = this proc writes to file
dump.cpp:  // ping each proc in my cluster, receive its data, write data to file
dump.cpp:  // else wait for ping from fileproc, send my data to fileproc
dump.cpp:  // comm and output buf of doubles
dump.cpp:          nlines /= size_one;
dump.cpp:  // comm and output sbuf = one big string of formatted values per proc
dump.cpp:  // restore original x,v,image unaltered by PBC
dump.cpp:  // if file per timestep, close file if I am filewriter
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:------------------------------------------------------------------------- */
dump.cpp:  // single file, already opened, so just return
dump.cpp:  // if one file per timestep, replace '*' with current timestep
dump.cpp:  // each proc with filewriter = 1 opens a file
dump.cpp:  // delete string with timestep replaced
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:------------------------------------------------------------------------- */
dump.cpp:  // if single proc, swap ptrs to buf,ids <-> bufsort,idsort
dump.cpp:  // if multiple procs, exchange datums between procs via irregular
dump.cpp:    // grow proclist if necessary
dump.cpp:    // proclist[i] = which proc Ith datum will be sent to
dump.cpp:      // use 0.5 instead of EPSILON since atom IDs are integers
dump.cpp:      // if use EPSILON, it can be lost if 64-bit maxall-minall is too big
dump.cpp:      // then iproc == nprocs for largest ID, causing irregular to crash
dump.cpp:        iproc = static_cast<int> ((ids[i]-minall)/range * nprocs);
dump.cpp:      // proc assignment is inverted if sortorder = DESCEND
dump.cpp:        iproc = static_cast<int> ((value-minall)/range * nprocs);
dump.cpp:    // create comm plan, grow recv bufs if necessary,
dump.cpp:    // exchange datums, destroy plan
dump.cpp:    // if sorting on atom IDs, exchange IDs also
dump.cpp:  // if reorder flag is set & total/per-proc counts match pre-computed values,
dump.cpp:  // then create index directly from idsort
dump.cpp:  // else quicksort of index using IDs or buf column as comparator
dump.cpp:  // reset buf size and maxbuf to largest of any post-sort nme values
dump.cpp:  // this insures proc 0 can receive everyone's info
dump.cpp:  // copy data from bufsort to buf using index
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:------------------------------------------------------------------------- */
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:------------------------------------------------------------------------- */
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:------------------------------------------------------------------------- */
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:------------------------------------------------------------------------- */
dump.cpp:      multiproc = nprocs/nper;
dump.cpp:      fileproc = me/nper * nper;
dump.cpp:      int icluster = fileproc/nper;
dump.cpp:        // pass format none to child classes which may use it
dump.cpp:        // not an error if they don't
dump.cpp:      } else {   // pass other format options to child classes
dump.cpp:      int icluster = static_cast<int> ((bigint) me * nfile/nprocs);
dump.cpp:      fileproc = static_cast<int> ((bigint) icluster * nprocs/nfile);
dump.cpp:      int fcluster = static_cast<int> ((bigint) fileproc * nfile/nprocs);
dump.cpp:        static_cast<int> ((bigint) (icluster+1) * nprocs/nfile);
dump.cpp:      fcluster = static_cast<int> ((bigint) fileprocnext * nfile/nprocs);
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:------------------------------------------------------------------------- */
dump.cpp:/* ----------------------------------------------------------------------
dump.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump_custom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:// customize by adding keyword
dump_custom.cpp:// also customize compute_atom_property.cpp
dump_custom.cpp:enum{INT,DOUBLE,STRING,BIGINT};    // same as in DumpCFG
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  // expand args if any have wildcard character "*"
dump_custom.cpp:  // ok to include trailing optional args,
dump_custom.cpp:  //   so long as they do not have "*" between square brackets
dump_custom.cpp:  // nfield may be shrunk below if extra optional args exist
dump_custom.cpp:  // allocate field vectors
dump_custom.cpp:  // computes, fixes, variables which the dump accesses
dump_custom.cpp:  // process attributes
dump_custom.cpp:  // ioptional = start of additional optional args in expanded args
dump_custom.cpp:  // noptional = # of optional args
dump_custom.cpp:  // reset nfield to subtract off optional args
dump_custom.cpp:  // reset ioptional to what it would be in original arg list
dump_custom.cpp:  // only dump image and dump movie styles process optional args,
dump_custom.cpp:  //   they do not use expanded earg list
dump_custom.cpp:  // atom selection arrays
dump_custom.cpp:  // default element name for all types = C
dump_custom.cpp:  // setup format strings
dump_custom.cpp:  // setup column string
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  // if wildcard expansion occurred, free earg memory from expand_args()
dump_custom.cpp:  // could not do in constructor, b/c some derived classes process earg
dump_custom.cpp:  // check nfix in case all fixes have already been deleted
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  // format = copy of default or user-specified line format
dump_custom.cpp:  // tokenize the format string and add space at end of each format element
dump_custom.cpp:  // if user-specified int/float format exists, use it instead
dump_custom.cpp:  // if user-specified column format exists, use it instead
dump_custom.cpp:  // lo priority = line, medium priority = int/float, hi priority = column
dump_custom.cpp:  // setup boundary string
dump_custom.cpp:  // setup function ptrs
dump_custom.cpp:  // find current ptr for each compute,fix,variable
dump_custom.cpp:  // check that fix frequency is acceptable
dump_custom.cpp:  // set index and check validity of region
dump_custom.cpp:  // open single file, one time only
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  // grow choose and variable vbuf arrays if needed
dump_custom.cpp:  // invoke Computes for per-atom quantities
dump_custom.cpp:  // only if within a run or minimize
dump_custom.cpp:  // else require that computes are current
dump_custom.cpp:  // this prevents a compute from being invoked by the WriteDump class
dump_custom.cpp:  // evaluate atom-style Variables for per-atom quantities
dump_custom.cpp:  // choose all local atoms for output
dump_custom.cpp:  // un-choose if not in group
dump_custom.cpp:  // un-choose if not in region
dump_custom.cpp:  // un-choose if any threshold criterion isn't met
dump_custom.cpp:      // customize by adding to if statement
dump_custom.cpp:        double invxprd = 1.0/domain->xprd;
dump_custom.cpp:        double invyprd = 1.0/domain->yprd;
dump_custom.cpp:        double invzprd = 1.0/domain->zprd;
dump_custom.cpp:        double invxprd = 1.0/domain->xprd;
dump_custom.cpp:        double invyprd = 1.0/domain->yprd;
dump_custom.cpp:        double invzprd = 1.0/domain->zprd;
dump_custom.cpp:      } else if (thresh_array[ithresh] == MUMAG) {//Magnetic properties
dump_custom.cpp:      // unselect atoms that don't meet threshold criterion
dump_custom.cpp:      // compare to single value or values stored in threshfix
dump_custom.cpp:      // copy ptr attribute into thresh_fix if this is first comparison
dump_custom.cpp:      // update values stored in threshfix
dump_custom.cpp:  // compress choose flags into clist
dump_custom.cpp:  // nchoose = # of selected atoms
dump_custom.cpp:  // clist[i] = local index of each selected atom
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  // customize by adding to if statement
dump_custom.cpp:    } else if (strcmp(arg[iarg],"mumag") == 0) {//Magnetic properties
dump_custom.cpp:    // compute value = c_ID
dump_custom.cpp:    // if no trailing [], then arg is set to 0, else arg is int between []
dump_custom.cpp:    // fix value = f_ID
dump_custom.cpp:    // if no trailing [], then arg is set to 0, else arg is between []
dump_custom.cpp:    // variable value = v_name
dump_custom.cpp:    // custom per-atom floating point value = d_ID
dump_custom.cpp:    // custom per-atom integer value = i_ID
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:      // just clear format_column_user allocated by this dump child class
dump_custom.cpp:      // replace "d" in format_int_user with bigint format specifier
dump_custom.cpp:      // use of &str[1] removes leading '%' from BIGINT_FORMAT string
dump_custom.cpp:    // grow threshold arrays
dump_custom.cpp:    // set attribute type of threshold
dump_custom.cpp:    // customize by adding to if statement
dump_custom.cpp:    //Magnetic quantities
dump_custom.cpp:    // compute value = c_ID
dump_custom.cpp:    // if no trailing [], then arg is set to 0, else arg is between []
dump_custom.cpp:    // must grow field2index and argindex arrays, since access is beyond nfield
dump_custom.cpp:    // fix value = f_ID
dump_custom.cpp:    // if no trailing [], then arg is set to 0, else arg is between []
dump_custom.cpp:    // must grow field2index and argindex arrays, since access is beyond nfield
dump_custom.cpp:    // variable value = v_ID
dump_custom.cpp:    // must grow field2index and argindex arrays, since access is beyond nfield
dump_custom.cpp:    // custom per atom floating point value = d_ID
dump_custom.cpp:    // must grow field2index and argindex arrays, since access is beyond nfield
dump_custom.cpp:    // custom per atom integer value = i_ID
dump_custom.cpp:    // must grow field2index and argindex arrays, since access is beyond nfield
dump_custom.cpp:    // set operation type of threshold
dump_custom.cpp:    // set threshold value as number or special LAST keyword
dump_custom.cpp:    // create FixStore to hold LAST values, should work with restart
dump_custom.cpp:    // id = dump-ID + nthreshlast + DUMP_STORE, fix group = dump group
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  if (flag_custom[index] == 0) { // integer
dump_custom.cpp:  } else if (flag_custom[index] == 1) { // double
dump_custom.cpp:/* ----------------------------------------------------------------------
dump_custom.cpp:------------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  double invxprd = 1.0/domain->xprd;
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  double invyprd = 1.0/domain->yprd;
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  double invzprd = 1.0/domain->zprd;
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  double invxprd = 1.0/domain->xprd;
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  double invyprd = 1.0/domain->yprd;
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:  double invzprd = 1.0/domain->zprd;
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp://Magnetic quantities
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_custom.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:/* ----------------------------------------------------------------------
dump_dcd.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump_dcd.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump_dcd.cpp:------------------------------------------------------------------------- */
dump_dcd.cpp:/* ----------------------------------------------------------------------
dump_dcd.cpp:------------------------------------------------------------------------- */
dump_dcd.cpp:// necessary to set SEEK params b/c MPI-2 messes with these settings
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:  // allocate global array for atom coords
dump_dcd.cpp:  if (n > static_cast<bigint>(MAXSMALLINT/3/sizeof(float)))
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:  // check that dump frequency has not changed and is not a variable
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:  // first time, write header for entire file
dump_dcd.cpp:  // dim[] = size and angle cosines of orthogonal or triclinic box
dump_dcd.cpp:  // dim[0] = a = length of unit cell vector along x-axis
dump_dcd.cpp:  // dim[1] = gamma = cosine of angle between a and b
dump_dcd.cpp:  // dim[2] = b = length of unit cell vector in xy-plane
dump_dcd.cpp:  // dim[3] = beta = cosine of angle between a and c
dump_dcd.cpp:  // dim[4] = alpha = cosine of angle between b and c
dump_dcd.cpp:  // dim[5] = c = length of final unit cell vector
dump_dcd.cpp:  // 48 = 6 doubles
dump_dcd.cpp:    dim[4] = (h[5]*h[4] + h[1]*h[3]) / blen/clen; // alpha
dump_dcd.cpp:    dim[3] = (h[0]*h[4]) / alen/clen;             // beta
dump_dcd.cpp:    dim[1] = (h[0]*h[5]) / alen/blen;             // gamma
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:  // copy buf atom coords into 3 global arrays
dump_dcd.cpp:  // if last chunk of atoms in this snapshot, write global arrays to file
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:/* ----------------------------------------------------------------------
dump_dcd.cpp:------------------------------------------------------------------------- */
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:  // write coords
dump_dcd.cpp:  // update NFILE and NSTEP fields in DCD header
dump_dcd.cpp:/* ---------------------------------------------------------------------- */
dump_dcd.cpp:  fwrite_int32(fp,0);                    // NFILE = # of snapshots in file
dump_dcd.cpp:  fwrite_int32(fp,ntimestep);            // START = timestep of first snapshot
dump_dcd.cpp:  fwrite_int32(fp,nevery_save);          // SKIP = interval between snapshots
dump_dcd.cpp:  fwrite_int32(fp,ntimestep);            // NSTEP = timestep of last snapshot
dump_dcd.cpp:  fwrite_int32(fp,0);                         // NAMD writes NSTEP or ISTART
dump_dcd.cpp:  fwrite_int32(fp,24);                   // pretend to be Charmm version 24
dump_dcd.cpp:  fwrite_int32(fp,natoms);                // number of atoms in each snapshot
dump_image.cpp:/* ----------------------------------------------------------------------
dump_image.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump_image.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump_image.cpp:------------------------------------------------------------------------- */
dump_image.cpp:enum{SPHERE,LINE,TRI};           // also in some Body and Fix child classes
dump_image.cpp:/* ---------------------------------------------------------------------- */
dump_image.cpp:  // force binary flag on to avoid corrupted output on Windows
dump_image.cpp:  // set filetype based on filename suffix
dump_image.cpp:  // atom color,diameter settings
dump_image.cpp:  // create Image class with single colormap for atoms
dump_image.cpp:  // change defaults for 2d
dump_image.cpp:  // set defaults for optional args
dump_image.cpp:  // parse optional args
dump_image.cpp:        theta *= MY_PI/180.0;
dump_image.cpp:        phi *= MY_PI/180.0;
dump_image.cpp:  // error checks and setup for lineflag, triflag, bodyflag, fixflag
dump_image.cpp:  // allocate image buffer now that image size is known
dump_image.cpp:  // communication neede for bonds colored by atoms
dump_image.cpp:  // additional defaults for dump_modify options
dump_image.cpp:  // viewflag = DYNAMIC if any view parameter is dynamic
dump_image.cpp:  // local data
dump_image.cpp:/* ---------------------------------------------------------------------- */
dump_image.cpp:/* ---------------------------------------------------------------------- */
dump_image.cpp:  // check variables
dump_image.cpp:  // set up type -> element mapping
dump_image.cpp:/* ---------------------------------------------------------------------- */
dump_image.cpp:  // open new file
dump_image.cpp:  // reset box center and view parameters if dynamic
dump_image.cpp:  // nme = # of atoms this proc will contribute to dump
dump_image.cpp:  // pack buf with color & diameter
dump_image.cpp:  // set minmax color range if using dynamic atom color map
dump_image.cpp:    if (flag) error->all(FLERR,"Invalid color map min/max values");
dump_image.cpp:  // create image on each proc, then merge them
dump_image.cpp:  // write image file
dump_image.cpp:/* ----------------------------------------------------------------------
dump_image.cpp:------------------------------------------------------------------------- */
dump_image.cpp:/* ----------------------------------------------------------------------
dump_image.cpp:------------------------------------------------------------------------- */
dump_image.cpp:/* ----------------------------------------------------------------------
dump_image.cpp:------------------------------------------------------------------------- */
dump_image.cpp:  // view direction theta and phi
dump_image.cpp:    theta *= MY_PI/180.0;
dump_image.cpp:    phi *= MY_PI/180.0;
dump_image.cpp:  // up vector
dump_image.cpp:  // zoom and perspective
dump_image.cpp:  // remainder of view setup is internal to Image class
dump_image.cpp:/* ----------------------------------------------------------------------
dump_image.cpp:------------------------------------------------------------------------- */
dump_image.cpp:  // render my atoms
dump_image.cpp:      // do not draw if line,tri,body keywords enabled and atom is one of those
dump_image.cpp:  // render atoms that are lines
dump_image.cpp:  // render atoms that are triangles
dump_image.cpp:  // tstyle = 1 for tri only, 2 for edges only, 3 for both
dump_image.cpp:  // render atoms that are bodies
dump_image.cpp:  // render bonds for my atoms
dump_image.cpp:  // both atoms in bond must be selected for bond to be rendered
dump_image.cpp:  // if newton_bond is off, only render bond once
dump_image.cpp:  // render bond in 2 pieces if crosses periodic boundary
dump_image.cpp:  // if bond is deleted (type = 0), do not render
dump_image.cpp:  // if bond is turned off (type < 0), still render
dump_image.cpp:    // communicate choose flag for ghost atoms to know if they are selected
dump_image.cpp:    // if bcolor/bdiam = ATOM, setup bufcopy to comm atom color/diam attributes
dump_image.cpp:        // draw cylinder in 2 pieces if bcolor = ATOM
dump_image.cpp:        // or bond crosses periodic boundary
dump_image.cpp:  // render objects provided by a fix
dump_image.cpp:        // no fix draws spheres yet
dump_image.cpp:  // render outline of my sub-box, orthogonal or triclinic
dump_image.cpp:  // render outline of simulation box, orthogonal or triclinic
dump_image.cpp:  // render XYZ axes in red/green/blue
dump_image.cpp:  // offset by 10% of box size and scale by axeslen
dump_image.cpp:/* ---------------------------------------------------------------------- */
dump_image.cpp:/* ---------------------------------------------------------------------- */
dump_image.cpp:/* ---------------------------------------------------------------------- */
dump_image.cpp:    // ptrs = list of ncount colornames separated by '/'
dump_image.cpp:    while ((nextptr = strchr(ptr,'/'))) {
dump_image.cpp:    ptrs[ncount++] = strtok(arg[2],"/");
dump_image.cpp:    while ((ptrs[ncount++] = strtok(NULL,"/")));
dump_image.cpp:    // assign each of ncount colors in round-robin fashion to types
dump_image.cpp:    // ptrs = list of ncount colornames separated by '/'
dump_image.cpp:    while ((nextptr = strchr(ptr,'/'))) {
dump_image.cpp:    ptrs[ncount++] = strtok(arg[2],"/");
dump_image.cpp:    while ((ptrs[ncount++] = strtok(NULL,"/")));
dump_image.cpp:    // assign each of ncount colors in round-robin fashion to types
dump_local.cpp:/* ----------------------------------------------------------------------
dump_local.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump_local.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump_local.cpp:------------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:  // expand args if any have wildcard character "*"
dump_local.cpp:  // allocate field vectors
dump_local.cpp:  // computes & fixes which the dump accesses
dump_local.cpp:  // process attributes
dump_local.cpp:  // setup format strings
dump_local.cpp:  // setup column string
dump_local.cpp:  // setup default label string
dump_local.cpp:  // if wildcard expansion occurred, free earg memory from exapnd_args()
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:  // format = copy of default or user-specified line format
dump_local.cpp:  // tokenize the format string and add space at end of each format element
dump_local.cpp:  // if user-specified int/float format exists, use it instead
dump_local.cpp:  // if user-specified column format exists, use it instead
dump_local.cpp:  // lo priority = line, medium priority = int/float, hi priority = column
dump_local.cpp:  // setup boundary string
dump_local.cpp:  // setup function ptrs
dump_local.cpp:  // find current ptr for each compute,fix,variable
dump_local.cpp:  // check that fix frequency is acceptable
dump_local.cpp:  // open single file, one time only
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:  // invoke Computes for local quantities
dump_local.cpp:  // only if within a run or minimize
dump_local.cpp:  // else require that computes are current
dump_local.cpp:  // this prevents a compute from being invoked by the WriteDump class
dump_local.cpp:  // nmine = # of local values I contribute
dump_local.cpp:  // must be consistent for all input fields
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:/* ----------------------------------------------------------------------
dump_local.cpp:------------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:  // customize by adding to if statement
dump_local.cpp:    // compute value = c_ID
dump_local.cpp:    // if no trailing [], then arg is set to 0, else arg is int between []
dump_local.cpp:    // fix value = f_ID
dump_local.cpp:    // if no trailing [], then arg is set to 0, else arg is between []
dump_local.cpp:/* ----------------------------------------------------------------------
dump_local.cpp:------------------------------------------------------------------------- */
dump_local.cpp:/* ----------------------------------------------------------------------
dump_local.cpp:------------------------------------------------------------------------- */
dump_local.cpp:/* ----------------------------------------------------------------------
dump_local.cpp:------------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_local.cpp:/* ----------------------------------------------------------------------
dump_local.cpp:------------------------------------------------------------------------- */
dump_local.cpp:/* ---------------------------------------------------------------------- */
dump_movie.cpp:/* ----------------------------------------------------------------------
dump_movie.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump_movie.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump_movie.cpp:------------------------------------------------------------------------- */
dump_movie.cpp:/* ----------------------------------------------------------------------
dump_movie.cpp:------------------------------------------------------------------------- */
dump_movie.cpp:/* ---------------------------------------------------------------------- */
dump_movie.cpp:/* ---------------------------------------------------------------------- */
dump_movie.cpp:/* ---------------------------------------------------------------------- */
dump_movie.cpp:  // initialize image style circumventing multifile check
dump_movie.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:/* ----------------------------------------------------------------------
dump_xyz.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
dump_xyz.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
dump_xyz.cpp:------------------------------------------------------------------------- */
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:  // format = copy of default or user-specified line format
dump_xyz.cpp:  // initialize typenames array to be backward compatible by default
dump_xyz.cpp:  // a 32-bit int can be maximally 10 digits plus sign
dump_xyz.cpp:  // setup function ptr
dump_xyz.cpp:  // open single file, one time only
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:/* ----------------------------------------------------------------------
dump_xyz.cpp:------------------------------------------------------------------------- */
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
dump_xyz.cpp:/* ---------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
error.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ---------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
error.cpp:/* ----------------------------------------------------------------------
error.cpp:------------------------------------------------------------------------- */
finish.cpp:/* ----------------------------------------------------------------------
finish.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
finish.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
finish.cpp:------------------------------------------------------------------------- */
finish.cpp:// local function prototypes, code at end of file
finish.cpp:/* ---------------------------------------------------------------------- */
finish.cpp:/* ---------------------------------------------------------------------- */
finish.cpp:  // recompute natoms in case atoms have been lost
finish.cpp:  // choose flavors of statistical output
finish.cpp:  // flag determines caller
finish.cpp:  // flag = 0 = just loop summary
finish.cpp:  // flag = 1 = dynamics or minimization
finish.cpp:  // flag = 2 = PRD
finish.cpp:  // flag = 3 = TAD
finish.cpp:  // flag = 4 = HYPER
finish.cpp:  // turn off neighflag for Kspace partition of verlet/split integrator
finish.cpp:        strncmp(update->integrate_style,"verlet/split",12) == 0 &&
finish.cpp:  // loop stats
finish.cpp:    // overall loop time
finish.cpp:    time_loop = tmp/nprocs;
finish.cpp:    cpu_loop = tmp/nprocs;
finish.cpp:    if (time_loop > 0.0) cpu_loop = cpu_loop/time_loop*100.0;
finish.cpp:      // Gromacs/NAMD-style performance metric for suitable unit settings
finish.cpp:        double t_step = ((double) time_loop) / ((double) update->nsteps);
finish.cpp:        double step_t = 1.0/t_step;
finish.cpp:          double tau_day = 24.0*3600.0 / t_step * update->dt / one_fs;
finish.cpp:          const char perf[] = "Performance: %.3f tau/day, %.3f timesteps/s\n";
finish.cpp:          double hrs_ns = t_step / update->dt * 1000000.0 * one_fs / 3600.0;
finish.cpp:          double ns_day = 24.0*3600.0 / t_step * update->dt / one_fs/1000000.0;
finish.cpp:            "Performance: %.3f ns/day, %.3f hours/ns, %.3f timesteps/s\n";
finish.cpp:      // CPU use on MPI tasks and OpenMP threads
finish.cpp:  // avoid division by zero for very short runs
finish.cpp:  // get "Other" wall time for later use
finish.cpp:  // minimization stats
finish.cpp:  // PRD stats
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:    if (me == 0) { // XXXX: replica comm, replica output
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:  // TAD stats
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:  // HYPER stats
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:    time = tmp/nprocs;
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:                time,time/time_loop*100.0);
finish.cpp:  // further timing breakdowns
finish.cpp:    time = tmp/nprocs;
finish.cpp:      if (screen) fprintf(screen,fmt,time,time/time_loop*100.0);
finish.cpp:      if (logfile) fprintf(logfile,fmt,time,time/time_loop*100.0);
finish.cpp:    "\nThread timing breakdown (MPI rank %d):\nTotal threaded time %.4g / %.1f%%\n";
finish.cpp:  // print thread breakdown only with full timer detail
finish.cpp:    thr_total /= (double) nthreads;
finish.cpp:        fprintf(screen,thr_hdr_fmt,me,thr_total,thr_total/time_loop*100.0);
finish.cpp:        fprintf(logfile,thr_hdr_fmt,me,thr_total,thr_total/time_loop*100.0);
finish.cpp:                       "since GPU/CPU overlap is enabled\n"
finish.cpp:  // FFT timing statistics
finish.cpp:  // time3d,time1d = total time during run for 3d and 1d FFTs
finish.cpp:  // loop on timing() until nsample FFTs require at least 1.0 CPU sec
finish.cpp:  // time_kspace may be 0.0 if another partition is doing Kspace
finish.cpp:    time3d = nsteps * time3d / nsample;
finish.cpp:    time3d = tmp/nprocs;
finish.cpp:    time1d = nsteps * time1d / nsample;
finish.cpp:    time1d = tmp/nprocs;
finish.cpp:    time_kspace = tmp/nprocs;
finish.cpp:      if (time_kspace) fraction = time3d/time_kspace*100.0;
finish.cpp:      flop3 = nfft*nflops/1.0e9/(time3d/nsteps);
finish.cpp:      flop1 = nfft*nflops/1.0e9/(time1d/nsteps);
finish.cpp:    // find a non-skip neighbor list containing half pairwise interactions
finish.cpp:    // count neighbors in that list for stats purposes
finish.cpp:    // allow it to be Kokkos neigh list as well
finish.cpp:    // find a non-skip neighbor list containing full pairwise interactions
finish.cpp:    // count neighbors in that list for stats purposes
finish.cpp:    // allow it to be Kokkos neigh list as well
finish.cpp:          fprintf(screen,"Ave neighs/atom = %g\n",nall/atom->natoms);
finish.cpp:          fprintf(screen,"Ave special neighs/atom = %g\n",
finish.cpp:                  nspec_all/atom->natoms);
finish.cpp:          fprintf(logfile,"Ave neighs/atom = %g\n",nall/atom->natoms);
finish.cpp:          fprintf(logfile,"Ave special neighs/atom = %g\n",
finish.cpp:                  nspec_all/atom->natoms);
finish.cpp:/* ---------------------------------------------------------------------- */
finish.cpp:  ave = tmp/ntotal;
finish.cpp:    else m = static_cast<int> ((data[i]-min)/del * nhisto);
finish.cpp:/* ---------------------------------------------------------------------- */
finish.cpp:  if (time/time_loop < 0.001)  // insufficient timer resolution!
finish.cpp:    time_cpu = time_cpu / time;
finish.cpp:  time = tmp/nprocs;
finish.cpp:  time_sq = tmp/nprocs;
finish.cpp:  time_cpu = tmp/nprocs*100.0;
finish.cpp:  // % variance from the average as measure of load imbalance
finish.cpp:  if ((time > 0.001) && ((time_sq/time - time) > 1.0e-10))
finish.cpp:    time_sq = sqrt(time_sq/time - time)*100.0;
finish.cpp:    tmp = time/time_loop*100.0;
finish.cpp:      time_loop = 100.0/time_loop;
finish.cpp:/* ---------------------------------------------------------------------- */
finish.cpp:  time_avg /= nthreads;
finish.cpp:  time_std /= nthreads;
finish.cpp:  time_total /= nthreads;
finish.cpp:  if ((time_avg > 0.001) && ((time_std/time_avg -time_avg) > 1.0e-10))
finish.cpp:    time_std = sqrt(time_std/time_avg - time_avg)*100.0;
finish.cpp:                   time_avg/time_total*100.0);
finish.cpp:                   time_avg/time_total*100.0);
fix_adapt.cpp:/* ----------------------------------------------------------------------
fix_adapt.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_adapt.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_adapt.cpp:------------------------------------------------------------------------- */
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:  // count # of adaptations
fix_adapt.cpp:  // parse keywords
fix_adapt.cpp:  // optional keywords
fix_adapt.cpp:  // allocate pair style arrays
fix_adapt.cpp:  // allocate bond style arrays:
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:  // check nfix in case all fixes have already been deleted
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:/* ----------------------------------------------------------------------
fix_adapt.cpp:------------------------------------------------------------------------- */
fix_adapt.cpp:  // new id = fix-ID + FIX_STORE_ATTRIBUTE
fix_adapt.cpp:  // new fix group = group for this fix
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:  // allow a dynamic group only if ATOM attribute not used
fix_adapt.cpp:  // setup and error checks
fix_adapt.cpp:      // if ad->pstyle has trailing sub-style annotation ":N",
fix_adapt.cpp:      //   strip it for pstyle arg to pair_match() and set nsub = N
fix_adapt.cpp:      // this should work for appended suffixes as well
fix_adapt.cpp:        strcat(psuffix,"/");
fix_adapt.cpp:      // for pair styles only parameters that are 2-d arrays in atom types or
fix_adapt.cpp:      // scalars are supported
fix_adapt.cpp:      // if pair hybrid, test that ilo,ihi,jlo,jhi are valid for sub-style
fix_adapt.cpp:          strcmp(force->pair_style,"hybrid/overlay") == 0) {
fix_adapt.cpp:        strcat(bsuffix,"/");
fix_adapt.cpp:      // for bond styles, use a vector
fix_adapt.cpp:  // make copy of original pair/bond array values
fix_adapt.cpp:  // fixes that store initial per-atom values
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:/* ---------------------------------------------------------------------- */
fix_adapt.cpp:/* ----------------------------------------------------------------------
fix_adapt.cpp:------------------------------------------------------------------------- */
fix_adapt.cpp:  // variable evaluation may invoke computes so wrap with clear/add
fix_adapt.cpp:    // set global scalar or type pair array values
fix_adapt.cpp:    // set bond type array values:
fix_adapt.cpp:    // set kspace scale factor
fix_adapt.cpp:    // set per atom values, also make changes for ghost atoms
fix_adapt.cpp:      // reset radius from diameter
fix_adapt.cpp:      // also scale rmass to new value
fix_adapt.cpp:              density = rmass[i] / (4.0*MY_PI/3.0 *
fix_adapt.cpp:              rmass[i] = 4.0*MY_PI/3.0 *
fix_adapt.cpp:  // re-initialize pair styles if any PAIR settings were changed
fix_adapt.cpp:  // ditto for bond styles if any BOND setitings were changes
fix_adapt.cpp:  // this resets other coeffs that may depend on changed values,
fix_adapt.cpp:  //   and also offset and tail corrections
fix_adapt.cpp:  // reset KSpace charges if charges have changed
fix_adapt.cpp:/* ----------------------------------------------------------------------
fix_adapt.cpp:------------------------------------------------------------------------- */
fix_adapt.cpp:            density = rmass[i] / (4.0*MY_PI/3.0 *
fix_adapt.cpp:            rmass[i] = 4.0*MY_PI/3.0 * radius[i]*radius[i]*radius[i] * density;
fix_adapt.cpp:/* ----------------------------------------------------------------------
fix_adapt.cpp:------------------------------------------------------------------------- */
fix_addforce.cpp:/* ----------------------------------------------------------------------
fix_addforce.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_addforce.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_addforce.cpp:------------------------------------------------------------------------- */
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:  // optional args
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:  // check variables
fix_addforce.cpp:  // set index and check validity of region
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:  // update region if necessary
fix_addforce.cpp:  // reallocate sforce array if necessary
fix_addforce.cpp:  // foriginal[0] = "potential energy" for added force
fix_addforce.cpp:  // foriginal[123] = force on atoms before extra force added
fix_addforce.cpp:  // constant force
fix_addforce.cpp:  // potential energy = - x dot f in unwrapped coords
fix_addforce.cpp:  // variable force, wrap with clear/add
fix_addforce.cpp:  // potential energy = evar if defined, else 0.0
fix_addforce.cpp:  // wrap with clear/add
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:/* ---------------------------------------------------------------------- */
fix_addforce.cpp:/* ----------------------------------------------------------------------
fix_addforce.cpp:------------------------------------------------------------------------- */
fix_addforce.cpp:  // only sum across procs one time
fix_addforce.cpp:/* ----------------------------------------------------------------------
fix_addforce.cpp:------------------------------------------------------------------------- */
fix_addforce.cpp:  // only sum across procs one time
fix_addforce.cpp:/* ----------------------------------------------------------------------
fix_addforce.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:/* ----------------------------------------------------------------------
fix_ave_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_ave_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_ave_atom.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:/* ---------------------------------------------------------------------- */
fix_ave_atom.cpp:  if (narg < 7) error->all(FLERR,"Illegal fix ave/atom command");
fix_ave_atom.cpp:  // expand args if any have wildcard character "*"
fix_ave_atom.cpp:  // this can reset nvalues
fix_ave_atom.cpp:  // parse values
fix_ave_atom.cpp:          error->all(FLERR,"Illegal fix ave/atom command");
fix_ave_atom.cpp:    } else error->all(FLERR,"Illegal fix ave/atom command");
fix_ave_atom.cpp:  // if wildcard expansion occurred, free earg memory from exapnd_args()
fix_ave_atom.cpp:  // setup and error check
fix_ave_atom.cpp:  // for fix inputs, check that fix frequency is acceptable
fix_ave_atom.cpp:    error->all(FLERR,"Illegal fix ave/atom command");
fix_ave_atom.cpp:    error->all(FLERR,"Illegal fix ave/atom command");
fix_ave_atom.cpp:        error->all(FLERR,"Compute ID for fix ave/atom does not exist");
fix_ave_atom.cpp:                   "Fix ave/atom compute does not calculate per-atom values");
fix_ave_atom.cpp:        error->all(FLERR,"Fix ave/atom compute does not "
fix_ave_atom.cpp:        error->all(FLERR,"Fix ave/atom compute does not "
fix_ave_atom.cpp:        error->all(FLERR,"Fix ave/atom compute array is accessed out-of-range");
fix_ave_atom.cpp:        error->all(FLERR,"Fix ID for fix ave/atom does not exist");
fix_ave_atom.cpp:        error->all(FLERR,"Fix ave/atom fix does not calculate per-atom values");
fix_ave_atom.cpp:                   "Fix ave/atom fix does not calculate a per-atom vector");
fix_ave_atom.cpp:                   "Fix ave/atom fix does not calculate a per-atom array");
fix_ave_atom.cpp:        error->all(FLERR,"Fix ave/atom fix array is accessed out-of-range");
fix_ave_atom.cpp:                   "Fix for fix ave/atom not computed at compatible time");
fix_ave_atom.cpp:        error->all(FLERR,"Variable name for fix ave/atom does not exist");
fix_ave_atom.cpp:        error->all(FLERR,"Fix ave/atom variable is not atom-style variable");
fix_ave_atom.cpp:  // this fix produces either a per-atom vector or array
fix_ave_atom.cpp:  // perform initial allocation of atom-based array
fix_ave_atom.cpp:  // register with Atom class
fix_ave_atom.cpp:  // zero the array since dump may access it on timestep 0
fix_ave_atom.cpp:  // zero the array since a variable may access it before first run
fix_ave_atom.cpp:  // nvalid = next step on which end_of_step does something
fix_ave_atom.cpp:  // add nvalid to all computes that store invocation times
fix_ave_atom.cpp:  // since don't know a priori which are invoked by this fix
fix_ave_atom.cpp:  // once in end_of_step() can set timestep for ones actually invoked
fix_ave_atom.cpp:/* ---------------------------------------------------------------------- */
fix_ave_atom.cpp:  // unregister callback to this fix from Atom class
fix_ave_atom.cpp:/* ---------------------------------------------------------------------- */
fix_ave_atom.cpp:/* ---------------------------------------------------------------------- */
fix_ave_atom.cpp:  // set indices and check validity of all computes,fixes,variables
fix_ave_atom.cpp:        error->all(FLERR,"Compute ID for fix ave/atom does not exist");
fix_ave_atom.cpp:        error->all(FLERR,"Fix ID for fix ave/atom does not exist");
fix_ave_atom.cpp:        error->all(FLERR,"Variable name for fix ave/atom does not exist");
fix_ave_atom.cpp:  // need to reset nvalid if nvalid < ntimestep b/c minimize was performed
fix_ave_atom.cpp:/* ----------------------------------------------------------------------
fix_ave_atom.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:/* ---------------------------------------------------------------------- */
fix_ave_atom.cpp:  // skip if not step which requires doing something
fix_ave_atom.cpp:  // error check if timestep was reset in an invalid manner
fix_ave_atom.cpp:    error->all(FLERR,"Invalid timestep reset for fix ave/atom");
fix_ave_atom.cpp:  // zero if first step
fix_ave_atom.cpp:  // accumulate results of attributes,computes,fixes,variables to local copy
fix_ave_atom.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_ave_atom.cpp:    // invoke compute if not previously invoked
fix_ave_atom.cpp:    // access fix fields, guaranteed to be ready
fix_ave_atom.cpp:    // evaluate atom-style variable
fix_ave_atom.cpp:    // final argument = 1 sums result to array
fix_ave_atom.cpp:  // done if irepeat < nrepeat
fix_ave_atom.cpp:  // else reset irepeat and nvalid
fix_ave_atom.cpp:  // average the final result for the Nfreq timestep
fix_ave_atom.cpp:      array[i][m] /= repeat;
fix_ave_atom.cpp:/* ----------------------------------------------------------------------
fix_ave_atom.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:/* ----------------------------------------------------------------------
fix_ave_atom.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:  memory->grow(array,nmax,nvalues,"fix_ave/atom:array");
fix_ave_atom.cpp:/* ----------------------------------------------------------------------
fix_ave_atom.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:/* ----------------------------------------------------------------------
fix_ave_atom.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:/* ----------------------------------------------------------------------
fix_ave_atom.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:/* ----------------------------------------------------------------------
fix_ave_atom.cpp:------------------------------------------------------------------------- */
fix_ave_atom.cpp:  bigint nvalid = (update->ntimestep/peratom_freq)*peratom_freq + peratom_freq;
fix_ave_chunk.cpp:/* ----------------------------------------------------------------------
fix_ave_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_ave_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_ave_chunk.cpp:------------------------------------------------------------------------- */
fix_ave_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_ave_chunk.cpp:  if (narg < 7) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:  // expand args if any have wildcard character "*"
fix_ave_chunk.cpp:  // parse values until one isn't recognized
fix_ave_chunk.cpp:    } else if (strcmp(arg[iarg],"density/number") == 0) {
fix_ave_chunk.cpp:    } else if (strcmp(arg[iarg],"density/mass") == 0) {
fix_ave_chunk.cpp:          error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:  if (nvalues == 0) error->all(FLERR,"No values in fix ave/chunk command");
fix_ave_chunk.cpp:  // optional args
fix_ave_chunk.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:      } else error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:      else error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:        if (iarg+3 > narg) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:        if (nwindow <= 0) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:        error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:        error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:        error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:          sprintf(str,"Cannot open fix ave/chunk file %s",arg[iarg+1]);
fix_ave_chunk.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:    } else error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:  // setup and error check
fix_ave_chunk.cpp:    error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:    error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:    error->all(FLERR,"Illegal fix ave/chunk command");
fix_ave_chunk.cpp:        error->all(FLERR,"Compute ID for fix ave/chunk does not exist");
fix_ave_chunk.cpp:        error->all(FLERR,"Fix ave/chunk compute does not "
fix_ave_chunk.cpp:        error->all(FLERR,"Fix ave/chunk compute does not "
fix_ave_chunk.cpp:        error->all(FLERR,"Fix ave/chunk compute does not "
fix_ave_chunk.cpp:                   "Fix ave/chunk compute vector is accessed out-of-range");
fix_ave_chunk.cpp:        error->all(FLERR,"Fix ID for fix ave/chunk does not exist");
fix_ave_chunk.cpp:                   "Fix ave/chunk fix does not calculate per-atom values");
fix_ave_chunk.cpp:                   "Fix ave/chunk fix does not calculate a per-atom vector");
fix_ave_chunk.cpp:                   "Fix ave/chunk fix does not calculate a per-atom array");
fix_ave_chunk.cpp:        error->all(FLERR,"Fix ave/chunk fix vector is accessed out-of-range");
fix_ave_chunk.cpp:        error->all(FLERR,"Variable name for fix ave/chunk does not exist");
fix_ave_chunk.cpp:        error->all(FLERR,"Fix ave/chunk variable is not atom-style variable");
fix_ave_chunk.cpp:  // increment lock counter in compute chunk/atom
fix_ave_chunk.cpp:  // only if nrepeat > 1 or ave = RUNNING/WINDOW,
fix_ave_chunk.cpp:  //   so that locking spans multiple timesteps
fix_ave_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for fix ave/chunk");
fix_ave_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
fix_ave_chunk.cpp:    error->all(FLERR,"Fix ave/chunk does not use chunk/atom compute");
fix_ave_chunk.cpp:  // print file comment lines
fix_ave_chunk.cpp:  // if wildcard expansion occurred, free earg memory from expand_args()
fix_ave_chunk.cpp:  // wait to do this until after file comment lines are printed
fix_ave_chunk.cpp:  // this fix produces a global array
fix_ave_chunk.cpp:  // size_array_rows is variable and set by allocate()
fix_ave_chunk.cpp:  // initializations
fix_ave_chunk.cpp:  // nvalid = next step on which end_of_step does something
fix_ave_chunk.cpp:  // add nvalid to all computes that store invocation times
fix_ave_chunk.cpp:  // since don't know a priori which are invoked by this fix
fix_ave_chunk.cpp:  // once in end_of_step() can set timestep for ones actually invoked
fix_ave_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_ave_chunk.cpp:  // decrement lock counter in compute chunk/atom, it if still exists
fix_ave_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_ave_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_ave_chunk.cpp:  // set indices and check validity of all computes,fixes,variables
fix_ave_chunk.cpp:  // check that fix frequency is acceptable
fix_ave_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for fix ave/chunk");
fix_ave_chunk.cpp:        error->all(FLERR,"Compute ID for fix ave/chunk does not exist");
fix_ave_chunk.cpp:        error->all(FLERR,"Fix ID for fix ave/chunk does not exist");
fix_ave_chunk.cpp:                   "Fix for fix ave/chunk not computed at compatible time");
fix_ave_chunk.cpp:        error->all(FLERR,"Variable name for fix ave/chunk does not exist");
fix_ave_chunk.cpp:  // need to reset nvalid if nvalid < ntimestep b/c minimize was performed
fix_ave_chunk.cpp:/* ----------------------------------------------------------------------
fix_ave_chunk.cpp:   do not call setup_chunks(), even though fix ave/spatial called setup_bins()
fix_ave_chunk.cpp:   b/c could cause nchunk to change if Nfreq epoch crosses 2 runs
fix_ave_chunk.cpp:------------------------------------------------------------------------- */
fix_ave_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_ave_chunk.cpp:  // skip if not step which requires doing something
fix_ave_chunk.cpp:  // error check if timestep was reset in an invalid manner
fix_ave_chunk.cpp:    error->all(FLERR,"Invalid timestep reset for fix ave/chunk");
fix_ave_chunk.cpp:  // first sample within single Nfreq epoch
fix_ave_chunk.cpp:  // zero out arrays that accumulate over many samples, but not across epochs
fix_ave_chunk.cpp:  // invoke setup_chunks() to determine current nchunk
fix_ave_chunk.cpp:  //   re-allocate per-chunk arrays if needed
fix_ave_chunk.cpp:  // invoke lock() in two cases:
fix_ave_chunk.cpp:  //   if nrepeat > 1: so nchunk cannot change until Nfreq epoch is over,
fix_ave_chunk.cpp:  //     will be unlocked on last repeat of this Nfreq
fix_ave_chunk.cpp:  //   if ave = RUNNING/WINDOW and not yet locked:
fix_ave_chunk.cpp:  //     set forever, will be unlocked in fix destructor
fix_ave_chunk.cpp:  // wrap setup_chunks in clearstep/addstep b/c it may invoke computes
fix_ave_chunk.cpp:  //   both nevery and nfreq are future steps,
fix_ave_chunk.cpp:  //   since call below to cchunk->ichunk()
fix_ave_chunk.cpp:  //     does not re-invoke internal cchunk compute on this same step
fix_ave_chunk.cpp:  // if any DENSITY requested, invoke setup_chunks() on each sampling step
fix_ave_chunk.cpp:  // nchunk will not change but bin volumes might, e.g. for NPT simulation
fix_ave_chunk.cpp:  // zero out arrays for one sample
fix_ave_chunk.cpp:  // compute chunk/atom assigns atoms to chunk IDs
fix_ave_chunk.cpp:  // extract ichunk index vector from compute
fix_ave_chunk.cpp:  // ichunk = 1 to Nchunk for included atoms, 0 for excluded atoms
fix_ave_chunk.cpp:  // wrap compute_ichunk in clearstep/addstep b/c it may invoke computes
fix_ave_chunk.cpp:  // perform the computation for one sample
fix_ave_chunk.cpp:  // count # of atoms in each bin
fix_ave_chunk.cpp:  // accumulate results of attributes,computes,fixes,variables to local copy
fix_ave_chunk.cpp:  // sum within each chunk, only include atoms in fix group
fix_ave_chunk.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_ave_chunk.cpp:    // V,F adds velocities,forces to values
fix_ave_chunk.cpp:    // DENSITY_NUMBER adds 1 to values
fix_ave_chunk.cpp:    // DENSITY_MASS or MASS adds mass to values
fix_ave_chunk.cpp:    // TEMPERATURE adds KE to values
fix_ave_chunk.cpp:    // subtract and restore velocity bias if requested
fix_ave_chunk.cpp:    // COMPUTE adds its scalar or vector component to values
fix_ave_chunk.cpp:    // invoke compute if not previously invoked
fix_ave_chunk.cpp:    // FIX adds its scalar or vector component to values
fix_ave_chunk.cpp:    // access fix fields, guaranteed to be ready
fix_ave_chunk.cpp:    // VARIABLE adds its per-atom quantities to values
fix_ave_chunk.cpp:    // evaluate atom-style variable
fix_ave_chunk.cpp:        memory->create(varatom,maxvar,"ave/chunk:varatom");
fix_ave_chunk.cpp:  // process the current sample
fix_ave_chunk.cpp:  // if normflag = ALL, accumulate values,count separately to many
fix_ave_chunk.cpp:  // if normflag = SAMPLE, one = value/count, accumulate one to many
fix_ave_chunk.cpp:  //   count is MPI summed here, value is MPI summed below across samples
fix_ave_chunk.cpp:  //   exception is TEMPERATURE: normalize by DOF
fix_ave_chunk.cpp:  //   exception is DENSITY_NUMBER: 
fix_ave_chunk.cpp:  //     normalize by bin volume, not by atom count
fix_ave_chunk.cpp:  //   exception is DENSITY_MASS:
fix_ave_chunk.cpp:  //     scale by mv2d, normalize by bin volume, not by atom count
fix_ave_chunk.cpp:  //   exception is scaleflag = NOSCALE (norm = NONE):
fix_ave_chunk.cpp:  //     no normalize by atom count
fix_ave_chunk.cpp:  //     check last so other options can take precedence
fix_ave_chunk.cpp:            values_many[m][j] += mvv2e*values_one[m][j] /
fix_ave_chunk.cpp:            if (volflag == SCALAR) values_one[m][j] /= chunk_volume_scalar;
fix_ave_chunk.cpp:            else values_one[m][j] /= chunk_volume_vec[m];
fix_ave_chunk.cpp:            if (volflag == SCALAR) values_one[m][j] /= chunk_volume_scalar;
fix_ave_chunk.cpp:            else values_one[m][j] /= chunk_volume_vec[m];
fix_ave_chunk.cpp:            values_many[m][j] += values_one[m][j]/count_many[m];
fix_ave_chunk.cpp:  // done if irepeat < nrepeat
fix_ave_chunk.cpp:  // else reset irepeat and nvalid
fix_ave_chunk.cpp:  // unlock compute chunk/atom at end of Nfreq epoch
fix_ave_chunk.cpp:  // do not unlock if ave = RUNNING or WINDOW
fix_ave_chunk.cpp:  // time average across samples
fix_ave_chunk.cpp:  // if normflag = ALL, final is total value / total count
fix_ave_chunk.cpp:  //   exception is TEMPERATURE: normalize by DOF for total count
fix_ave_chunk.cpp:  //   exception is DENSITY_NUMBER: 
fix_ave_chunk.cpp:  //     normalize by final bin_volume and repeat, not by total count
fix_ave_chunk.cpp:  //   exception is DENSITY_MASS:
fix_ave_chunk.cpp:  //     scale by mv2d, normalize by bin volume and repeat, not by total count
fix_ave_chunk.cpp:  //   exception is scaleflag == NOSCALE: 
fix_ave_chunk.cpp:  //     normalize by repeat, not by total count
fix_ave_chunk.cpp:  //     check last so other options can take precedence
fix_ave_chunk.cpp:  // if normflag = SAMPLE, final is sum of ave / repeat
fix_ave_chunk.cpp:            values_sum[m][j] *= mvv2e / ((cdof + adof*count_sum[m]) * boltz);
fix_ave_chunk.cpp:            if (volflag == SCALAR) values_sum[m][j] /= chunk_volume_scalar;
fix_ave_chunk.cpp:            else values_sum[m][j] /= chunk_volume_vec[m];
fix_ave_chunk.cpp:            values_sum[m][j] /= repeat;
fix_ave_chunk.cpp:            if (volflag == SCALAR) values_sum[m][j] /= chunk_volume_scalar;
fix_ave_chunk.cpp:            else values_sum[m][j] /= chunk_volume_vec[m];
fix_ave_chunk.cpp:            values_sum[m][j] *= mv2d/repeat;
fix_ave_chunk.cpp:            values_sum[m][j] /= repeat;
fix_ave_chunk.cpp:            values_sum[m][j] /= count_sum[m];
fix_ave_chunk.cpp:      count_sum[m] /= repeat;
fix_ave_chunk.cpp:      for (j = 0; j < nvalues; j++) values_sum[m][j] /= repeat;
fix_ave_chunk.cpp:      count_sum[m] /= repeat;
fix_ave_chunk.cpp:  // if ave = ONE, only single Nfreq timestep value is needed
fix_ave_chunk.cpp:  // if ave = RUNNING, combine with all previous Nfreq timestep values
fix_ave_chunk.cpp:  // if ave = WINDOW, comine with nwindow most recent Nfreq timestep values
fix_ave_chunk.cpp:  // output result to file
fix_ave_chunk.cpp:          fprintf(fp,"  %d %g",m+1,count_total[m]/normcount);
fix_ave_chunk.cpp:            fprintf(fp,format,values_total[m][i]/normcount);
fix_ave_chunk.cpp:                  count_total[m]/normcount);
fix_ave_chunk.cpp:            fprintf(fp,format,values_total[m][i]/normcount);
fix_ave_chunk.cpp:                  count_total[m]/normcount);
fix_ave_chunk.cpp:            fprintf(fp,format,values_total[m][i]/normcount);
fix_ave_chunk.cpp:                  coord[m][0],coord[m][1],coord[m][2],count_total[m]/normcount);
fix_ave_chunk.cpp:            fprintf(fp,format,values_total[m][i]/normcount);
fix_ave_chunk.cpp:          fprintf(fp,"  %d %d %g",m+1,chunkID[m],count_total[m]/normcount);
fix_ave_chunk.cpp:            fprintf(fp,format,values_total[m][i]/normcount);
fix_ave_chunk.cpp:                  count_total[m]/normcount);
fix_ave_chunk.cpp:            fprintf(fp,format,values_total[m][i]/normcount);
fix_ave_chunk.cpp:                  count_total[m]/normcount);
fix_ave_chunk.cpp:            fprintf(fp,format,values_total[m][i]/normcount);
fix_ave_chunk.cpp:                  coord[j-1][1],coord[j-1][2],count_total[m]/normcount);
fix_ave_chunk.cpp:            fprintf(fp,format,values_total[m][i]/normcount);
fix_ave_chunk.cpp:/* ----------------------------------------------------------------------
fix_ave_chunk.cpp:------------------------------------------------------------------------- */
fix_ave_chunk.cpp:  // reallocate chunk arrays if needed
fix_ave_chunk.cpp:    memory->grow(count_one,nchunk,"ave/chunk:count_one");
fix_ave_chunk.cpp:    memory->grow(count_many,nchunk,"ave/chunk:count_many");
fix_ave_chunk.cpp:    memory->grow(count_sum,nchunk,"ave/chunk:count_sum");
fix_ave_chunk.cpp:    memory->grow(count_total,nchunk,"ave/chunk:count_total");
fix_ave_chunk.cpp:    memory->grow(values_one,nchunk,nvalues,"ave/chunk:values_one");
fix_ave_chunk.cpp:    memory->grow(values_many,nchunk,nvalues,"ave/chunk:values_many");
fix_ave_chunk.cpp:    memory->grow(values_sum,nchunk,nvalues,"ave/chunk:values_sum");
fix_ave_chunk.cpp:    memory->grow(values_total,nchunk,nvalues,"ave/chunk:values_total");
fix_ave_chunk.cpp:    // only allocate count and values list for ave = WINDOW
fix_ave_chunk.cpp:      memory->create(count_list,nwindow,nchunk,"ave/chunk:count_list");
fix_ave_chunk.cpp:                     "ave/chunk:values_list");
fix_ave_chunk.cpp:    // reinitialize regrown count/values total since they accumulate
fix_ave_chunk.cpp:/* ----------------------------------------------------------------------
fix_ave_chunk.cpp:------------------------------------------------------------------------- */
fix_ave_chunk.cpp:  if (j < 0) return count_total[i]/normcount;
fix_ave_chunk.cpp:  return values_total[i][j]/normcount;
fix_ave_chunk.cpp:/* ----------------------------------------------------------------------
fix_ave_chunk.cpp:------------------------------------------------------------------------- */
fix_ave_chunk.cpp:  bigint nvalid = (update->ntimestep/nfreq)*nfreq + nfreq;
fix_ave_chunk.cpp:/* ----------------------------------------------------------------------
fix_ave_chunk.cpp:------------------------------------------------------------------------- */
fix_ave_chunk.cpp:  double bytes = maxvar * sizeof(double);         // varatom
fix_ave_chunk.cpp:  bytes += 4*maxchunk * sizeof(double);           // count one,many,sum,total
fix_ave_chunk.cpp:  bytes += nvalues*maxchunk * sizeof(double);     // values one,many,sum,total
fix_ave_chunk.cpp:  bytes += nwindow*maxchunk * sizeof(double);          // count_list
fix_ave_chunk.cpp:  bytes += nwindow*maxchunk*nvalues * sizeof(double);  // values_list
fix_ave_correlate.cpp:/* ----------------------------------------------------------------------
fix_ave_correlate.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_ave_correlate.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_ave_correlate.cpp:------------------------------------------------------------------------- */
fix_ave_correlate.cpp:/* ----------------------------------------------------------------------
fix_ave_correlate.cpp:------------------------------------------------------------------------- */
fix_ave_correlate.cpp:/* ---------------------------------------------------------------------- */
fix_ave_correlate.cpp:  if (narg < 7) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:  // expand args if any have wildcard character "*"
fix_ave_correlate.cpp:  // parse values until one isn't recognized
fix_ave_correlate.cpp:          error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:  // optional args
fix_ave_correlate.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:      else if (strcmp(arg[iarg+1],"auto/upper") == 0) type = AUTOUPPER;
fix_ave_correlate.cpp:      else if (strcmp(arg[iarg+1],"auto/lower") == 0) type = AUTOLOWER;
fix_ave_correlate.cpp:      else error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:      else error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:          sprintf(str,"Cannot open fix ave/correlate file %s",arg[iarg+1]);
fix_ave_correlate.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:    } else error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:  // setup and error check
fix_ave_correlate.cpp:  // for fix inputs, check that fix frequency is acceptable
fix_ave_correlate.cpp:    error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:    error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:    error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:    error->all(FLERR,"Illegal fix ave/correlate command");
fix_ave_correlate.cpp:        error->all(FLERR,"Compute ID for fix ave/correlate does not exist");
fix_ave_correlate.cpp:                   "Fix ave/correlate compute does not calculate a scalar");
fix_ave_correlate.cpp:                   "Fix ave/correlate compute does not calculate a vector");
fix_ave_correlate.cpp:        error->all(FLERR,"Fix ave/correlate compute vector "
fix_ave_correlate.cpp:        error->all(FLERR,"Fix ID for fix ave/correlate does not exist");
fix_ave_correlate.cpp:        error->all(FLERR,"Fix ave/correlate fix does not calculate a scalar");
fix_ave_correlate.cpp:        error->all(FLERR,"Fix ave/correlate fix does not calculate a vector");
fix_ave_correlate.cpp:                   "Fix ave/correlate fix vector is accessed out-of-range");
fix_ave_correlate.cpp:        error->all(FLERR,"Fix for fix ave/correlate "
fix_ave_correlate.cpp:        error->all(FLERR,"Variable name for fix ave/correlate does not exist");
fix_ave_correlate.cpp:                   "Fix ave/correlate variable is not equal-style variable");
fix_ave_correlate.cpp:                   "Fix ave/correlate variable is not vector-style variable");
fix_ave_correlate.cpp:  // npair = # of correlation pairs to calculate
fix_ave_correlate.cpp:  if (type == UPPER || type == LOWER) npair = nvalues*(nvalues-1)/2;
fix_ave_correlate.cpp:  if (type == AUTOUPPER || type == AUTOLOWER) npair = nvalues*(nvalues+1)/2;
fix_ave_correlate.cpp:  // print file comment lines
fix_ave_correlate.cpp:  // if wildcard expansion occurred, free earg memory from expand_args()
fix_ave_correlate.cpp:  // wait to do this until after file comment lines are printed
fix_ave_correlate.cpp:  // allocate and initialize memory for averaging
fix_ave_correlate.cpp:  // set count and corr to zero since they accumulate
fix_ave_correlate.cpp:  // also set save versions to zero in case accessed via compute_array()
fix_ave_correlate.cpp:  memory->create(values,nrepeat,nvalues,"ave/correlate:values");
fix_ave_correlate.cpp:  memory->create(count,nrepeat,"ave/correlate:count");
fix_ave_correlate.cpp:  memory->create(save_count,nrepeat,"ave/correlate:save_count");
fix_ave_correlate.cpp:  memory->create(corr,nrepeat,npair,"ave/correlate:corr");
fix_ave_correlate.cpp:  memory->create(save_corr,nrepeat,npair,"ave/correlate:save_corr");
fix_ave_correlate.cpp:  // this fix produces a global array
fix_ave_correlate.cpp:  // nvalid = next step on which end_of_step does something
fix_ave_correlate.cpp:  // add nvalid to all computes that store invocation times
fix_ave_correlate.cpp:  // since don't know a priori which are invoked by this fix
fix_ave_correlate.cpp:  // once in end_of_step() can set timestep for ones actually invoked
fix_ave_correlate.cpp:/* ---------------------------------------------------------------------- */
fix_ave_correlate.cpp:/* ---------------------------------------------------------------------- */
fix_ave_correlate.cpp:/* ---------------------------------------------------------------------- */
fix_ave_correlate.cpp:  // set current indices for all computes,fixes,variables
fix_ave_correlate.cpp:        error->all(FLERR,"Compute ID for fix ave/correlate does not exist");
fix_ave_correlate.cpp:        error->all(FLERR,"Fix ID for fix ave/correlate does not exist");
fix_ave_correlate.cpp:        error->all(FLERR,"Variable name for fix ave/correlate does not exist");
fix_ave_correlate.cpp:  // need to reset nvalid if nvalid < ntimestep b/c minimize was performed
fix_ave_correlate.cpp:/* ----------------------------------------------------------------------
fix_ave_correlate.cpp:------------------------------------------------------------------------- */
fix_ave_correlate.cpp:/* ---------------------------------------------------------------------- */
fix_ave_correlate.cpp:  // skip if not step which requires doing something
fix_ave_correlate.cpp:  // error check if timestep was reset in an invalid manner
fix_ave_correlate.cpp:    error->all(FLERR,"Invalid timestep reset for fix ave/correlate");
fix_ave_correlate.cpp:  // accumulate results of computes,fixes,variables to origin
fix_ave_correlate.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_ave_correlate.cpp:  // lastindex = index in values ring of latest time sample
fix_ave_correlate.cpp:    // invoke compute if not previously invoked
fix_ave_correlate.cpp:    // access fix fields, guaranteed to be ready
fix_ave_correlate.cpp:    // evaluate equal-style or vector-style variable
fix_ave_correlate.cpp:  // fistindex = index in values ring of earliest time sample
fix_ave_correlate.cpp:  // nsample = number of time samples in values ring
fix_ave_correlate.cpp:  // calculate all Cij() enabled by latest values
fix_ave_correlate.cpp:  // save results in save_count and save_corr
fix_ave_correlate.cpp:        save_corr[i][j] = prefactor*corr[i][j]/count[i];
fix_ave_correlate.cpp:  // output result to file
fix_ave_correlate.cpp:          fprintf(fp," %g",prefactor*corr[i][j]/count[i]);
fix_ave_correlate.cpp:  // zero accumulation if requested
fix_ave_correlate.cpp:  // recalculate Cij(0)
fix_ave_correlate.cpp:/* ----------------------------------------------------------------------
fix_ave_correlate.cpp:------------------------------------------------------------------------- */
fix_ave_correlate.cpp:/* ----------------------------------------------------------------------
fix_ave_correlate.cpp:------------------------------------------------------------------------- */
fix_ave_correlate.cpp:/* ----------------------------------------------------------------------
fix_ave_correlate.cpp:------------------------------------------------------------------------- */
fix_ave_correlate.cpp:  if (nvalid % nevery) nvalid = (nvalid/nevery)*nevery + nevery;
fix_aveforce.cpp:/* ----------------------------------------------------------------------
fix_aveforce.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_aveforce.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_aveforce.cpp:------------------------------------------------------------------------- */
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:  // optional args
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:  // check variables
fix_aveforce.cpp:  // set index and check validity of region
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:  // update region if necessary
fix_aveforce.cpp:  // sum forces on participating atoms
fix_aveforce.cpp:  // average the force on participating atoms
fix_aveforce.cpp:  // add in requested amount, computed via variable evaluation if necessary
fix_aveforce.cpp:  // wrap variable evaluation with clear/add
fix_aveforce.cpp:  fave[0] = foriginal_all[0]/ncount + xvalue;
fix_aveforce.cpp:  fave[1] = foriginal_all[1]/ncount + yvalue;
fix_aveforce.cpp:  fave[2] = foriginal_all[2]/ncount + zvalue;
fix_aveforce.cpp:  // set force of all participating atoms to same value
fix_aveforce.cpp:  // only for active dimensions
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:  // ave + extra force on selected RESPA level
fix_aveforce.cpp:  // just ave on all other levels
fix_aveforce.cpp:    fave[0] = foriginal_all[0]/ncount;
fix_aveforce.cpp:    fave[1] = foriginal_all[1]/ncount;
fix_aveforce.cpp:    fave[2] = foriginal_all[2]/ncount;
fix_aveforce.cpp:/* ---------------------------------------------------------------------- */
fix_aveforce.cpp:/* ----------------------------------------------------------------------
fix_aveforce.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_ave_histo.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ---------------------------------------------------------------------- */
fix_ave_histo.cpp:  if (narg < 10) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:  // scan values to count them
fix_ave_histo.cpp:  // then read options so know mode = SCALAR/VECTOR before re-reading values
fix_ave_histo.cpp:  if (nvalues == 0) error->all(FLERR,"No values in fix ave/histo command");
fix_ave_histo.cpp:  // expand args if any have wildcard character "*"
fix_ave_histo.cpp:  // this can reset nvalues
fix_ave_histo.cpp:  // parse values
fix_ave_histo.cpp:          error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:  // if wildcard expansion occurred, free earg memory from expand_args()
fix_ave_histo.cpp:  // setup and error check
fix_ave_histo.cpp:  // kind = inputs are all global, or all per-atom, or all local
fix_ave_histo.cpp:  // for fix inputs, check that fix frequency is acceptable
fix_ave_histo.cpp:    error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:    error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:  if (lo >= hi) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:  if (nbins <= 0) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:    error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      if (c_id < 0) error->all(FLERR,"Fix ave/histo input is invalid compute");
fix_ave_histo.cpp:      else error->all(FLERR,"Fix ave/histo input is invalid compute");
fix_ave_histo.cpp:      if (f_id < 0) error->all(FLERR,"Fix ave/histo input is invalid fix");
fix_ave_histo.cpp:      else error->all(FLERR,"Fix ave/histo input is invalid fix");
fix_ave_histo.cpp:      if (ivariable < 0) error->all(FLERR,"Fix ave/histo input is invalid variable");
fix_ave_histo.cpp:      else error->all(FLERR,"Fix ave/histo input is invalid variable");
fix_ave_histo.cpp:                 "Fix ave/histo inputs are not all global, peratom, or local");
fix_ave_histo.cpp:               "Fix ave/histo cannot input per-atom values in scalar mode");
fix_ave_histo.cpp:    error->all(FLERR,"Fix ave/histo cannot input local values in scalar mode");
fix_ave_histo.cpp:        error->all(FLERR,"Compute ID for fix ave/histo does not exist");
fix_ave_histo.cpp:                   "Fix ave/histo compute does not calculate a global scalar");
fix_ave_histo.cpp:                   "Fix ave/histo compute does not calculate a global vector");
fix_ave_histo.cpp:                   "Fix ave/histo compute vector is accessed out-of-range");
fix_ave_histo.cpp:        error->all(FLERR,"Compute ID for fix ave/histo does not exist");
fix_ave_histo.cpp:                   "Fix ave/histo compute does not calculate a global vector");
fix_ave_histo.cpp:                   "Fix ave/histo compute does not calculate a global array");
fix_ave_histo.cpp:                   "Fix ave/histo compute array is accessed out-of-range");
fix_ave_histo.cpp:        error->all(FLERR,"Compute ID for fix ave/histo does not exist");
fix_ave_histo.cpp:                   "Fix ave/histo compute does not calculate per-atom values");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo compute does not "
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo compute does not "
fix_ave_histo.cpp:                   "Fix ave/histo compute array is accessed out-of-range");
fix_ave_histo.cpp:        error->all(FLERR,"Compute ID for fix ave/histo does not exist");
fix_ave_histo.cpp:                   "Fix ave/histo compute does not calculate local values");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo compute does not "
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo compute does not "
fix_ave_histo.cpp:                   "Fix ave/histo compute array is accessed out-of-range");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ID for fix ave/histo does not exist");
fix_ave_histo.cpp:                   "Fix ave/histo fix does not calculate a global scalar");
fix_ave_histo.cpp:                   "Fix ave/histo fix does not calculate a global vector");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix vector is accessed out-of-range");
fix_ave_histo.cpp:                   "Fix for fix ave/histo not computed at compatible time");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ID for fix ave/histo does not exist");
fix_ave_histo.cpp:                   "Fix ave/histo fix does not calculate a global vector");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix does not calculate a global array");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix array is accessed out-of-range");
fix_ave_histo.cpp:                   "Fix for fix ave/histo not computed at compatible time");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ID for fix ave/histo does not exist");
fix_ave_histo.cpp:                   "Fix ave/histo fix does not calculate per-atom values");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix does not "
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix does not "
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix array is accessed out-of-range");
fix_ave_histo.cpp:                   "Fix for fix ave/histo not computed at compatible time");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ID for fix ave/histo does not exist");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix does not calculate local values");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix does not "
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix does not "
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo fix array is accessed out-of-range");
fix_ave_histo.cpp:                   "Fix for fix ave/histo not computed at compatible time");
fix_ave_histo.cpp:        error->all(FLERR,"Variable name for fix ave/histo does not exist");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo variable is not equal-style variable");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo variable is not vector-style variable");
fix_ave_histo.cpp:        error->all(FLERR,"Variable name for fix ave/histo does not exist");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo variable is not vector-style variable");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo variable cannot be indexed");
fix_ave_histo.cpp:        error->all(FLERR,"Variable name for fix ave/histo does not exist");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo variable is not atom-style variable");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ave/histo variable cannot be indexed");
fix_ave_histo.cpp:  // print file comment lines
fix_ave_histo.cpp:    else fprintf(fp,"# Bin Coord Count Count/Total\n");
fix_ave_histo.cpp:  // allocate and initialize memory for averaging
fix_ave_histo.cpp:    memory->create(stats_list,nwindow,4,"ave/histo:stats_list");
fix_ave_histo.cpp:    memory->create(bin_list,nwindow,nbins,"ave/histo:bin_list");
fix_ave_histo.cpp:  // initializations
fix_ave_histo.cpp:  // set coord to bin centers
fix_ave_histo.cpp:    binsize = (hi-lo)/(nbins-2);
fix_ave_histo.cpp:    bininv = 1.0/binsize;
fix_ave_histo.cpp:    binsize = (hi-lo)/nbins;
fix_ave_histo.cpp:    bininv = 1.0/binsize;
fix_ave_histo.cpp:  // nvalid = next step on which end_of_step does something
fix_ave_histo.cpp:  // add nvalid to all computes that store invocation times
fix_ave_histo.cpp:  // since don't know a priori which are invoked by this fix
fix_ave_histo.cpp:  // once in end_of_step() can set timestep for ones actually invoked
fix_ave_histo.cpp:/* ---------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ---------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ---------------------------------------------------------------------- */
fix_ave_histo.cpp:  // set current indices for all computes,fixes,variables
fix_ave_histo.cpp:        error->all(FLERR,"Compute ID for fix ave/histo does not exist");
fix_ave_histo.cpp:        error->all(FLERR,"Fix ID for fix ave/histo does not exist");
fix_ave_histo.cpp:        error->all(FLERR,"Variable name for fix ave/histo does not exist");
fix_ave_histo.cpp:  // need to reset nvalid if nvalid < ntimestep b/c minimize was performed
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ---------------------------------------------------------------------- */
fix_ave_histo.cpp:  // skip if not step which requires doing something
fix_ave_histo.cpp:  // error check if timestep was reset in an invalid manner
fix_ave_histo.cpp:    error->all(FLERR,"Invalid timestep reset for fix ave/histo");
fix_ave_histo.cpp:  // zero if first step
fix_ave_histo.cpp:  // accumulate results of computes,fixes,variables to local copy
fix_ave_histo.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_ave_histo.cpp:    // atom attributes
fix_ave_histo.cpp:    // invoke compute if not previously invoked
fix_ave_histo.cpp:      // access fix fields, guaranteed to be ready
fix_ave_histo.cpp:    // evaluate equal-style or vector-style or atom-style variable
fix_ave_histo.cpp:          memory->create(vector,maxatom,"ave/histo:vector");
fix_ave_histo.cpp:  // done if irepeat < nrepeat
fix_ave_histo.cpp:  // else reset irepeat and nvalid
fix_ave_histo.cpp:  // merge histogram stats across procs if necessary
fix_ave_histo.cpp:  // if ave = ONE, only single Nfreq timestep value is needed
fix_ave_histo.cpp:  // if ave = RUNNING, combine with all previous Nfreq timestep values
fix_ave_histo.cpp:  // if ave = WINDOW, combine with nwindow most recent Nfreq timestep values
fix_ave_histo.cpp:  // output result to file
fix_ave_histo.cpp:                i+1,coord[i],bin_total[i],bin_total[i]/stats_total[0]);
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:  else if (stats_total[0] != 0.0) return bin_total[i]/stats_total[0];
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:  // option defaults
fix_ave_histo.cpp:  // optional args
fix_ave_histo.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:          sprintf(str,"Cannot open fix ave/histo file %s",arg[iarg+1]);
fix_ave_histo.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      else error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:        if (iarg+3 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:        if (nwindow <= 0) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      else error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      else error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:    } else error->all(FLERR,"Illegal fix ave/histo command");
fix_ave_histo.cpp:/* ----------------------------------------------------------------------
fix_ave_histo.cpp:------------------------------------------------------------------------- */
fix_ave_histo.cpp:  bigint nvalid = (update->ntimestep/nfreq)*nfreq + nfreq;
fix_ave_histo_weight.cpp:/* ----------------------------------------------------------------------
fix_ave_histo_weight.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_ave_histo_weight.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_ave_histo_weight.cpp:------------------------------------------------------------------------- */
fix_ave_histo_weight.cpp:/* ----------------------------------------------------------------------
fix_ave_histo_weight.cpp:------------------------------------------------------------------------- */
fix_ave_histo_weight.cpp:/* ---------------------------------------------------------------------- */
fix_ave_histo_weight.cpp:  // nvalues = 2 required for histo/weight
fix_ave_histo_weight.cpp:  if (nvalues != 2) error->all(FLERR,"Illegal fix ave/histo/weight command");
fix_ave_histo_weight.cpp:  // check that length of 2 values is the same
fix_ave_histo_weight.cpp:    error->all(FLERR,"Fix ave/histo/weight value and weight vector "
fix_ave_histo_weight.cpp:/* ---------------------------------------------------------------------- */
fix_ave_histo_weight.cpp:  // skip if not step which requires doing something
fix_ave_histo_weight.cpp:  // error check if timestep was reset in an invalid manner
fix_ave_histo_weight.cpp:    error->all(FLERR,"Invalid timestep reset for fix ave/histo");
fix_ave_histo_weight.cpp:  // zero if first step
fix_ave_histo_weight.cpp:  // first calculate weight factors, then bin single value
fix_ave_histo_weight.cpp:  // accumulate results of computes,fixes,variables to local copy
fix_ave_histo_weight.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_ave_histo_weight.cpp:  // calculate weight factors which are 2nd value (i = 1)
fix_ave_histo_weight.cpp:  // atom attributes
fix_ave_histo_weight.cpp:  // invoke compute if not previously invoked
fix_ave_histo_weight.cpp:  // access fix fields, guaranteed to be ready
fix_ave_histo_weight.cpp:      error->all(FLERR,"Fix ave/histo/weight option not yet supported");
fix_ave_histo_weight.cpp:      // NOTE: need to allocate local storage
fix_ave_histo_weight.cpp:  // evaluate equal-style variable
fix_ave_histo_weight.cpp:      memory->create(vector,maxatom,"ave/histo/weight:vector");
fix_ave_histo_weight.cpp:  // bin values using weights, values are 1st value (i = 0)
fix_ave_histo_weight.cpp:  // atom attributes
fix_ave_histo_weight.cpp:  // invoke compute if not previously invoked
fix_ave_histo_weight.cpp:    // access fix fields, guaranteed to be ready
fix_ave_histo_weight.cpp:    // evaluate equal-style variable
fix_ave_histo_weight.cpp:      memory->create(vector,maxatom,"ave/histo/weight:vector");
fix_ave_histo_weight.cpp:  // code beyond this point is identical to FixAveHisto
fix_ave_histo_weight.cpp:  // done if irepeat < nrepeat
fix_ave_histo_weight.cpp:  // else reset irepeat and nvalid
fix_ave_histo_weight.cpp:  // merge histogram stats across procs if necessary
fix_ave_histo_weight.cpp:  // if ave = ONE, only single Nfreq timestep value is needed
fix_ave_histo_weight.cpp:  // if ave = RUNNING, combine with all previous Nfreq timestep values
fix_ave_histo_weight.cpp:  // if ave = WINDOW, combine with nwindow most recent Nfreq timestep values
fix_ave_histo_weight.cpp:  // output result to file
fix_ave_histo_weight.cpp:                i+1,coord[i],bin_total[i],bin_total[i]/stats_total[0]);
fix_ave_histo_weight.cpp:/* ----------------------------------------------------------------------
fix_ave_histo_weight.cpp:------------------------------------------------------------------------- */
fix_ave_histo_weight.cpp:/* ----------------------------------------------------------------------
fix_ave_histo_weight.cpp:------------------------------------------------------------------------- */
fix_ave_histo_weight.cpp:/* ----------------------------------------------------------------------
fix_ave_histo_weight.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_ave_time.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:/* ---------------------------------------------------------------------- */
fix_ave_time.cpp:  if (narg < 7) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:  // scan values to count them
fix_ave_time.cpp:  // then read options so know mode = SCALAR/VECTOR before re-reading values
fix_ave_time.cpp:  if (nvalues == 0) error->all(FLERR,"No values in fix ave/time command");
fix_ave_time.cpp:  // expand args if any have wildcard character "*"
fix_ave_time.cpp:  // this can reset nvalues
fix_ave_time.cpp:  // parse values
fix_ave_time.cpp:        error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:  // set off columns now that nvalues is finalized
fix_ave_time.cpp:      error->all(FLERR,"Invalid fix ave/time off column");
fix_ave_time.cpp:  // setup and error check
fix_ave_time.cpp:  // for fix inputs, check that fix frequency is acceptable
fix_ave_time.cpp:  // set variable_length if any compute is variable length
fix_ave_time.cpp:    error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:    error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:    error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:        error->all(FLERR,"Compute ID for fix ave/time does not exist");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time compute does not calculate a scalar");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time compute does not calculate a vector");
fix_ave_time.cpp:                   "Fix ave/time compute vector is accessed out-of-range");
fix_ave_time.cpp:        error->all(FLERR,"Compute ID for fix ave/time does not exist");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time compute does not calculate a vector");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time compute does not calculate an array");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time compute array is accessed out-of-range");
fix_ave_time.cpp:        error->all(FLERR,"Fix ID for fix ave/time does not exist");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time fix does not calculate a scalar");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time fix does not calculate a vector");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time fix vector cannot be variable length");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time fix vector is accessed out-of-range");
fix_ave_time.cpp:                   "Fix for fix ave/time not computed at compatible time");
fix_ave_time.cpp:        error->all(FLERR,"Fix ID for fix ave/time does not exist");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time fix does not calculate a vector");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time fix does not calculate an array");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time fix array cannot be variable length");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time fix array is accessed out-of-range");
fix_ave_time.cpp:                   "Fix for fix ave/time not computed at compatible time");
fix_ave_time.cpp:        error->all(FLERR,"Variable name for fix ave/time does not exist");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time variable is not equal-style variable");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time variable is not vector-style variable");
fix_ave_time.cpp:        error->all(FLERR,"Variable name for fix ave/time does not exist");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time variable is not vector-style variable");
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time mode vector variable cannot be indexed");
fix_ave_time.cpp:  // all_variable_length = 1 if all values are variable length
fix_ave_time.cpp:  // any_variable_length = 1 if any values are variable length
fix_ave_time.cpp:  // if VECTOR mode, check that all columns are same length
fix_ave_time.cpp:  // nrows = # of rows in output array
fix_ave_time.cpp:  // if all columns are variable length, just set nrows = 1 for now
fix_ave_time.cpp:    memory->create(column,nrows,"ave/time:column");
fix_ave_time.cpp:  // enable locking of row count by this fix for computes of variable length
fix_ave_time.cpp:  // only if nrepeat > 1 or ave = RUNNING/WINDOW,
fix_ave_time.cpp:  //   so that locking spans multiple timesteps
fix_ave_time.cpp:  // print file comment lines
fix_ave_time.cpp:  // for mode = VECTOR, cannot use arg to print
fix_ave_time.cpp:  // since array args may have been expanded to multiple vectors
fix_ave_time.cpp:  // if wildcard expansion occurred, free earg memory from expand_args()
fix_ave_time.cpp:  // wait to do this until after file comment lines are printed
fix_ave_time.cpp:  // allocate memory for averaging
fix_ave_time.cpp:      memory->create(vector_list,nwindow,nvalues,"ave/time:vector_list");
fix_ave_time.cpp:  // this fix produces either a global scalar or vector or array
fix_ave_time.cpp:  // SCALAR mode produces either a scalar or vector
fix_ave_time.cpp:  // VECTOR mode produces either a vector or array
fix_ave_time.cpp:  // intensive/extensive flags set by compute,fix,variable that produces value
fix_ave_time.cpp:          error->all(FLERR,"Fix ave/time cannot set output array "
fix_ave_time.cpp:                     "intensive/extensive from these inputs");
fix_ave_time.cpp:          error->all(FLERR,"Fix ave/time cannot set output array "
fix_ave_time.cpp:                     "intensive/extensive from these inputs");
fix_ave_time.cpp:  // initializations
fix_ave_time.cpp:  // set vector_total to zero since it accumulates
fix_ave_time.cpp:  // array_total already zeroed in allocate_arrays
fix_ave_time.cpp:  // nvalid = next step on which end_of_step does something
fix_ave_time.cpp:  // add nvalid to all computes that store invocation times
fix_ave_time.cpp:  // since don't know a priori which are invoked by this fix
fix_ave_time.cpp:  // once in end_of_step() can set timestep for ones actually invoked
fix_ave_time.cpp:/* ---------------------------------------------------------------------- */
fix_ave_time.cpp:  // decrement lock counter in compute chunk/atom, it if still exists
fix_ave_time.cpp:/* ---------------------------------------------------------------------- */
fix_ave_time.cpp:/* ---------------------------------------------------------------------- */
fix_ave_time.cpp:  // set current indices for all computes,fixes,variables
fix_ave_time.cpp:        error->all(FLERR,"Compute ID for fix ave/time does not exist");
fix_ave_time.cpp:        error->all(FLERR,"Fix ID for fix ave/time does not exist");
fix_ave_time.cpp:        error->all(FLERR,"Variable name for fix ave/time does not exist");
fix_ave_time.cpp:  // need to reset nvalid if nvalid < ntimestep b/c minimize was performed
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:/* ---------------------------------------------------------------------- */
fix_ave_time.cpp:  // skip if not step which requires doing something
fix_ave_time.cpp:  // error check if timestep was reset in an invalid manner
fix_ave_time.cpp:    error->all(FLERR,"Invalid timestep reset for fix ave/time");
fix_ave_time.cpp:/* ---------------------------------------------------------------------- */
fix_ave_time.cpp:  // zero if first sample within single Nfreq epoch
fix_ave_time.cpp:  // if any input is variable length, initialize current length
fix_ave_time.cpp:  // check for exceeding length is done below
fix_ave_time.cpp:  // accumulate results of computes,fixes,variables to local copy
fix_ave_time.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_ave_time.cpp:    // invoke compute if not previously invoked
fix_ave_time.cpp:    // insure no out-of-range access to variable-length compute vector
fix_ave_time.cpp:    // access fix fields, guaranteed to be ready
fix_ave_time.cpp:    // evaluate equal-style or vector-style variable
fix_ave_time.cpp:    // insure no out-of-range access to vector-style variable
fix_ave_time.cpp:    // add value to vector or just set directly if offcol is set
fix_ave_time.cpp:  // done if irepeat < nrepeat
fix_ave_time.cpp:  // else reset irepeat and nvalid
fix_ave_time.cpp:  // average the final result for the Nfreq timestep
fix_ave_time.cpp:    if (offcol[i] == 0) vector[i] /= repeat;
fix_ave_time.cpp:  // if ave = ONE, only single Nfreq timestep value is needed
fix_ave_time.cpp:  // if ave = RUNNING, combine with all previous Nfreq timestep values
fix_ave_time.cpp:  // if ave = WINDOW, combine with nwindow most recent Nfreq timestep values
fix_ave_time.cpp:  // insure any columns with offcol set are effectively set to last value
fix_ave_time.cpp:  // output result to file
fix_ave_time.cpp:    for (i = 0; i < nvalues; i++) fprintf(fp,format,vector_total[i]/norm);
fix_ave_time.cpp:/* ---------------------------------------------------------------------- */
fix_ave_time.cpp:  // first sample within single Nfreq epoch
fix_ave_time.cpp:  // zero out arrays that accumulate over many samples, but not across epochs
fix_ave_time.cpp:  // invoke setup_chunks() to determine current nchunk
fix_ave_time.cpp:  //   re-allocate per-chunk arrays if needed
fix_ave_time.cpp:  // invoke lock() in two cases:
fix_ave_time.cpp:  //   if nrepeat > 1: so nchunk cannot change until Nfreq epoch is over,
fix_ave_time.cpp:  //     will be unlocked on last repeat of this Nfreq
fix_ave_time.cpp:  //   if ave = RUNNING/WINDOW and not yet locked:
fix_ave_time.cpp:  //     set forever, will be unlocked in fix destructor
fix_ave_time.cpp:  // wrap setup_chunks in clearstep/addstep b/c it may invoke computes
fix_ave_time.cpp:  //   both nevery and nfreq are future steps,
fix_ave_time.cpp:  //   since call below to cchunk->ichunk()
fix_ave_time.cpp:  //     does not re-invoke internal cchunk compute on this same step
fix_ave_time.cpp:        memory->create(column,nrows,"ave/time:column");
fix_ave_time.cpp:  // accumulate results of computes,fixes,variables to local copy
fix_ave_time.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_ave_time.cpp:    // invoke compute if not previously invoked
fix_ave_time.cpp:    // access fix fields, guaranteed to be ready
fix_ave_time.cpp:    // evaluate vector-style variable
fix_ave_time.cpp:    // insure nvec = nrows, else error
fix_ave_time.cpp:    // could be different on this timestep than when column_length(1) set nrows
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time vector-style variable changed length");
fix_ave_time.cpp:    // add columns of values to array or just set directly if offcol is set
fix_ave_time.cpp:  // done if irepeat < nrepeat
fix_ave_time.cpp:  // else reset irepeat and nvalid
fix_ave_time.cpp:  // unlock any variable length computes at end of Nfreq epoch
fix_ave_time.cpp:  // do not unlock if ave = RUNNING or WINDOW
fix_ave_time.cpp:  // average the final result for the Nfreq timestep
fix_ave_time.cpp:      if (offcol[j] == 0) array[i][j] /= repeat;
fix_ave_time.cpp:  // if ave = ONE, only single Nfreq timestep value is needed
fix_ave_time.cpp:  // if ave = RUNNING, combine with all previous Nfreq timestep values
fix_ave_time.cpp:  // if ave = WINDOW, combine with nwindow most recent Nfreq timestep values
fix_ave_time.cpp:  // insure any columns with offcol set are effectively set to last value
fix_ave_time.cpp:  // output result to file
fix_ave_time.cpp:      for (j = 0; j < nvalues; j++) fprintf(fp,format,array_total[i][j]/norm);
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:  // determine nrows for static values
fix_ave_time.cpp:        // variables are always varlen = 1, so dynamic
fix_ave_time.cpp:        error->all(FLERR,"Fix ave/time columns are inconsistent lengths");
fix_ave_time.cpp:  // determine new nrows for dynamic values
fix_ave_time.cpp:  // either all must be the same
fix_ave_time.cpp:  // or must match other static values
fix_ave_time.cpp:  // don't need to check if not MODE = VECTOR, just invoke lock_length()
fix_ave_time.cpp:          error->all(FLERR,"Fix ave/time columns are inconsistent lengths");
fix_ave_time.cpp:          error->all(FLERR,"Fix ave/time columns are inconsistent lengths");
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:  if (norm) return vector_total[0]/norm;
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:    if (mode == SCALAR) return vector_total[i]/norm;
fix_ave_time.cpp:    if (mode == VECTOR) return array_total[i][0]/norm;
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:  if (norm) return array_total[i][j]/norm;
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:  // option defaults
fix_ave_time.cpp:  // optional args
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:          sprintf(str,"Cannot open fix ave/time file %s",arg[iarg+1]);
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:      else error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:        if (iarg+3 > narg) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:        if (nwindow <= 0) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:      else error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:      memory->grow(offlist,noff+1,"ave/time:offlist");
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/spatial command");
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/spatial command");
fix_ave_time.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix ave/spatial command");
fix_ave_time.cpp:    } else error->all(FLERR,"Illegal fix ave/time command");
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:  memory->create(array,nrows,nvalues,"ave/time:array");
fix_ave_time.cpp:  memory->create(array_total,nrows,nvalues,"ave/time:array_total");
fix_ave_time.cpp:    memory->create(array_list,nwindow,nrows,nvalues,"ave/time:array_list");
fix_ave_time.cpp:  // reinitialize regrown array_total since it accumulates
fix_ave_time.cpp:/* ----------------------------------------------------------------------
fix_ave_time.cpp:------------------------------------------------------------------------- */
fix_ave_time.cpp:  bigint nvalid = (update->ntimestep/nfreq)*nfreq + nfreq;
fix_balance.cpp:/* ----------------------------------------------------------------------
fix_balance.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_balance.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_balance.cpp:------------------------------------------------------------------------- */
fix_balance.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
fix_balance.cpp:/* ---------------------------------------------------------------------- */
fix_balance.cpp:  // parse required arguments
fix_balance.cpp:  // error checks
fix_balance.cpp:  // create instance of Balance class
fix_balance.cpp:  // if SHIFT, initialize it with params
fix_balance.cpp:  // process remaining optional args via Balance
fix_balance.cpp:  // create instance of Irregular class
fix_balance.cpp:  // only force reneighboring if nevery > 0
fix_balance.cpp:  // compute initial outputs
fix_balance.cpp:/* ---------------------------------------------------------------------- */
fix_balance.cpp:/* ---------------------------------------------------------------------- */
fix_balance.cpp:/* ---------------------------------------------------------------------- */
fix_balance.cpp:/* ---------------------------------------------------------------------- */
fix_balance.cpp:/* ---------------------------------------------------------------------- */
fix_balance.cpp:  // compute final imbalance factor if setup_pre_exchange() invoked balancer
fix_balance.cpp:  // this is called at end of run setup, before output
fix_balance.cpp:/* ---------------------------------------------------------------------- */
fix_balance.cpp:  // do not allow rebalancing twice on same timestep
fix_balance.cpp:  // even if wanted to, can mess up elapsed time in ImbalanceTime
fix_balance.cpp:  // insure atoms are in current box & update box via shrink-wrap
fix_balance.cpp:  // has to be be done before rebalance() invokes Irregular::migrate_atoms()
fix_balance.cpp:  //   since it requires atoms be inside simulation box
fix_balance.cpp:  //   even though pbc() will be done again in Verlet::run()
fix_balance.cpp:  // no exchange() since doesn't matter if atoms are assigned to correct procs
fix_balance.cpp:  // perform a rebalance if threshold exceeded
fix_balance.cpp:  // next timestep to rebalance
fix_balance.cpp:  if (nevery) next_reneighbor = (update->ntimestep/nevery)*nevery + nevery;
fix_balance.cpp:/* ----------------------------------------------------------------------
fix_balance.cpp:------------------------------------------------------------------------- */
fix_balance.cpp:  // return if not a rebalance timestep
fix_balance.cpp:  // do not allow rebalancing twice on same timestep
fix_balance.cpp:  // even if wanted to, can mess up elapsed time in ImbalanceTime
fix_balance.cpp:  // insure atoms are in current box & update box via shrink-wrap
fix_balance.cpp:  // no exchange() since doesn't matter if atoms are assigned to correct procs
fix_balance.cpp:  // perform a rebalance if threshold exceeded
fix_balance.cpp:  // if weight variable is used, wrap weight setting in clear/add compute
fix_balance.cpp:  // next timestep to rebalance
fix_balance.cpp:  if (nevery) next_reneighbor = (update->ntimestep/nevery)*nevery + nevery;
fix_balance.cpp:/* ----------------------------------------------------------------------
fix_balance.cpp:------------------------------------------------------------------------- */
fix_balance.cpp:/* ----------------------------------------------------------------------
fix_balance.cpp:------------------------------------------------------------------------- */
fix_balance.cpp:  // invoke balancer and reset comm->uniform flag
fix_balance.cpp:  // output of new decomposition
fix_balance.cpp:  // reset proc sub-domains
fix_balance.cpp:  // check and warn if any proc's subbox is smaller than neigh skin
fix_balance.cpp:  //   since may lead to lost atoms in exchange()
fix_balance.cpp:  // move atoms to new processors via irregular()
fix_balance.cpp:  // only needed if migrate_check() says an atom moves to far
fix_balance.cpp:  // else allow caller's comm->exchange() to do it
fix_balance.cpp:  // invoke KSpace setup_grid() to adjust to new proc sub-domains
fix_balance.cpp:  // pending triggers pre_neighbor() to compute final imbalance factor
fix_balance.cpp:  // can only be done after atoms migrate in comm->exchange()
fix_balance.cpp:/* ----------------------------------------------------------------------
fix_balance.cpp:------------------------------------------------------------------------- */
fix_balance.cpp:/* ----------------------------------------------------------------------
fix_balance.cpp:------------------------------------------------------------------------- */
fix_balance.cpp:/* ----------------------------------------------------------------------
fix_balance.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_box_relax.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:#define MAX_LIFO_DEPTH 2     // 3 box0 arrays in *.h dimensioned to this
fix_box_relax.cpp:/* ---------------------------------------------------------------------- */
fix_box_relax.cpp:  if (narg < 5) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:  // default values
fix_box_relax.cpp:  // turn on tilt factor scaling, whenever applicable
fix_box_relax.cpp:  // set fixed-point to default = center of cell
fix_box_relax.cpp:  // process keywords
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:        error->all(FLERR,"Invalid fix box/relax command for a 2d simulation");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:        error->all(FLERR,"Invalid fix box/relax command for a 2d simulation");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:        error->all(FLERR,"Invalid fix box/relax command for a 2d simulation");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      else error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      else error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (nreset_h0 < 0) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      else error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      else error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      else error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:    } else error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:  // error checks
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax command for a 2d simulation");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax command for a 2d simulation");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax command pressure settings");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax command pressure settings");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax command pressure settings");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax command pressure settings");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax command pressure settings");
fix_box_relax.cpp:  // require periodicity in tensile dimension
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax on a non-periodic dimension");
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax on a non-periodic dimension");
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax on a non-periodic dimension");
fix_box_relax.cpp:  // require periodicity in 2nd dim of off-diagonal tilt component
fix_box_relax.cpp:               "Cannot use fix box/relax on a 2nd non-periodic dimension");
fix_box_relax.cpp:               "Cannot use fix box/relax on a 2nd non-periodic dimension");
fix_box_relax.cpp:               "Cannot use fix box/relax on a 2nd non-periodic dimension");
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax "
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax "
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax "
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax with "
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax with "
fix_box_relax.cpp:    error->all(FLERR,"Cannot use fix box/relax with "
fix_box_relax.cpp:    error->all(FLERR,"Can not specify Pxy/Pxz/Pyz in "
fix_box_relax.cpp:               "fix box/relax with non-triclinic box");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax pressure settings");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax pressure settings");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax pressure settings");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax pressure settings");
fix_box_relax.cpp:    error->all(FLERR,"Invalid fix box/relax pressure settings");
fix_box_relax.cpp:  if (vmax <= 0.0) error->all(FLERR,"Illegal fix box/relax command");
fix_box_relax.cpp:  // pstyle = TRICLINIC if any off-diagonal term is controlled -> 6 dof
fix_box_relax.cpp:  // else pstyle = ISO if XYZ coupling or XY coupling in 2d -> 1 dof
fix_box_relax.cpp:  // else pstyle = ANISO -> 3 dof
fix_box_relax.cpp:  // create a new compute temp style
fix_box_relax.cpp:  // id = fix-ID + temp
fix_box_relax.cpp:  // compute group = all since pressure is always global (group all)
fix_box_relax.cpp:  //   and thus its KE/temperature contribution should use group all
fix_box_relax.cpp:  // create a new compute pressure style (virial only)
fix_box_relax.cpp:  // id = fix-ID + press, compute group = all
fix_box_relax.cpp:  // pass id_temp as 4th arg to pressure constructor
fix_box_relax.cpp:/* ---------------------------------------------------------------------- */
fix_box_relax.cpp:  // delete temperature and pressure if fix created them
fix_box_relax.cpp:/* ---------------------------------------------------------------------- */
fix_box_relax.cpp:/* ---------------------------------------------------------------------- */
fix_box_relax.cpp:  // set temperature and pressure ptrs
fix_box_relax.cpp:    error->all(FLERR,"Temperature ID for fix box/relax does not exist");
fix_box_relax.cpp:    error->all(FLERR,"Pressure ID for fix box/relax does not exist");
fix_box_relax.cpp:  pv2e = 1.0 / force->nktv2p;
fix_box_relax.cpp:  // detect if any rigid fixes exist so rigid bodies move when box is remapped
fix_box_relax.cpp:  // rfix[] = indices to each fix rigid
fix_box_relax.cpp:  // initial box dimensions
fix_box_relax.cpp:  // hydrostatic target pressure and deviatoric target stress
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:  // trigger virial computation on every iteration of minimizer
fix_box_relax.cpp:  // compute energy, forces for each extra degree of freedom
fix_box_relax.cpp:  // returned eng = PV must be in units of energy
fix_box_relax.cpp:  // returned fextra must likewise be in units of energy
fix_box_relax.cpp:    scale = domain->xprd/xprdinit;
fix_box_relax.cpp:    if (p_flag[0]) scalex = domain->xprd/xprdinit;
fix_box_relax.cpp:    if (p_flag[1]) scaley = domain->yprd/yprdinit;
fix_box_relax.cpp:    if (p_flag[2]) scalez = domain->zprd/zprdinit;
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:    error->all(FLERR,"Attempt to push beyond stack limit in fix box/relax");
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:    error->all(FLERR,"Attempt to pop empty stack in fix box/relax");
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:  // if nreset_h0 > 0, reset reference box
fix_box_relax.cpp:  // every nreset_h0 timesteps
fix_box_relax.cpp:  // only needed for deviatoric external stress
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:  if (pstyle == ISO) alpha = vmax/fabs(hextra[0]);
fix_box_relax.cpp:    if (p_flag[0]) alpha = MIN(alpha,vmax/fabs(hextra[0]));
fix_box_relax.cpp:    if (p_flag[1]) alpha = MIN(alpha,vmax/fabs(hextra[1]));
fix_box_relax.cpp:    if (p_flag[2]) alpha = MIN(alpha,vmax/fabs(hextra[2]));
fix_box_relax.cpp:      if (p_flag[3]) alpha = MIN(alpha,vmax/fabs(hextra[3]));
fix_box_relax.cpp:      if (p_flag[4]) alpha = MIN(alpha,vmax/fabs(hextra[4]));
fix_box_relax.cpp:      if (p_flag[5]) alpha = MIN(alpha,vmax/fabs(hextra[5]));
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:   dilate the box and owned/ghost atoms around center of box
fix_box_relax.cpp:------------------------------------------------------------------------- */
fix_box_relax.cpp:  // rescale simulation box from linesearch starting point
fix_box_relax.cpp:  // scale atom coords for all atoms or only for fix group atoms
fix_box_relax.cpp:  // convert pertinent atoms and rigid bodies to lamda coords
fix_box_relax.cpp:  // reset global and local box to new size/shape
fix_box_relax.cpp:      domain->boxlo[i] = currentBoxLo0 + (currentBoxLo0 - fixedpoint[i])/domain->h[i]*ds[i]*h0[i];
fix_box_relax.cpp:      domain->boxhi[i] = currentBoxHi0 + (currentBoxHi0 - fixedpoint[i])/domain->h[i]*ds[i]*h0[i];
fix_box_relax.cpp:        error->all(FLERR,"Fix box/relax generated negative box length");
fix_box_relax.cpp:  // scale tilt factors with cell, if set
fix_box_relax.cpp:  if (scaleyz) domain->yz = (domain->boxhi[2] - domain->boxlo[2])*h0[3]/h0[2];
fix_box_relax.cpp:  if (scalexz) domain->xz = (domain->boxhi[2] - domain->boxlo[2])*h0[4]/h0[2];
fix_box_relax.cpp:  if (scalexy) domain->xy = (domain->boxhi[1] - domain->boxlo[1])*h0[5]/h0[1];
fix_box_relax.cpp:  // convert pertinent atoms and rigid bodies back to box coords
fix_box_relax.cpp:/* ---------------------------------------------------------------------- */
fix_box_relax.cpp:    double ave = 1.0/3.0 * (tensor[0] + tensor[1] + tensor[2]);
fix_box_relax.cpp:  // switch order from xy-xz-yz to Voigt
fix_box_relax.cpp:/* ---------------------------------------------------------------------- */
fix_box_relax.cpp:    // reset id_temp of pressure to new temperature ID
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:-----------------------------------------------------------------------*/
fix_box_relax.cpp:  // reset reference box dimensions
fix_box_relax.cpp:  // compute target deviatoric stress tensor pdevmod
fix_box_relax.cpp:  // Modify to account for off-diagonal terms
fix_box_relax.cpp:  // These equations come from the stationarity relation:
fix_box_relax.cpp:  //    Pdev,sys = Pdev,targ*hinv^t*hdiag
fix_box_relax.cpp:  // where:
fix_box_relax.cpp:  // Pdev,sys is the system deviatoric stress tensor,
fix_box_relax.cpp:  // Pdev,targ = pdeviatoric, effective target deviatoric stress
fix_box_relax.cpp:  // hinv^t is the transpose of the inverse h tensor
fix_box_relax.cpp:  // hdiag is the diagonal part of the h tensor
fix_box_relax.cpp:  // compute symmetric sigma tensor
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:-----------------------------------------------------------------------*/
fix_box_relax.cpp:  // compute strain energy = 0.5*Tr(sigma*h*h^t) in energy units
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:-----------------------------------------------------------------------*/
fix_box_relax.cpp:  // [ 0 5 4 ]   [ 0 5 4 ] [ 0 5 4 ]
fix_box_relax.cpp:  // [ 5 1 3 ] = [ - 1 3 ] [ 5 1 3 ]
fix_box_relax.cpp:  // [ 4 3 2 ]   [ - - 2 ] [ 4 3 2 ]
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:-----------------------------------------------------------------------*/
fix_box_relax.cpp:  if (pflagsum) p_hydro /= pflagsum;
fix_box_relax.cpp:/* ----------------------------------------------------------------------
fix_box_relax.cpp:   ---------------------------------------------------------------------- */
fix_controller.cpp:/* ----------------------------------------------------------------------
fix_controller.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_controller.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_controller.cpp:------------------------------------------------------------------------- */
fix_controller.cpp:/* ---------------------------------------------------------------------- */
fix_controller.cpp:  // process variable arg
fix_controller.cpp:  // setpoint arg
fix_controller.cpp:  // control variable arg
fix_controller.cpp:  // error check
fix_controller.cpp:/* ---------------------------------------------------------------------- */
fix_controller.cpp:/* ---------------------------------------------------------------------- */
fix_controller.cpp:/* ---------------------------------------------------------------------- */
fix_controller.cpp:  // set sampling time
fix_controller.cpp:/* ---------------------------------------------------------------------- */
fix_controller.cpp:  // current value of pv = invocation of compute,fix,variable
fix_controller.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_controller.cpp:  // invoke compute if not previously invoked
fix_controller.cpp:  // access fix field, guaranteed to be ready
fix_controller.cpp:  // evaluate equal-style variable
fix_controller.cpp:  // new control var = f(old value, current process var, setpoint)
fix_controller.cpp:  // cv = cvold -kp*err -ki*sumerr -kd*deltaerr
fix_controller.cpp:  // note: this deviates from standard notation, which is
fix_controller.cpp:  // cv = kp*err +ki*sumerr +kd*deltaerr
fix_controller.cpp:  // the difference is in the sign and the time integral
fix_controller.cpp:  // 3 terms of PID equation
fix_controller.cpp:  // reset control variable
fix_controller.cpp:/* ---------------------------------------------------------------------- */
fix_controller.cpp:/* ----------------------------------------------------------------------
fix_controller.cpp:------------------------------------------------------------------------- */
fix.cpp:/* ----------------------------------------------------------------------
fix.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix.cpp:------------------------------------------------------------------------- */
fix.cpp:// allocate space for static class instance variable and initialize it
fix.cpp:/* ---------------------------------------------------------------------- */
fix.cpp:  // fix ID, group, and style
fix.cpp:  // ID must be all alphanumeric chars or underscores
fix.cpp:  // reasonable defaults
fix.cpp:  // however, each fix that uses these values should explicitly set them
fix.cpp:  // per-atom virial
fix.cpp:  // set vflag_atom = 0 b/c some fixes grow vatom in grow_arrays()
fix.cpp:  //   which may occur outside of timestepping
fix.cpp:  // KOKKOS per-fix data masks
fix.cpp:/* ---------------------------------------------------------------------- */
fix.cpp:/* ----------------------------------------------------------------------
fix.cpp:------------------------------------------------------------------------- */
fix.cpp:    if (strcmp(arg[iarg],"dynamic/dof") == 0) {
fix.cpp:/* ----------------------------------------------------------------------
fix.cpp:------------------------------------------------------------------------- */
fix.cpp:  eflag_atom = eflag / 2;
fix.cpp:  vflag_atom = vflag / 4;
fix.cpp:  // reallocate per-atom arrays if necessary
fix.cpp:  // zero accumulators
fix.cpp:  // no global energy variable to zero (unlike pair,bond,angle,etc)
fix.cpp:  // fixes tally it individually via fix_modify energy yes and compute_scalar()
fix.cpp:/* ----------------------------------------------------------------------
fix.cpp:------------------------------------------------------------------------- */
fix.cpp:  vflag_atom = vflag / 4;
fix.cpp:  // reallocate per-atom array if necessary
fix.cpp:  // zero accumulators
fix.cpp:/* ----------------------------------------------------------------------
fix.cpp:   tally per-atom energy and global/per-atom virial into accumulators
fix.cpp:   increment per-atom energy of each atom in list by 1/total fraction
fix.cpp:   this method can be used when fix computes energy/forces in post_force()
fix.cpp:------------------------------------------------------------------------- */
fix.cpp:    double fraction = eng/total;
fix.cpp:/* ----------------------------------------------------------------------
fix.cpp:   increment global virial by n/total fraction
fix.cpp:   increment per-atom virial of each atom in list by 1/total fraction
fix.cpp:------------------------------------------------------------------------- */
fix.cpp:    double fraction = n/total;
fix.cpp:    double fraction = 1.0/total;
fix_deform.cpp:/* ----------------------------------------------------------------------
fix_deform.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_deform.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_deform.cpp:------------------------------------------------------------------------- */
fix_deform.cpp:/* ----------------------------------------------------------------------
fix_deform.cpp:------------------------------------------------------------------------- */
fix_deform.cpp:// same as domain.cpp, fix_nvt_sllod.cpp, compute_temp_deform.cpp
fix_deform.cpp:/* ---------------------------------------------------------------------- */
fix_deform.cpp:  // set defaults
fix_deform.cpp:  // parse arguments
fix_deform.cpp:  // read options from end of input line
fix_deform.cpp:  // no x remap effectively moves atoms within box, so set restart_pbc
fix_deform.cpp:  // setup dimflags used by other classes to check for volume-change conflicts
fix_deform.cpp:  // no tensile deformation on shrink-wrapped dims
fix_deform.cpp:  // b/c shrink wrap will change box-length
fix_deform.cpp:  // no tilt deformation on shrink-wrapped 2nd dim
fix_deform.cpp:  // b/c shrink wrap will change tilt factor in domain::reset_box()
fix_deform.cpp:  // apply scaling to FINAL,DELTA,VEL,WIGGLE since they have dist/vel units
fix_deform.cpp:  // for 3,4,5: scaling is in 1st dimension, e.g. x for xz
fix_deform.cpp:  // for VOLUME, setup links to other dims
fix_deform.cpp:  // fixed, dynamic1, dynamic2
fix_deform.cpp:  // set varflag
fix_deform.cpp:  // set initial values at time fix deform is issued
fix_deform.cpp:  // reneighboring only forced if flips can occur due to shape changes
fix_deform.cpp:/* ---------------------------------------------------------------------- */
fix_deform.cpp:  // reset domain's h_rate = 0.0, since this fix may have made it non-zero
fix_deform.cpp:/* ---------------------------------------------------------------------- */
fix_deform.cpp:/* ---------------------------------------------------------------------- */
fix_deform.cpp:  // error if more than one fix deform
fix_deform.cpp:  // domain, fix nvt/sllod, compute temp/deform only work on single h_rate
fix_deform.cpp:  // Kspace setting
fix_deform.cpp:  // elapsed time for entire simulation, including multiple runs if defined
fix_deform.cpp:  // check variables for VARIABLE style
fix_deform.cpp:  // set start/stop values for box size and shape
fix_deform.cpp:  // if single run, start is current values
fix_deform.cpp:  // if multiple runs enabled via run start/stop settings,
fix_deform.cpp:  //   start is value when fix deform was issued
fix_deform.cpp:  // if VARIABLE or NONE, no need to set
fix_deform.cpp:        0.5*set[i].amplitude * sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:        0.5*set[i].amplitude * sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:        set[i].amplitude * sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:      // compute min/max for WIGGLE = extrema tilt factor will ever reach
fix_deform.cpp:            set[i].amplitude*sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:            set[i].amplitude*sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:            set[i].amplitude*sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:            set[i].amplitude*sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:  // if using tilt TRATE, then initial tilt must be non-zero
fix_deform.cpp:  // if yz changes and will cause box flip, then xy cannot be changing
fix_deform.cpp:  // yz = [3], xy = [5]
fix_deform.cpp:  // this is b/c the flips would induce continuous changes in xz
fix_deform.cpp:  //   in order to keep the edge vectors of the flipped shape matrix
fix_deform.cpp:  //   an integer combination of the edge vectors of the unflipped shape matrix
fix_deform.cpp:  // VARIABLE for yz is error, since no way to calculate if box flip occurs
fix_deform.cpp:  // WIGGLE lo/hi flip test is on min/max oscillation limit, not tilt_stop
fix_deform.cpp:  // only trigger actual errors if flipflag is set
fix_deform.cpp:      if (lo/(set[1].hi_start-set[1].lo_start) < -0.5 ||
fix_deform.cpp:          hi/(set[1].hi_start-set[1].lo_start) > 0.5) flag = 1;
fix_deform.cpp:        if (lo/(set[1].hi_stop-set[1].lo_stop) < -0.5 ||
fix_deform.cpp:            hi/(set[1].hi_stop-set[1].lo_stop) > 0.5) flag = 1;
fix_deform.cpp:  // set domain->h_rate values for use by domain and other fixes/computes
fix_deform.cpp:  // initialize all rates to 0.0
fix_deform.cpp:  // cannot set here for TRATE,VOLUME,WIGGLE,VARIABLE since not constant
fix_deform.cpp:        dlo_dt = (set[i].lo_stop - set[i].lo_start) / delt;
fix_deform.cpp:        dhi_dt = (set[i].hi_stop - set[i].hi_start) / delt;
fix_deform.cpp:        h_rate[i] = (set[i].tilt_stop - set[i].tilt_start) / delt;
fix_deform.cpp:  // detect if any rigid fixes exist so rigid bodies can be rescaled
fix_deform.cpp:  // rfix[] = indices to each fix rigid
fix_deform.cpp:/* ----------------------------------------------------------------------
fix_deform.cpp:------------------------------------------------------------------------- */
fix_deform.cpp:/* ---------------------------------------------------------------------- */
fix_deform.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_deform.cpp:  // wrap variable evaluations with clear/add
fix_deform.cpp:  // set new box size
fix_deform.cpp:  // for NONE, target is current box size
fix_deform.cpp:  // for TRATE, set target directly based on current time, also set h_rate
fix_deform.cpp:  // for WIGGLE, set target directly based on current time, also set h_rate
fix_deform.cpp:  // for VARIABLE, set target directly via variable eval, also set h_rate
fix_deform.cpp:  // for others except VOLUME, target is linear value between start and stop
fix_deform.cpp:        0.5*set[i].amplitude * sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:        0.5*set[i].amplitude * sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:      h_rate[i] = TWOPI/set[i].tperiod * set[i].amplitude *
fix_deform.cpp:        cos(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:  // set new box size for VOLUME dims that are linked to other dims
fix_deform.cpp:  // NOTE: still need to set h_rate for these dims
fix_deform.cpp:        0.5*(set[i].vol_start /
fix_deform.cpp:              set[set[i].dynamic1].lo_target) /
fix_deform.cpp:        0.5*(set[i].vol_start /
fix_deform.cpp:              set[set[i].dynamic1].lo_target) /
fix_deform.cpp:        0.5*(set[i].vol_start /
fix_deform.cpp:              set[set[i].dynamic1].lo_target) /
fix_deform.cpp:        0.5*(set[i].vol_start /
fix_deform.cpp:              set[set[i].dynamic1].lo_target) /
fix_deform.cpp:        0.5*sqrt(set[i].vol_start /
fix_deform.cpp:                  set[set[i].dynamic1].lo_target) /
fix_deform.cpp:        0.5*sqrt(set[i].vol_start /
fix_deform.cpp:                  set[set[i].dynamic1].lo_target) /
fix_deform.cpp:  // for triclinic, set new box shape
fix_deform.cpp:  // for NONE, target is current tilt
fix_deform.cpp:  // for TRATE, set target directly based on current time. also set h_rate
fix_deform.cpp:  // for WIGGLE, set target directly based on current time. also set h_rate
fix_deform.cpp:  // for VARIABLE, set target directly via variable eval. also set h_rate
fix_deform.cpp:  // for other styles, target is linear value between start and stop values
fix_deform.cpp:          set[i].amplitude * sin(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:        h_rate[i] = TWOPI/set[i].tperiod * set[i].amplitude *
fix_deform.cpp:          cos(TWOPI*delt/set[i].tperiod);
fix_deform.cpp:      // tilt_target can be large positive or large negative value
fix_deform.cpp:      // add/subtract box lengths until tilt_target is closest to current value
fix_deform.cpp:      double current = h[i]/h[idenom];
fix_deform.cpp:      while (set[i].tilt_target/denom - current > 0.0)
fix_deform.cpp:      while (set[i].tilt_target/denom - current < 0.0)
fix_deform.cpp:      if (fabs(set[i].tilt_target/denom - 1.0 - current) <
fix_deform.cpp:          fabs(set[i].tilt_target/denom - current))
fix_deform.cpp:  // if any tilt ratios exceed 0.5, set flip = 1 and compute new tilt values
fix_deform.cpp:  // do not flip in x or y if non-periodic (can tilt but not flip)
fix_deform.cpp:  //   this is b/c the box length would be changed (dramatically) by flip
fix_deform.cpp:  // if yz tilt exceeded, adjust C vector by one B vector
fix_deform.cpp:  // if xz tilt exceeded, adjust C vector by one A vector
fix_deform.cpp:  // if xy tilt exceeded, adjust B vector by one A vector
fix_deform.cpp:  // check yz first since it may change xz, then xz check comes after
fix_deform.cpp:  // flip is performed on next timestep, before reneighboring in pre-exchange()
fix_deform.cpp:    double xprdinv = 1.0 / xprd;
fix_deform.cpp:    double yprdinv = 1.0 / yprd;
fix_deform.cpp:  // convert atoms and rigid bodies to lamda coords
fix_deform.cpp:  // reset global and local box to new size/shape
fix_deform.cpp:  // only if deform fix is controlling the dimension
fix_deform.cpp:  // convert atoms and rigid bodies back to box coords
fix_deform.cpp:  // redo KSpace coeffs since box has changed
fix_deform.cpp:/* ---------------------------------------------------------------------- */
fix_deform.cpp:/* ----------------------------------------------------------------------
fix_deform.cpp:------------------------------------------------------------------------- */
fix_deprecated.cpp:/* ----------------------------------------------------------------------
fix_deprecated.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_deprecated.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_deprecated.cpp:------------------------------------------------------------------------- */
fix_deprecated.cpp:/* ---------------------------------------------------------------------- */
fix_deprecated.cpp:  if (strncmp(style,"ave/spatial",11) == 0) {
fix_deprecated.cpp:    "NOTE: The fix styles 'ave/spatial' and 'ave/spatial/sphere' have been replaced\n"
fix_deprecated.cpp:    "by the more general fix ave/chunk and compute chunk/atom commands.\n"
fix_deprecated.cpp:    "All ave/spatial and ave/spatial/sphere functionality is available in these\n"
fix_deprecated.cpp:    "new commands. These ave/spatial keywords & options are part of fix ave/chunk:\n"
fix_deprecated.cpp:    "These ave/spatial keywords & options for binning are part of compute chunk/atom:\n"
fix_drag.cpp:/* ----------------------------------------------------------------------
fix_drag.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_drag.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_drag.cpp:------------------------------------------------------------------------- */
fix_drag.cpp:/* ---------------------------------------------------------------------- */
fix_drag.cpp:/* ---------------------------------------------------------------------- */
fix_drag.cpp:/* ---------------------------------------------------------------------- */
fix_drag.cpp:/* ---------------------------------------------------------------------- */
fix_drag.cpp:/* ---------------------------------------------------------------------- */
fix_drag.cpp:  // apply drag force to atoms in group of magnitude f_mag
fix_drag.cpp:  // apply in direction (r-r0) if atom is further than delta away
fix_drag.cpp:        prefactor = f_mag/r;
fix_drag.cpp:/* ---------------------------------------------------------------------- */
fix_drag.cpp:/* ----------------------------------------------------------------------
fix_drag.cpp:------------------------------------------------------------------------- */
fix_drag.cpp:  // only sum across procs one time
fix_dt_reset.cpp:/* ----------------------------------------------------------------------
fix_dt_reset.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_dt_reset.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_dt_reset.cpp:------------------------------------------------------------------------- */
fix_dt_reset.cpp:/* ---------------------------------------------------------------------- */
fix_dt_reset.cpp:  if (narg < 7) error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:  // set time_depend, else elapsed time accumulation can be messed up
fix_dt_reset.cpp:  if (nevery <= 0) error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:  if (minbound && tmin < 0.0) error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:  if (maxbound && tmax < 0.0) error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:    error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:  if (xmax <= 0.0) error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:      else error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:    } else error->all(FLERR,"Illegal fix dt/reset command");
fix_dt_reset.cpp:  // setup scaling, based on xlattice parameter
fix_dt_reset.cpp:  // initializations
fix_dt_reset.cpp:/* ---------------------------------------------------------------------- */
fix_dt_reset.cpp:/* ---------------------------------------------------------------------- */
fix_dt_reset.cpp:  // set rRESPA flag
fix_dt_reset.cpp:  // check for DCD or XTC dumps
fix_dt_reset.cpp:                     "Dump dcd/xtc timestamp may be wrong with fix dt/reset");
fix_dt_reset.cpp:/* ---------------------------------------------------------------------- */
fix_dt_reset.cpp:/* ---------------------------------------------------------------------- */
fix_dt_reset.cpp:  // compute vmax and amax of any atom in group
fix_dt_reset.cpp:      if (rmass) massinv = 1.0/rmass[i];
fix_dt_reset.cpp:      else massinv = 1.0/mass[type[i]];
fix_dt_reset.cpp:      if (vsq > 0.0) dtv = xmax/sqrt(vsq);
fix_dt_reset.cpp:      if (fsq > 0.0) dtf = sqrt(2.0*xmax/(ftm2v*sqrt(fsq)*massinv));
fix_dt_reset.cpp:      if (delr > xmax) dt *= xmax/delr;
fix_dt_reset.cpp:  // if timestep didn't change, just return
fix_dt_reset.cpp:  // else reset update->dt and other classes that depend on it
fix_dt_reset.cpp:  // rRESPA, pair style, fixes
fix_dt_reset.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:/* ----------------------------------------------------------------------
fix_enforce2d.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_enforce2d.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_enforce2d.cpp:------------------------------------------------------------------------- */
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:  // list of fixes with enforce2d methods
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:  // for systems with omega/angmom/torque, zero x and y components
fix_enforce2d.cpp:  // invoke other fixes that enforce 2d
fix_enforce2d.cpp:  // fix rigid variants
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_enforce2d.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_external.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:  if (strcmp(arg[3],"pf/callback") == 0) {
fix_external.cpp:  } else if (strcmp(arg[3],"pf/array") == 0) {
fix_external.cpp:  // perform initial allocation of atom-based array
fix_external.cpp:  // register with Atom class
fix_external.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:  // unregister callbacks to this fix from Atom class
fix_external.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:/* --------------------------------------------------------------------- */
fix_external.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:  // invoke the callback in driver program
fix_external.cpp:  // it will fill fexternal with forces
fix_external.cpp:  // add forces from fexternal to atoms in group
fix_external.cpp:/* ---------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_external.cpp:/* ----------------------------------------------------------------------
fix_external.cpp:------------------------------------------------------------------------- */
fix_force_spin.cpp:/* ----------------------------------------------------------------------
fix_force_spin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_force_spin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_force_spin.cpp:------------------------------------------------------------------------- */
fix_force_spin.cpp:/* ---------------------------------------------------------------------- */
fix_force_spin.cpp:  // 7 arguments for a force/spin fix command:
fix_force_spin.cpp:  //(fix  ID  group  force/spin  magnitude (T or eV)  style (zeeman or anisotropy)  direction (3 cartesian coordinates) 
fix_force_spin.cpp:  //Magnetic interactions only coded for cartesian coordinates
fix_force_spin.cpp:  } else error->all(FLERR,"Illegal fix force/spin command");
fix_force_spin.cpp:  degree2rad = MY_PI/180.0;
fix_force_spin.cpp:/* ---------------------------------------------------------------------- */
fix_force_spin.cpp:/* ---------------------------------------------------------------------- */
fix_force_spin.cpp:/* ---------------------------------------------------------------------- */
fix_force_spin.cpp:  double hbar = force->hplanck/MY_2PI; //eV/(rad.THz)
fix_force_spin.cpp:  double mub = 5.78901e-5; //in eV/T 
fix_force_spin.cpp:  double gyro = mub/hbar; //in rad.THz/T  
fix_force_spin.cpp:  H_field *= gyro; //in rad.THz
fix_force_spin.cpp:  Ka /= hbar; //in rad.THz
fix_force_spin.cpp:  // check variables
fix_force_spin.cpp:  // set magnetic field components once and for all
fix_force_spin.cpp:/* ---------------------------------------------------------------------- */
fix_force_spin.cpp:/* ---------------------------------------------------------------------- */
fix_force_spin.cpp:  // update gravity due to variables
fix_force_spin.cpp:    set_magneticforce(); //Update value of the mag. field if time-dependent
fix_force_spin.cpp:/* ---------------------------------------------------------------------- */
fix_force_spin.cpp:/* ---------------------------------------------------------------------- */
fix_force_spin.cpp://No acceleration for magnetic EOM, only a "magnetic force" 
fix_force_spin.cpp:/* ----------------------------------------------------------------------
fix_force_spin.cpp:------------------------------------------------------------------------- */
fix_force_spin.cpp:  // only sum across procs one time
fix_gravity.cpp:/* ----------------------------------------------------------------------
fix_gravity.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_gravity.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_gravity.cpp:------------------------------------------------------------------------- */
fix_gravity.cpp:/* ---------------------------------------------------------------------- */
fix_gravity.cpp:  degree2rad = MY_PI/180.0;
fix_gravity.cpp:/* ---------------------------------------------------------------------- */
fix_gravity.cpp:/* ---------------------------------------------------------------------- */
fix_gravity.cpp:/* ---------------------------------------------------------------------- */
fix_gravity.cpp:  // check variables
fix_gravity.cpp:  // set gravity components once and for all
fix_gravity.cpp:/* ---------------------------------------------------------------------- */
fix_gravity.cpp:/* ---------------------------------------------------------------------- */
fix_gravity.cpp:  // update gravity due to variables
fix_gravity.cpp:/* ---------------------------------------------------------------------- */
fix_gravity.cpp:/* ---------------------------------------------------------------------- */
fix_gravity.cpp:      xgrav = xdir/length;
fix_gravity.cpp:      ygrav = ydir/length;
fix_gravity.cpp:      zgrav = zdir/length;
fix_gravity.cpp:      xgrav = xdir/length;
fix_gravity.cpp:      ygrav = ydir/length;
fix_gravity.cpp:/* ----------------------------------------------------------------------
fix_gravity.cpp:------------------------------------------------------------------------- */
fix_gravity.cpp:  // only sum across procs one time
fix_group.cpp:/* ----------------------------------------------------------------------
fix_group.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_group.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_group.cpp:------------------------------------------------------------------------- */
fix_group.cpp:/* ---------------------------------------------------------------------- */
fix_group.cpp:  // dgroupbit = bitmask of dynamic group
fix_group.cpp:  // group ID is last part of fix ID
fix_group.cpp:  // process optional args
fix_group.cpp:/* ---------------------------------------------------------------------- */
fix_group.cpp:/* ---------------------------------------------------------------------- */
fix_group.cpp:/* ---------------------------------------------------------------------- */
fix_group.cpp:  // parent group cannot be dynamic
fix_group.cpp:  // else order of FixGroup fixes would matter
fix_group.cpp:  // set current indices for region and variable
fix_group.cpp:  // warn if any FixGroup is not at tail end of all post_integrate fixes
fix_group.cpp:/* ----------------------------------------------------------------------
fix_group.cpp:------------------------------------------------------------------------- */
fix_group.cpp:/* ---------------------------------------------------------------------- */
fix_group.cpp:  // only assign atoms to group on steps that are multiples of nevery
fix_group.cpp:/* ---------------------------------------------------------------------- */
fix_group.cpp:/* ---------------------------------------------------------------------- */
fix_group.cpp:  // invoke atom-style variable if defined
fix_group.cpp:    memory->create(var,nlocal,"fix/group:varvalue");
fix_group.cpp:  // update region in case it has a variable dependence or is dynamic
fix_group.cpp:  // set mask for each atom
fix_group.cpp:  // only in group if in parent group, in region, variable is non-zero
fix_group.cpp:  // if compute, fix, etc needs updated masks of ghost atoms,
fix_group.cpp:  // it must do forward_comm() to update them
fix_halt.cpp:/* ----------------------------------------------------------------------
fix_halt.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_halt.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_halt.cpp:------------------------------------------------------------------------- */
fix_halt.cpp:/* ---------------------------------------------------------------------- */
fix_halt.cpp:  // comparison args
fix_halt.cpp:  // parse optional args
fix_halt.cpp:  // add nfirst to all computes that store invocation times
fix_halt.cpp:  // since don't know a priori which are invoked via variables by this fix
fix_halt.cpp:  // once in end_of_step() can set timestep for ones actually invoked
fix_halt.cpp:    const bigint nfirst = (update->ntimestep/nevery)*nevery + nevery;
fix_halt.cpp:/* ---------------------------------------------------------------------- */
fix_halt.cpp:/* ---------------------------------------------------------------------- */
fix_halt.cpp:/* ---------------------------------------------------------------------- */
fix_halt.cpp:  // set ivar from current variable list
fix_halt.cpp:  // settings used by TLIMIT
fix_halt.cpp:  nextstep = (update->ntimestep/nevery)*nevery + nevery;
fix_halt.cpp:/* ---------------------------------------------------------------------- */
fix_halt.cpp:  // variable evaluation may invoke computes so wrap with clear/add
fix_halt.cpp:  // check if halt is triggered, else just return
fix_halt.cpp:  // hard halt -> exit LAMMPS
fix_halt.cpp:  // soft/continue halt -> trigger timer to break from run loop
fix_halt.cpp:  // print message with ID of fix halt in case multiple instances
fix_halt.cpp:/* ----------------------------------------------------------------------
fix_halt.cpp:------------------------------------------------------------------------- */
fix_halt.cpp:  // continue halt -> subsequent runs are allowed
fix_halt.cpp:/* ----------------------------------------------------------------------
fix_halt.cpp:------------------------------------------------------------------------- */
fix_halt.cpp:/* ----------------------------------------------------------------------
fix_halt.cpp:   first project to 1/2 the run time, thereafter to end of run
fix_halt.cpp:------------------------------------------------------------------------- */
fix_halt.cpp:      static_cast<bigint> (tratio*value/cpu * elapsed);
fix_halt.cpp:    nextstep = (final/nevery)*nevery + nevery;
fix_heat.cpp:/* ----------------------------------------------------------------------
fix_heat.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_heat.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_heat.cpp:------------------------------------------------------------------------- */
fix_heat.cpp:/* ----------------------------------------------------------------------
fix_heat.cpp:------------------------------------------------------------------------- */
fix_heat.cpp:/* ---------------------------------------------------------------------- */
fix_heat.cpp:  // optional args
fix_heat.cpp:/* ---------------------------------------------------------------------- */
fix_heat.cpp:/* ---------------------------------------------------------------------- */
fix_heat.cpp:/* ---------------------------------------------------------------------- */
fix_heat.cpp:  // set index and check validity of region
fix_heat.cpp:  // check variable
fix_heat.cpp:  // cannot have 0 atoms in group
fix_heat.cpp:/* ---------------------------------------------------------------------- */
fix_heat.cpp:  // reallocate per-atom arrays if necessary
fix_heat.cpp:  // evaluate variable
fix_heat.cpp:  // vcm = center-of-mass velocity of scaled atoms
fix_heat.cpp:  // add heat via scale factor on velocities for CONSTANT and EQUAL cases
fix_heat.cpp:  // scale = velocity scale factor to accomplish eflux change in energy
fix_heat.cpp:  // vsub = velocity subtracted from each atom to preserve momentum
fix_heat.cpp:  // overall KE cannot go negative
fix_heat.cpp:      (ke + heat - 0.5*vcmsq*masstotal)/(ke - 0.5*vcmsq*masstotal);
fix_heat.cpp:  // add heat via per-atom scale factor on velocities for ATOM case
fix_heat.cpp:  // vscale = velocity scale factor to accomplish eflux change in energy
fix_heat.cpp:  // vsub = velocity subtracted from each atom to preserve momentum
fix_heat.cpp:  // KE of an atom cannot go negative
fix_heat.cpp:            (ke + heat - 0.5*vcmsq*masstotal)/(ke - 0.5*vcmsq*masstotal);
fix_heat.cpp:      vsub[0] /= masstotal;
fix_heat.cpp:      vsub[1] /= masstotal;
fix_heat.cpp:      vsub[2] /= masstotal;
fix_heat.cpp:            (ke + heat - 0.5*vcmsq*masstotal)/(ke - 0.5*vcmsq*masstotal);
fix_heat.cpp:      vsub[0] /= masstotal;
fix_heat.cpp:      vsub[1] /= masstotal;
fix_heat.cpp:      vsub[2] /= masstotal;
fix_heat.cpp:/* ---------------------------------------------------------------------- */
fix_heat.cpp:    else average_scale = scale_sum_all/static_cast<double>(ncount_all);
fix_heat.cpp:/* ----------------------------------------------------------------------
fix_heat.cpp:------------------------------------------------------------------------- */
fix_indent.cpp:/* ----------------------------------------------------------------------
fix_indent.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_indent.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_indent.cpp:------------------------------------------------------------------------- */
fix_indent.cpp:/* ----------------------------------------------------------------------
fix_indent.cpp:------------------------------------------------------------------------- */
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:  k3 = k/3.0;
fix_indent.cpp:  // read options from end of input line
fix_indent.cpp:  // setup scaling
fix_indent.cpp:  // apply scaling factors to geometry
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:  // indenter values, 0 = energy, 1-3 = force components
fix_indent.cpp:  // wrap variable evaluations with clear/add
fix_indent.cpp:  // spherical indenter
fix_indent.cpp:    // ctr = current indenter center
fix_indent.cpp:    // remap into periodic box
fix_indent.cpp:        fx = delx*fmag/r;
fix_indent.cpp:        fy = dely*fmag/r;
fix_indent.cpp:        fz = delz*fmag/r;
fix_indent.cpp:  // cylindrical indenter
fix_indent.cpp:    // ctr = current indenter axis
fix_indent.cpp:    // remap into periodic box
fix_indent.cpp:    // 3rd coord is just near box for remap(), since isn't used
fix_indent.cpp:        fx = delx*fmag/r;
fix_indent.cpp:        fy = dely*fmag/r;
fix_indent.cpp:        fz = delz*fmag/r;
fix_indent.cpp:  // planar indenter
fix_indent.cpp:    // plane = current plane position
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:/* ---------------------------------------------------------------------- */
fix_indent.cpp:/* ----------------------------------------------------------------------
fix_indent.cpp:------------------------------------------------------------------------- */
fix_indent.cpp:  // only sum across procs one time
fix_indent.cpp:/* ----------------------------------------------------------------------
fix_indent.cpp:------------------------------------------------------------------------- */
fix_indent.cpp:  // only sum across procs one time
fix_indent.cpp:/* ----------------------------------------------------------------------
fix_indent.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_langevin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:#define SINERTIA 0.4          // moment of inertia prefactor for sphere
fix_langevin.cpp:#define EINERTIA 0.2          // moment of inertia prefactor for ellipsoid
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:  // initialize Marsaglia RNG with processor-unique seed
fix_langevin.cpp:  // allocate per-type arrays for force prefactors
fix_langevin.cpp:  // optional args
fix_langevin.cpp:  // set temperature = NULL, user can override via fix_modify if wants bias
fix_langevin.cpp:  // flangevin is unallocated until first call to setup()
fix_langevin.cpp:  // compute_scalar checks for this and returns 0.0 
fix_langevin.cpp:  // if flangevin_allocated is not set
fix_langevin.cpp:  // setup atom-based array for franprev
fix_langevin.cpp:  // register with Atom class
fix_langevin.cpp:  // no need to set peratom_flag, b/c data is for internal use only
fix_langevin.cpp:  // initialize franprev to zero
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:  // check variable
fix_langevin.cpp:  // if oflag or ascale set, check that all group particles are finite-size
fix_langevin.cpp:  // set force prefactors
fix_langevin.cpp:      gfactor1[i] = -atom->mass[i] / t_period / force->ftm2v;
fix_langevin.cpp:        sqrt(24.0*force->boltz/t_period/update->dt/force->mvv2e) /
fix_langevin.cpp:      gfactor1[i] *= 1.0/ratio[i];
fix_langevin.cpp:      gfactor2[i] *= 1.0/sqrt(ratio[i]);
fix_langevin.cpp:  if (gjfflag) gjffac = 1.0/(1.0+update->dt/2.0/t_period);
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:  // enumerate all 2^6 possibilities for template parameters
fix_langevin.cpp:  // this avoids testing them inside inner loop:
fix_langevin.cpp:  // TSTYLEATOM, GJF, TALLY, BIAS, RMASS, ZERO
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:  // apply damping and thermostat to atoms in group
fix_langevin.cpp:  // for Tp_TSTYLEATOM:
fix_langevin.cpp:  //   use per-atom per-coord target temperature
fix_langevin.cpp:  // for Tp_GJF:
fix_langevin.cpp:  //   use Gronbech-Jensen/Farago algorithm
fix_langevin.cpp:  //   else use regular algorithm
fix_langevin.cpp:  // for Tp_TALLY:
fix_langevin.cpp:  //   store drag plus random forces in flangevin[nlocal][3]
fix_langevin.cpp:  // for Tp_BIAS:
fix_langevin.cpp:  //   calculate temperature since some computes require temp
fix_langevin.cpp:  //   computed on current nlocal atoms to remove bias
fix_langevin.cpp:  //   test v = 0 since some computes mask non-participating atoms via v = 0
fix_langevin.cpp:  //   and added force has extra term not multiplied by v = 0
fix_langevin.cpp:  // for Tp_RMASS:
fix_langevin.cpp:  //   use per-atom masses
fix_langevin.cpp:  //   else use per-type masses
fix_langevin.cpp:  // for Tp_ZERO:
fix_langevin.cpp:  //   sum random force over all atoms in group
fix_langevin.cpp:  //   subtract sum/count from each atom in group
fix_langevin.cpp:  // reallocate flangevin if necessary
fix_langevin.cpp:	gamma1 = -rmass[i] / t_period / ftm2v;
fix_langevin.cpp:	gamma2 = sqrt(rmass[i]) * sqrt(24.0*boltz/t_period/dt/mvv2e) / ftm2v;
fix_langevin.cpp:	gamma1 *= 1.0/ratio[type[i]];
fix_langevin.cpp:	gamma2 *= 1.0/sqrt(ratio[type[i]]) * tsqrt;
fix_langevin.cpp:  // set total force to zero
fix_langevin.cpp:    fsumall[0] /= count;
fix_langevin.cpp:    fsumall[1] /= count;
fix_langevin.cpp:    fsumall[2] /= count;
fix_langevin.cpp:  // thermostat omega and angmom
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_langevin.cpp:  // if variable temp, evaluate variable, wrap with clear/add
fix_langevin.cpp:  // reallocate tforce array if necessary
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:  // rescale gamma1/gamma2 by 10/3 & sqrt(10/3) for spherical particles
fix_langevin.cpp:  // does not affect rotational thermosatting
fix_langevin.cpp:  // gives correct rotational diffusivity behavior
fix_langevin.cpp:  double tendivthree = 10.0/3.0;
fix_langevin.cpp:      gamma1 = -tendivthree*inertiaone / t_period / ftm2v;
fix_langevin.cpp:      gamma2 = sqrt(inertiaone) * sqrt(80.0*boltz/t_period/dt/mvv2e) / ftm2v;
fix_langevin.cpp:      gamma1 *= 1.0/ratio[type[i]];
fix_langevin.cpp:      gamma2 *= 1.0/sqrt(ratio[type[i]]) * tsqrt;
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:  // rescale gamma1/gamma2 by ascale for aspherical particles
fix_langevin.cpp:  // does not affect rotational thermosatting
fix_langevin.cpp:  // gives correct rotational diffusivity behavior if (nearly) spherical
fix_langevin.cpp:  // any value will be incorrect for rotational diffusivity if aspherical
fix_langevin.cpp:      gamma1 = -ascale / t_period / ftm2v;
fix_langevin.cpp:      gamma2 = sqrt(ascale*24.0*boltz/t_period/dt/mvv2e) / ftm2v;
fix_langevin.cpp:      gamma1 *= 1.0/ratio[type[i]];
fix_langevin.cpp:      gamma2 *= 1.0/sqrt(ratio[type[i]]) * tsqrt;
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:        sqrt(24.0*force->boltz/t_period/update->dt/force->mvv2e) /
fix_langevin.cpp:      gfactor2[i] *= 1.0/sqrt(ratio[i]);
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin.cpp:  // capture the very first energy transfer to thermal reservoir
fix_langevin.cpp:  // convert midstep energy back to previous fullstep energy
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin.cpp:/* ----------------------------------------------------------------------
fix_langevin.cpp:------------------------------------------------------------------------- */
fix_langevin_spin.cpp:/* ----------------------------------------------------------------------
fix_langevin_spin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_langevin_spin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_langevin_spin.cpp:------------------------------------------------------------------------- */
fix_langevin_spin.cpp:/* ----------------------------------------------------------------------
fix_langevin_spin.cpp:------------------------------------------------------------------------- */
fix_langevin_spin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin_spin.cpp:  if (narg != 7) error->all(FLERR,"Illegal fix langevin/spin command");
fix_langevin_spin.cpp:  if (alpha_t < 0.0) error->all(FLERR,"Fix langevin/spin transverse damping must be >= 0.0");
fix_langevin_spin.cpp:  if (alpha_l < 0.0) error->all(FLERR,"Fix langevin/spin transverse damping must be >= 0.0");
fix_langevin_spin.cpp:  if (seed <= 0) error->all(FLERR,"Illegal fix langevin/spin seed must be > 0");
fix_langevin_spin.cpp:  // initialize Marsaglia RNG with processor-unique seed
fix_langevin_spin.cpp:  //random = new RanMars(lmp,seed + comm->me);
fix_langevin_spin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin_spin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin_spin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin_spin.cpp:  // warn if any fix comes after this one  
fix_langevin_spin.cpp:     if (strcmp("force/spin",modify->fix[i]->style)==0) flag_force = MAX(flag_force,i);
fix_langevin_spin.cpp:     if (strcmp("langevin/spin",modify->fix[i]->style)==0) flag_lang = i;
fix_langevin_spin.cpp:  if (flag_force >= flag_lang) error->all(FLERR,"Fix langevin/spin should come after all other spin fixes");  
fix_langevin_spin.cpp:  Gil_factor = 1.0/(1.0+(alpha_t)*(alpha_t));
fix_langevin_spin.cpp:  double hbar = force->hplanck/MY_2PI; //eV/(rad.THz)
fix_langevin_spin.cpp:  D = (MY_2PI*Gil_factor*kb*temp)/hbar/dts;
fix_langevin_spin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin_spin.cpp:/* ---------------------------------------------------------------------- */
fix_langevin_spin.cpp:  // add the damping to the effective field of each spin
fix_langevin_spin.cpp:		cpx = fmy*sz - fmz*sy;//Computing cross product
fix_langevin_spin.cpp:		fmx -= alpha_t*cpx;//Taking the damping value away
fix_langevin_spin.cpp:  //apply thermal effects adding random fields to fm
fix_langevin_spin.cpp:		rx = sigma*random->gaussian();//Drawing random distributions
fix_langevin_spin.cpp:        	fm[i][0] += rx;//Adding random field
fix_langevin_spin.cpp:                fm[i][0] *= Gil_factor;//Multiplying by Gilbert's prefactor 
fix_langevin_spin.cpp:/* ---------------------------------------------------------------------- */
fix_lineforce.cpp:/* ----------------------------------------------------------------------
fix_lineforce.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_lineforce.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_lineforce.cpp:------------------------------------------------------------------------- */
fix_lineforce.cpp:/* ---------------------------------------------------------------------- */
fix_lineforce.cpp:  xdir /= len;
fix_lineforce.cpp:  ydir /= len;
fix_lineforce.cpp:  zdir /= len;
fix_lineforce.cpp:/* ---------------------------------------------------------------------- */
fix_lineforce.cpp:/* ---------------------------------------------------------------------- */
fix_lineforce.cpp:/* ---------------------------------------------------------------------- */
fix_lineforce.cpp:/* ---------------------------------------------------------------------- */
fix_lineforce.cpp:/* ---------------------------------------------------------------------- */
fix_lineforce.cpp:/* ---------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_minimize.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ---------------------------------------------------------------------- */
fix_minimize.cpp:  // register callback to this fix from Atom class
fix_minimize.cpp:  // don't perform initial allocation here, must wait until add_vector()
fix_minimize.cpp:/* ---------------------------------------------------------------------- */
fix_minimize.cpp:  // unregister callbacks to this fix from Atom class
fix_minimize.cpp:  // delete locally stored data
fix_minimize.cpp:/* ---------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:   allocate/initialize memory for a new vector with N elements per atom
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_minimize.cpp:/* ----------------------------------------------------------------------
fix_minimize.cpp:------------------------------------------------------------------------- */
fix_momentum.cpp:/* ----------------------------------------------------------------------
fix_momentum.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_momentum.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_momentum.cpp:------------------------------------------------------------------------- */
fix_momentum.cpp:/* ----------------------------------------------------------------------
fix_momentum.cpp:------------------------------------------------------------------------- */
fix_momentum.cpp:/* ---------------------------------------------------------------------- */
fix_momentum.cpp:/* ---------------------------------------------------------------------- */
fix_momentum.cpp:/* ---------------------------------------------------------------------- */
fix_momentum.cpp:/* ---------------------------------------------------------------------- */
fix_momentum.cpp:  // do nothing is group is empty, i.e. mass is zero;
fix_momentum.cpp:  // compute kinetic energy before momentum removal, if needed
fix_momentum.cpp:    // adjust velocities by vcm to zero linear momentum
fix_momentum.cpp:    // only adjust a component if flag is set
fix_momentum.cpp:    // adjust velocities to zero omega
fix_momentum.cpp:    // vnew_i = v_i - w x r_i
fix_momentum.cpp:    // must use unwrapped coords to compute r_i correctly
fix_momentum.cpp:  // compute kinetic energy after momentum removal, if needed
fix_momentum.cpp:    if (ekin_new != 0.0) factor = sqrt(ekin_old/ekin_new);
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_move.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:#define INERTIA 0.2          // moment of inertia prefactor for ellipsoid
fix_move.cpp:/* ---------------------------------------------------------------------- */
fix_move.cpp:  // parse args
fix_move.cpp:  // optional args
fix_move.cpp:  // error checks and warnings
fix_move.cpp:  // setup scaling and apply scaling factors to velocity & amplitude
fix_move.cpp:  // set omega_rotate from period
fix_move.cpp:  if (mstyle == WIGGLE || mstyle == ROTATE) omega_rotate = MY_2PI / period;
fix_move.cpp:  // runit = unit vector along rotation axis
fix_move.cpp:    runit[0] = axis[0]/len;
fix_move.cpp:    runit[1] = axis[1]/len;
fix_move.cpp:    runit[2] = axis[2]/len;
fix_move.cpp:  // set flags for extra attributes particles may store
fix_move.cpp:  // relevant extra attributes = omega, angmom, theta, quat
fix_move.cpp:  // perform initial allocation of atom-based array
fix_move.cpp:  // register with Atom class
fix_move.cpp:  // AtomVec pointers to retrieve per-atom storage of extra quantities
fix_move.cpp:  // xoriginal = initial unwrapped positions of atoms
fix_move.cpp:  // toriginal = initial theta of lines
fix_move.cpp:  // qoriginal = initial quat of extended particles
fix_move.cpp:  // nrestart = size of per-atom restart data
fix_move.cpp:  // nrestart = 1 + xorig + torig + qorig
fix_move.cpp:  // time origin for movement = current timestep
fix_move.cpp:/* ---------------------------------------------------------------------- */
fix_move.cpp:  // unregister callbacks to this fix from Atom class
fix_move.cpp:  // delete locally stored arrays
fix_move.cpp:/* ---------------------------------------------------------------------- */
fix_move.cpp:/* ---------------------------------------------------------------------- */
fix_move.cpp:  // set indices and style of all variables
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:  // for linear: X = X0 + V*dt
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:  // for wiggle: X = X0 + A sin(w*dt)
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:  // for rotate by right-hand rule around omega:
fix_move.cpp:  // P = point = vector = point of rotation
fix_move.cpp:  // R = vector = axis of rotation
fix_move.cpp:  // w = omega of rotation (from period)
fix_move.cpp:  // X0 = xoriginal = initial coord of atom
fix_move.cpp:  // R0 = runit = unit vector for R
fix_move.cpp:  // D = X0 - P = vector from P to X0
fix_move.cpp:  // C = (D dot R0) R0 = projection of atom coord onto R line
fix_move.cpp:  // A = D - C = vector from R line to X0
fix_move.cpp:  // B = R0 cross A = vector perp to A in plane of rotation
fix_move.cpp:  // A,B define plane of circular rotation around R line
fix_move.cpp:  // X = P + C + A cos(w*dt) + B sin(w*dt)
fix_move.cpp:  // V = w R0 cross (A cos(w*dt) + B sin(w*dt))
fix_move.cpp:        // set any extra attributes affected by rotation
fix_move.cpp:          // omega for spheres, lines, tris
fix_move.cpp:          // angmom for ellipsoids, tris, and bodies
fix_move.cpp:          // theta for lines
fix_move.cpp:          // quats for ellipsoids, tris, and bodies
fix_move.cpp:  // for variable: compute x,v from variables
fix_move.cpp:  // NOTE: also allow for changes to extra attributes?
fix_move.cpp:  //       omega, angmom, theta, quat
fix_move.cpp:  //       only necessary if prescribed motion involves rotation
fix_move.cpp:    // reallocate displace and velocity arrays as necessary
fix_move.cpp:    // pre-compute variable values, wrap with clear/add
fix_move.cpp:    // update x,v
fix_move.cpp:            dtfm = dtf / rmass[i];
fix_move.cpp:            dtfm = dtf / mass[type[i]];
fix_move.cpp:            dtfm = dtf / rmass[i];
fix_move.cpp:            dtfm = dtf / mass[type[i]];
fix_move.cpp:            dtfm = dtf / rmass[i];
fix_move.cpp:            dtfm = dtf / mass[type[i]];
fix_move.cpp:            dtfm = dtf / rmass[i];
fix_move.cpp:            dtfm = dtf / mass[type[i]];
fix_move.cpp:            dtfm = dtf / rmass[i];
fix_move.cpp:            dtfm = dtf / mass[type[i]];
fix_move.cpp:            dtfm = dtf / rmass[i];
fix_move.cpp:            dtfm = dtf / mass[type[i]];
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:          dtfm = dtf / rmass[i];
fix_move.cpp:          dtfm = dtf / mass[type[i]];
fix_move.cpp:/* ---------------------------------------------------------------------- */
fix_move.cpp:  // outermost level - update v and x
fix_move.cpp:  // all other levels - nothing
fix_move.cpp:/* ---------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:  // particle not in group
fix_move.cpp:  // current time still equal fix creation time
fix_move.cpp:  // backup particle to time_origin
fix_move.cpp:    // set theta and quat extra attributes affected by rotation
fix_move.cpp:      // theta for lines
fix_move.cpp:        toriginal[i] = theta - 0.0;  // NOTE: edit this line
fix_move.cpp:      // quats for ellipsoids, tris, and bodies
fix_move.cpp:          // qoriginal = f(quat,-delta);   // NOTE: edit this line
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:  // skip to Nth set of extra values
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ----------------------------------------------------------------------
fix_move.cpp:------------------------------------------------------------------------- */
fix_move.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nh.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp: ---------------------------------------------------------------------- */
fix_nh.cpp:  if (narg < 4) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:  // default values
fix_nh.cpp:  // turn on tilt factor scaling, whenever applicable
fix_nh.cpp:  // set fixed-point to default = center of cell
fix_nh.cpp:  // used by FixNVTSllod to preserve non-default value
fix_nh.cpp:  // process keywords
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:                   "Target temperature for fix nvt/npt/nph cannot be 0.0");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:        error->all(FLERR,"Invalid fix nvt/npt/nph command for a 2d simulation");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:        error->all(FLERR,"Invalid fix nvt/npt/nph command for a 2d simulation");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:        error->all(FLERR,"Invalid fix nvt/npt/nph command for a 2d simulation");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      else error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (drag < 0.0) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:          error->all(FLERR,"Fix nvt/npt/nph dilate group ID does not exist");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      // used by FixNVTSllod to preserve non-default value
fix_nh.cpp:      if (mtchain < 1) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (mpchain < 0) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      else error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (nc_tchain < 0) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (nc_pchain < 0) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (nreset_h0 < 0) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      else error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      else error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      else error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      else error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      else if (strcmp(arg[iarg+1],"dipole/dlm") == 0) {
fix_nh.cpp:      } else error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:      if (iarg+4 > narg) error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:    // disc keyword is also parsed in fix/nh/sphere  
fix_nh.cpp:    } else error->all(FLERR,"Illegal fix nvt/npt/nph command");
fix_nh.cpp:  // error checks
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph command for a 2d simulation");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph command for a 2d simulation");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph command for a 2d simulation");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph command pressure settings");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph command pressure settings");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph command pressure settings");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph command pressure settings");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph command pressure settings");
fix_nh.cpp:  // require periodicity in tensile dimension
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph on a non-periodic dimension");
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph on a non-periodic dimension");
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph on a non-periodic dimension");
fix_nh.cpp:  // require periodicity in 2nd dim of off-diagonal tilt component
fix_nh.cpp:               "Cannot use fix nvt/npt/nph on a 2nd non-periodic dimension");
fix_nh.cpp:               "Cannot use fix nvt/npt/nph on a 2nd non-periodic dimension");
fix_nh.cpp:               "Cannot use fix nvt/npt/nph on a 2nd non-periodic dimension");
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph "
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph "
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph "
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph with "
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph with "
fix_nh.cpp:    error->all(FLERR,"Cannot use fix nvt/npt/nph with "
fix_nh.cpp:    error->all(FLERR,"Can not specify Pxy/Pxz/Pyz in "
fix_nh.cpp:               "fix nvt/npt/nph with non-triclinic box");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph pressure settings");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph pressure settings");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph pressure settings");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph pressure settings");
fix_nh.cpp:    error->all(FLERR,"Invalid fix nvt/npt/nph pressure settings");
fix_nh.cpp:    error->all(FLERR,"Fix nvt/npt/nph damping parameters must be > 0.0");
fix_nh.cpp:  // set pstat_flag and box change and restart_pbc variables
fix_nh.cpp:    // pstyle = TRICLINIC if any off-diagonal term is controlled -> 6 dof
fix_nh.cpp:    // else pstyle = ISO if XYZ coupling or XY coupling in 2d -> 1 dof
fix_nh.cpp:    // else pstyle = ANISO -> 3 dof
fix_nh.cpp:    // pre_exchange only required if flips can occur due to shape changes
fix_nh.cpp:  // convert input periods to frequencies
fix_nh.cpp:  if (tstat_flag) t_freq = 1.0 / t_period;
fix_nh.cpp:  if (p_flag[0]) p_freq[0] = 1.0 / p_period[0];
fix_nh.cpp:  if (p_flag[1]) p_freq[1] = 1.0 / p_period[1];
fix_nh.cpp:  if (p_flag[2]) p_freq[2] = 1.0 / p_period[2];
fix_nh.cpp:  if (p_flag[3]) p_freq[3] = 1.0 / p_period[3];
fix_nh.cpp:  if (p_flag[4]) p_freq[4] = 1.0 / p_period[4];
fix_nh.cpp:  if (p_flag[5]) p_freq[5] = 1.0 / p_period[5];
fix_nh.cpp:  // Nose/Hoover temp and pressure init
fix_nh.cpp:    // add one extra dummy thermostat, set to zero
fix_nh.cpp:      // add one extra dummy thermostat, set to zero
fix_nh.cpp:  // initialize vol0,t0 to zero to signal uninitialized
fix_nh.cpp:  // values then assigned in init(), if necessary
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:  // delete temperature and pressure if fix created them
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:  // recheck that dilate group has not been deleted
fix_nh.cpp:      error->all(FLERR,"Fix nvt/npt/nph dilate group ID does not exist");
fix_nh.cpp:  // ensure no conflict with fix deform
fix_nh.cpp:  // set temperature and pressure ptrs
fix_nh.cpp:    error->all(FLERR,"Temperature ID for fix nvt/npt does not exist");
fix_nh.cpp:      error->all(FLERR,"Pressure ID for fix npt/nph does not exist");
fix_nh.cpp:  // set timesteps and frequencies
fix_nh.cpp:    pdrag_factor = 1.0 - (update->dt * p_freq_max * drag / nc_pchain);
fix_nh.cpp:    tdrag_factor = 1.0 - (update->dt * t_freq * drag / nc_tchain);
fix_nh.cpp:  // tally the number of dimensions that are barostatted
fix_nh.cpp:  // set initial volume and reference cell, if not already done
fix_nh.cpp:  // detect if any rigid fixes exist so rigid bodies move when box is remapped
fix_nh.cpp:  // rfix[] = indices to each fix rigid
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:  // tdof needed by compute_temp_target()
fix_nh.cpp:  // t_target is needed by NVT and NPT in compute_scalar()
fix_nh.cpp:  // If no thermostat or using fix nphug,
fix_nh.cpp:  // t_target must be defined by other means.
fix_nh.cpp:    // t0 = reference temperature for masses
fix_nh.cpp:    // cannot be done in init() b/c temperature cannot be called there
fix_nh.cpp:    // is b/c Modify::init() inits computes after fixes due to dof dependence
fix_nh.cpp:    // guesstimate a unit-dependent t0 if actual T = 0.0
fix_nh.cpp:    // if it was read in from a restart file, leave it be
fix_nh.cpp:  // masses and initial forces on thermostat variables
fix_nh.cpp:    eta_mass[0] = tdof * boltz * t_target / (t_freq*t_freq);
fix_nh.cpp:      eta_mass[ich] = boltz * t_target / (t_freq*t_freq);
fix_nh.cpp:                         boltz * t_target) / eta_mass[ich];
fix_nh.cpp:  // masses and initial forces on barostat variables
fix_nh.cpp:        omega_mass[i] = nkt/(p_freq[i]*p_freq[i]);
fix_nh.cpp:        if (p_flag[i]) omega_mass[i] = nkt/(p_freq[i]*p_freq[i]);
fix_nh.cpp:  // masses and initial forces on barostat thermostat variables
fix_nh.cpp:      etap_mass[0] = boltz * t_target / (p_freq_max*p_freq_max);
fix_nh.cpp:        etap_mass[ich] = boltz * t_target / (p_freq_max*p_freq_max);
fix_nh.cpp:           boltz * t_target) / etap_mass[ich];
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:  // update eta_press_dot
fix_nh.cpp:  // update eta_dot
fix_nh.cpp:  // need to recompute pressure to account for change in KE
fix_nh.cpp:  // t_current is up-to-date, but compute_temperature is not
fix_nh.cpp:  // compute appropriately coupled elements of mvv_current
fix_nh.cpp:  // remap simulation box by 1/2 step
fix_nh.cpp:  // remap simulation box by 1/2 step
fix_nh.cpp:  // redo KSpace coeffs since volume has changed
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:  // re-compute temp before nh_v_press()
fix_nh.cpp:  // only needed for temperature computes with BIAS on reneighboring steps:
fix_nh.cpp:  //   b/c some biases store per-atom values (e.g. temp/profile)
fix_nh.cpp:  //   per-atom values are invalid if reneigh/comm occurred
fix_nh.cpp:  //     since temp->compute() in initial_integrate()
fix_nh.cpp:  // compute new T,P after velocities rescaled by nh_v_press()
fix_nh.cpp:  // compute appropriately coupled elements of mvv_current
fix_nh.cpp:  // update eta_dot
fix_nh.cpp:  // update eta_press_dot
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:  // set timesteps by level
fix_nh.cpp:  // outermost level - update eta_dot and omega_dot, apply to v
fix_nh.cpp:  // all other levels - NVE update of v
fix_nh.cpp:  // x,v updates only performed for atoms in group
fix_nh.cpp:    // update eta_press_dot
fix_nh.cpp:    // update eta_dot
fix_nh.cpp:    // recompute pressure to account for change in KE
fix_nh.cpp:    // t_current is up-to-date, but compute_temperature is not
fix_nh.cpp:    // compute appropriately coupled elements of mvv_current
fix_nh.cpp:  // innermost level - also update x only for atoms in group
fix_nh.cpp:  // if barostat, perform 1/2 step remap before and after
fix_nh.cpp:  // if barostat, redo KSpace coeffs at outermost level,
fix_nh.cpp:  // since volume has changed
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:  // set timesteps by level
fix_nh.cpp:  // outermost level - update eta_dot and omega_dot, apply via final_integrate
fix_nh.cpp:  // all other levels - NVE update of v
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:    double ave = 1.0/3.0 * (tensor[0] + tensor[1] + tensor[2]);
fix_nh.cpp:  // switch order from xy-xz-yz to Voigt
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:  // omega is not used, except for book-keeping
fix_nh.cpp:  // convert pertinent atoms and rigid bodies to lamda coords
fix_nh.cpp:  // reset global and local box to new size/shape
fix_nh.cpp:  // this operation corresponds to applying the
fix_nh.cpp:  // translate and scale operations
fix_nh.cpp:  // corresponding to the solution of the following ODE:
fix_nh.cpp:  //
fix_nh.cpp:  // h_dot = omega_dot * h
fix_nh.cpp:  //
fix_nh.cpp:  // where h_dot, omega_dot and h are all upper-triangular
fix_nh.cpp:  // 3x3 tensors. In Voigt notation, the elements of the
fix_nh.cpp:  // RHS product tensor are:
fix_nh.cpp:  // h_dot = [0*0, 1*1, 2*2, 1*3+3*2, 0*4+5*3+4*2, 0*5+5*1]
fix_nh.cpp:  //
fix_nh.cpp:  // Ordering of operations preserves time symmetry.
fix_nh.cpp:  double dto2 = dto/2.0;
fix_nh.cpp:  double dto4 = dto/4.0;
fix_nh.cpp:  double dto8 = dto/8.0;
fix_nh.cpp:  // off-diagonal components, first half
fix_nh.cpp:  // scale diagonal components
fix_nh.cpp:  // scale tilt factors with cell, if set
fix_nh.cpp:  // off-diagonal components, second half
fix_nh.cpp:  // tilt factor to cell length ratio can not exceed TILTMAX in one step
fix_nh.cpp:    error->all(FLERR,"Fix npt/nph has tilted box too far in one step - "
fix_nh.cpp:  // convert pertinent atoms and rigid bodies back to box coords
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:    // reset id_temp of pressure to new temperature ID
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:  // thermostat chain energy is equivalent to Eq. (2) in
fix_nh.cpp:  // Martyna, Tuckerman, Tobias, Klein, Mol Phys, 87, 1117
fix_nh.cpp:  // Sum(0.5*p_eta_k^2/Q_k,k=1,M) + L*k*T*eta_1 + Sum(k*T*eta_k,k=2,M),
fix_nh.cpp:  // where L = tdof
fix_nh.cpp:  //       M = mtchain
fix_nh.cpp:  //       p_eta_k = Q_k*eta_dot[k-1]
fix_nh.cpp:  //       Q_1 = L*k*T/t_freq^2
fix_nh.cpp:  //       Q_k = k*T/t_freq^2, k > 1
fix_nh.cpp:  // barostat energy is equivalent to Eq. (8) in
fix_nh.cpp:  // Martyna, Tuckerman, Tobias, Klein, Mol Phys, 87, 1117
fix_nh.cpp:  // Sum(0.5*p_omega^2/W + P*V),
fix_nh.cpp:  // where N = natoms
fix_nh.cpp:  //       p_omega = W*omega_dot
fix_nh.cpp:  //       W = N*k*T/p_freq^2
fix_nh.cpp:  //       sum is over barostatted dimensions
fix_nh.cpp:          p_hydro*(volume-vol0) / (pdim*nktv2p);
fix_nh.cpp:    // extra contributions from thermostat chain for barostat
fix_nh.cpp:    // extra contribution from strain energy
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:        return p_hydro*(volume-vol0) / nktv2p;
fix_nh.cpp:          return p_hydro*(volume-vol0) / (pdim*nktv2p);
fix_nh.cpp:          return p_hydro*(volume-vol0) / (pdim*nktv2p);
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:/* ---------------------------------------------------------------------- */
fix_nh.cpp:  // If using respa, then remap is performed in innermost level
fix_nh.cpp:    pdrag_factor = 1.0 - (update->dt * p_freq_max * drag / nc_pchain);
fix_nh.cpp:    tdrag_factor = 1.0 - (update->dt * t_freq * drag / nc_tchain);
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:  // Update masses, to preserve initial freq, if flag set
fix_nh.cpp:    eta_mass[0] = tdof * boltz * t_target / (t_freq*t_freq);
fix_nh.cpp:      eta_mass[ich] = boltz * t_target / (t_freq*t_freq);
fix_nh.cpp:    eta_dotdot[0] = (kecurrent - ke_target)/eta_mass[0];
fix_nh.cpp:  double ncfac = 1.0/nc_tchain;
fix_nh.cpp:    // rescale temperature due to velocity scaling
fix_nh.cpp:    // should not be necessary to explicitly recompute the temperature
fix_nh.cpp:      eta_dotdot[0] = (kecurrent - ke_target)/eta_mass[0];
fix_nh.cpp:                         - boltz * t_target)/eta_mass[ich];
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:  // Update masses, to preserve initial freq, if flag set
fix_nh.cpp:        omega_mass[i] = nkt/(p_freq[i]*p_freq[i]);
fix_nh.cpp:        if (p_flag[i]) omega_mass[i] = nkt/(p_freq[i]*p_freq[i]);
fix_nh.cpp:      etap_mass[0] = boltz * t_target / (p_freq_max*p_freq_max);
fix_nh.cpp:        etap_mass[ich] = boltz * t_target / (p_freq_max*p_freq_max);
fix_nh.cpp:           boltz * t_target) / etap_mass[ich];
fix_nh.cpp:  etap_dotdot[0] = (kecurrent - lkt_press)/etap_mass[0];
fix_nh.cpp:  double ncfac = 1.0/nc_pchain;
fix_nh.cpp:    etap_dotdot[0] = (kecurrent - lkt_press)/etap_mass[0];
fix_nh.cpp:        (etap_mass[ich-1]*etap_dot[ich-1]*etap_dot[ich-1] - boltz*t_target) /
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:        dtfm = dtf / rmass[i];
fix_nh.cpp:        dtfm = dtf / mass[type[i]];
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:  // x update by full step only for atoms in group
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:  // if nreset_h0 > 0, reset vol0 and h0_inv
fix_nh.cpp:  // every nreset_h0 timesteps
fix_nh.cpp:  // generate upper-triangular half of
fix_nh.cpp:  // sigma = vol0*h0inv*(p_target-p_hydro)*h0inv^t
fix_nh.cpp:  // units of sigma are are PV/L^2 e.g. atm.A
fix_nh.cpp:  //
fix_nh.cpp:  // [ 0 5 4 ]   [ 0 5 4 ] [ 0 5 4 ] [ 0 - - ]
fix_nh.cpp:  // [ 5 1 3 ] = [ - 1 3 ] [ 5 1 3 ] [ 5 1 - ]
fix_nh.cpp:  // [ 4 3 2 ]   [ - - 2 ] [ 4 3 2 ] [ 4 3 2 ]
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:  // compute strain energy = 0.5*Tr(sigma*h*h^t) in energy units
fix_nh.cpp:  double energy = 0.5*(d0+d1+d2)/nktv2p;
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:  // generate upper-triangular part of h*sigma*h^t
fix_nh.cpp:  // units of fdev are are PV, e.g. atm*A^3
fix_nh.cpp:  // [ 0 5 4 ]   [ 0 5 4 ] [ 0 5 4 ] [ 0 - - ]
fix_nh.cpp:  // [ 5 1 3 ] = [ - 1 3 ] [ 5 1 3 ] [ 5 1 - ]
fix_nh.cpp:  // [ 4 3 2 ]   [ - - 2 ] [ 4 3 2 ] [ 4 3 2 ]
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_nh.cpp:  if (pdim > 0) p_hydro /= pdim;
fix_nh.cpp:  // if deviatoric, recompute sigma each time p_target changes
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:-----------------------------------------------------------------------*/
fix_nh.cpp:      mtk_term1 /= pdim * atom->natoms;
fix_nh.cpp:      mtk_term1 /= pdim * atom->natoms;
fix_nh.cpp:      f_omega = (p_current[i]-p_hydro)*volume /
fix_nh.cpp:        (omega_mass[i] * nktv2p) + mtk_term1 / omega_mass[i];
fix_nh.cpp:      if (deviatoric_flag) f_omega -= fdev[i]/(omega_mass[i] * nktv2p);
fix_nh.cpp:    if (pdim > 0) mtk_term2 /= pdim * atom->natoms;
fix_nh.cpp:        f_omega = p_current[i]*volume/(omega_mass[i] * nktv2p);
fix_nh.cpp:          f_omega -= fdev[i]/(omega_mass[i] * nktv2p);
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:    this is b/c the box length would be changed (dramatically) by flip
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh.cpp:  // flip is only triggered when tilt exceeds 0.5 by DELTAFLIP
fix_nh.cpp:  // this avoids immediate re-flipping due to tilt oscillations
fix_nh.cpp:/* ----------------------------------------------------------------------
fix_nh.cpp:------------------------------------------------------------------------- */
fix_nh_sphere.cpp:/* ----------------------------------------------------------------------
fix_nh_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nh_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nh_sphere.cpp:------------------------------------------------------------------------- */
fix_nh_sphere.cpp:/* ----------------------------------------------------------------------
fix_nh_sphere.cpp:------------------------------------------------------------------------- */
fix_nh_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_nh_sphere.cpp:    error->all(FLERR,"Fix nvt/nph/npt sphere requires atom style sphere");
fix_nh_sphere.cpp:  // inertia = moment of inertia prefactor for sphere or disc
fix_nh_sphere.cpp:                   "Fix nvt/nph/npt sphere disc option requires 2d simulation");
fix_nh_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_nh_sphere.cpp:  // check that all particles are finite-size
fix_nh_sphere.cpp:  // no point particles allowed
fix_nh_sphere.cpp:        error->one(FLERR,"Fix nvt/npt/nph/sphere require extended particles");
fix_nh_sphere.cpp:/* ----------------------------------------------------------------------
fix_nh_sphere.cpp:-----------------------------------------------------------------------*/
fix_nh_sphere.cpp:  // standard nve_v velocity update
fix_nh_sphere.cpp:  // set timestep here since dt may have changed or come via rRESPA
fix_nh_sphere.cpp:  double dtfrotate = dtf / inertia;
fix_nh_sphere.cpp:  // update omega for all particles
fix_nh_sphere.cpp:  // d_omega/dt = torque / inertia
fix_nh_sphere.cpp:  // 4 cases depending on radius vs shape and rmass vs mass
fix_nh_sphere.cpp:      dtirotate = dtfrotate / (radius[i]*radius[i]*rmass[i]);
fix_nh_sphere.cpp:/* ----------------------------------------------------------------------
fix_nh_sphere.cpp:-----------------------------------------------------------------------*/
fix_nh_sphere.cpp:  // standard nve_x position update
fix_nh_sphere.cpp:  // update mu for dipoles
fix_nh_sphere.cpp:      // d_mu/dt = omega cross mu
fix_nh_sphere.cpp:      // renormalize mu to dipole length
fix_nh_sphere.cpp:            scale = mu[i][3]/sqrt(msq);
fix_nh_sphere.cpp:      // Integrate orientation following Dullweber-Leimkuhler-Maclachlan scheme
fix_nh_sphere.cpp:          // Construct Q from dipole:
fix_nh_sphere.cpp:          // Q is the rotation matrix from space frame to body frame
fix_nh_sphere.cpp:          // i.e. v_b = Q.v_s
fix_nh_sphere.cpp:          // Define mu to lie along the z axis in the body frame
fix_nh_sphere.cpp:          // We take the unit dipole to avoid getting a scaling matrix
fix_nh_sphere.cpp:          inv_len_mu = 1.0/mu[i][3];
fix_nh_sphere.cpp:          // v = a x [0 0 1] - cross product of mu in space and body frames
fix_nh_sphere.cpp:          // s = |v|
fix_nh_sphere.cpp:          // c = a.[0 0 1] = a[2]
fix_nh_sphere.cpp:          // vx = [ 0    -v[2]  v[1]
fix_nh_sphere.cpp:          //        v[2]  0    -v[0]
fix_nh_sphere.cpp:          //       -v[1]  v[0]  0    ]
fix_nh_sphere.cpp:          // then
fix_nh_sphere.cpp:          // Q = I + vx + vx^2 * (1-c)/s^2
fix_nh_sphere.cpp:          if (s2 != 0.0){ // i.e. the vectors are not parallel
fix_nh_sphere.cpp:            scale = (1.0 - a[2])/s2;
fix_nh_sphere.cpp:          } else { // if parallel then we just have I or -I
fix_nh_sphere.cpp:            Q[0][0] = 1.0/a[2];  Q[0][1] = 0.0;       Q[0][2] = 0.0;
fix_nh_sphere.cpp:            Q[1][0] = 0.0;       Q[1][1] = 1.0/a[2];  Q[1][2] = 0.0;
fix_nh_sphere.cpp:            Q[2][0] = 0.0;       Q[2][1] = 0.0;       Q[2][2] = 1.0/a[2];
fix_nh_sphere.cpp:          // Local copy of this particle's angular velocity (in space frame)
fix_nh_sphere.cpp:          // Transform omega into body frame: w_temp= Q.w
fix_nh_sphere.cpp:          // Construct rotation R1
fix_nh_sphere.cpp:          BuildRxMatrix(R, dtf/force->ftm2v*w_temp[0]);
fix_nh_sphere.cpp:          // Apply R1 to w: w = R.w_temp
fix_nh_sphere.cpp:          // Apply R1 to Q: Q_temp = R^T.Q
fix_nh_sphere.cpp:          // Construct rotation R2
fix_nh_sphere.cpp:          BuildRyMatrix(R, dtf/force->ftm2v*w[1]);
fix_nh_sphere.cpp:          // Apply R2 to w: w_temp = R.w
fix_nh_sphere.cpp:          // Apply R2 to Q: Q = R^T.Q_temp
fix_nh_sphere.cpp:          // Construct rotation R3
fix_nh_sphere.cpp:          BuildRzMatrix(R, 2.0*dtf/force->ftm2v*w_temp[2]);
fix_nh_sphere.cpp:          // Apply R3 to w: w = R.w_temp
fix_nh_sphere.cpp:          // Apply R3 to Q: Q_temp = R^T.Q
fix_nh_sphere.cpp:          // Construct rotation R4
fix_nh_sphere.cpp:          BuildRyMatrix(R, dtf/force->ftm2v*w[1]);
fix_nh_sphere.cpp:          // Apply R4 to w: w_temp = R.w
fix_nh_sphere.cpp:          // Apply R4 to Q: Q = R^T.Q_temp
fix_nh_sphere.cpp:          // Construct rotation R5
fix_nh_sphere.cpp:          BuildRxMatrix(R, dtf/force->ftm2v*w_temp[0]);
fix_nh_sphere.cpp:          // Apply R5 to w: w = R.w_temp
fix_nh_sphere.cpp:          // Apply R5 to Q: Q_temp = R^T.Q
fix_nh_sphere.cpp:          // Transform w back into space frame w_temp = Q^T.w
fix_nh_sphere.cpp:          // Set dipole according to updated Q: mu = Q^T.[0 0 1] * |mu|
fix_nh_sphere.cpp:/* ----------------------------------------------------------------------
fix_nh_sphere.cpp:-----------------------------------------------------------------------*/
fix_nh_sphere.cpp:  // standard nh_v_temp scaling
fix_nph.cpp:/* ----------------------------------------------------------------------
fix_nph.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nph.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nph.cpp:------------------------------------------------------------------------- */
fix_nph.cpp:/* ---------------------------------------------------------------------- */
fix_nph.cpp:  // create a new compute temp style
fix_nph.cpp:  // id = fix-ID + temp
fix_nph.cpp:  // compute group = all since pressure is always global (group all)
fix_nph.cpp:  // and thus its KE/temperature contribution should use group all
fix_nph.cpp:  // create a new compute pressure style
fix_nph.cpp:  // id = fix-ID + press, compute group = all
fix_nph.cpp:  // pass id_temp as 4th arg to pressure constructor
fix_nph_sphere.cpp:/* ----------------------------------------------------------------------
fix_nph_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nph_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nph_sphere.cpp:------------------------------------------------------------------------- */
fix_nph_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_nph_sphere.cpp:    error->all(FLERR,"Temperature control can not be used with fix nph/sphere");
fix_nph_sphere.cpp:    error->all(FLERR,"Pressure control must be used with fix nph/sphere");
fix_nph_sphere.cpp:  // create a new compute temp style
fix_nph_sphere.cpp:  // id = fix-ID + temp
fix_nph_sphere.cpp:  // compute group = all since pressure is always global (group all)
fix_nph_sphere.cpp:  // and thus its KE/temperature contribution should use group all
fix_nph_sphere.cpp:  newarg[2] = (char *) "temp/sphere";
fix_nph_sphere.cpp:  // create a new compute pressure style
fix_nph_sphere.cpp:  // id = fix-ID + press, compute group = all
fix_nph_sphere.cpp:  // pass id_temp as 4th arg to pressure constructor
fix_npt.cpp:/* ----------------------------------------------------------------------
fix_npt.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_npt.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_npt.cpp:------------------------------------------------------------------------- */
fix_npt.cpp:/* ---------------------------------------------------------------------- */
fix_npt.cpp:  // create a new compute temp style
fix_npt.cpp:  // id = fix-ID + temp
fix_npt.cpp:  // compute group = all since pressure is always global (group all)
fix_npt.cpp:  // and thus its KE/temperature contribution should use group all
fix_npt.cpp:  // create a new compute pressure style
fix_npt.cpp:  // id = fix-ID + press, compute group = all
fix_npt.cpp:  // pass id_temp as 4th arg to pressure constructor
fix_npt_sphere.cpp:/* ----------------------------------------------------------------------
fix_npt_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_npt_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_npt_sphere.cpp:------------------------------------------------------------------------- */
fix_npt_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_npt_sphere.cpp:    error->all(FLERR,"Temperature control must be used with fix npt/sphere");
fix_npt_sphere.cpp:    error->all(FLERR,"Pressure control must be used with fix npt/sphere");
fix_npt_sphere.cpp:  // create a new compute temp style
fix_npt_sphere.cpp:  // id = fix-ID + temp
fix_npt_sphere.cpp:  // compute group = all since pressure is always global (group all)
fix_npt_sphere.cpp:  // and thus its KE/temperature contribution should use group all
fix_npt_sphere.cpp:  newarg[2] = (char *) "temp/sphere";
fix_npt_sphere.cpp:  // create a new compute pressure style
fix_npt_sphere.cpp:  // id = fix-ID + press, compute group = all
fix_npt_sphere.cpp:  // pass id_temp as 4th arg to pressure constructor
fix_nve.cpp:/* ----------------------------------------------------------------------
fix_nve.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nve.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nve.cpp:------------------------------------------------------------------------- */
fix_nve.cpp:/* ---------------------------------------------------------------------- */
fix_nve.cpp:  if (strcmp(style,"nve/sphere") != 0 && narg < 3)
fix_nve.cpp:/* ---------------------------------------------------------------------- */
fix_nve.cpp:/* ---------------------------------------------------------------------- */
fix_nve.cpp:/* ----------------------------------------------------------------------
fix_nve.cpp:------------------------------------------------------------------------- */
fix_nve.cpp:  // update v and x of atoms in group
fix_nve.cpp:        dtfm = dtf / rmass[i];
fix_nve.cpp:        dtfm = dtf / mass[type[i]];
fix_nve.cpp:/* ---------------------------------------------------------------------- */
fix_nve.cpp:  // update v of atoms in group
fix_nve.cpp:        dtfm = dtf / rmass[i];
fix_nve.cpp:        dtfm = dtf / mass[type[i]];
fix_nve.cpp:/* ---------------------------------------------------------------------- */
fix_nve.cpp:  // innermost level - NVE update of v and x
fix_nve.cpp:  // all other levels - NVE update of v
fix_nve.cpp:/* ---------------------------------------------------------------------- */
fix_nve.cpp:/* ---------------------------------------------------------------------- */
fix_nve_limit.cpp:/* ----------------------------------------------------------------------
fix_nve_limit.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nve_limit.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nve_limit.cpp:------------------------------------------------------------------------- */
fix_nve_limit.cpp:/* ---------------------------------------------------------------------- */
fix_nve_limit.cpp:  if (narg != 4) error->all(FLERR,"Illegal fix nve/limit command");
fix_nve_limit.cpp:/* ---------------------------------------------------------------------- */
fix_nve_limit.cpp:/* ---------------------------------------------------------------------- */
fix_nve_limit.cpp:  vlimitsq = (xlimit/dtv) * (xlimit/dtv);
fix_nve_limit.cpp:  // warn if using fix shake, which will lead to invalid constraint forces
fix_nve_limit.cpp:        error->warning(FLERR,"Should not use fix nve/limit with fix shake or fix rattle");
fix_nve_limit.cpp:/* ----------------------------------------------------------------------
fix_nve_limit.cpp:------------------------------------------------------------------------- */
fix_nve_limit.cpp:        dtfm = dtf / rmass[i];
fix_nve_limit.cpp:          scale = sqrt(vlimitsq/vsq);
fix_nve_limit.cpp:        dtfm = dtf / mass[type[i]];
fix_nve_limit.cpp:          scale = sqrt(vlimitsq/vsq);
fix_nve_limit.cpp:/* ---------------------------------------------------------------------- */
fix_nve_limit.cpp:        dtfm = dtf / rmass[i];
fix_nve_limit.cpp:          scale = sqrt(vlimitsq/vsq);
fix_nve_limit.cpp:        dtfm = dtf / mass[type[i]];
fix_nve_limit.cpp:          scale = sqrt(vlimitsq/vsq);
fix_nve_limit.cpp:/* ---------------------------------------------------------------------- */
fix_nve_limit.cpp:/* ---------------------------------------------------------------------- */
fix_nve_limit.cpp:/* ---------------------------------------------------------------------- */
fix_nve_limit.cpp:  vlimitsq = (xlimit/dtv) * (xlimit/dtv);
fix_nve_limit.cpp:/* ----------------------------------------------------------------------
fix_nve_limit.cpp:------------------------------------------------------------------------- */
fix_nve_noforce.cpp:/* ----------------------------------------------------------------------
fix_nve_noforce.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nve_noforce.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nve_noforce.cpp:------------------------------------------------------------------------- */
fix_nve_noforce.cpp:/* ---------------------------------------------------------------------- */
fix_nve_noforce.cpp:  if (narg != 3) error->all(FLERR,"Illegal fix nve/noforce command");
fix_nve_noforce.cpp:/* ---------------------------------------------------------------------- */
fix_nve_noforce.cpp:/* ---------------------------------------------------------------------- */
fix_nve_noforce.cpp:/* ---------------------------------------------------------------------- */
fix_nve_noforce.cpp:/* ---------------------------------------------------------------------- */
fix_nve_noforce.cpp:  if (flag) return;             // only used by NPT,NPH
fix_nve_noforce.cpp:/* ---------------------------------------------------------------------- */
fix_nve_sphere.cpp:/* ----------------------------------------------------------------------
fix_nve_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nve_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nve_sphere.cpp:------------------------------------------------------------------------- */
fix_nve_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_nve_sphere.cpp:  if (narg < 3) error->all(FLERR,"Illegal fix nve/sphere command");
fix_nve_sphere.cpp:  // process extra keywords
fix_nve_sphere.cpp:  // inertia = moment of inertia prefactor for sphere or disc
fix_nve_sphere.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix nve/sphere command");
fix_nve_sphere.cpp:      else if (strcmp(arg[iarg+1],"dipole/dlm") == 0) {
fix_nve_sphere.cpp:      } else error->all(FLERR,"Illegal fix nve/sphere command");
fix_nve_sphere.cpp:	error->all(FLERR,"Fix nve/sphere disc requires 2d simulation");	
fix_nve_sphere.cpp:    else error->all(FLERR,"Illegal fix nve/sphere command");
fix_nve_sphere.cpp:  // error checks
fix_nve_sphere.cpp:    error->all(FLERR,"Fix nve/sphere requires atom style sphere");
fix_nve_sphere.cpp:    error->all(FLERR,"Fix nve/sphere update dipole requires atom attribute mu");
fix_nve_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_nve_sphere.cpp:  // check that all particles are finite-size spheres
fix_nve_sphere.cpp:  // no point particles allowed
fix_nve_sphere.cpp:        error->one(FLERR,"Fix nve/sphere requires extended particles");
fix_nve_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_nve_sphere.cpp:  // set timestep here since dt may have changed or come via rRESPA
fix_nve_sphere.cpp:  double dtfrotate = dtf / inertia;
fix_nve_sphere.cpp:  // update v,x,omega for all particles
fix_nve_sphere.cpp:  // d_omega/dt = torque / inertia
fix_nve_sphere.cpp:      dtfm = dtf / rmass[i];
fix_nve_sphere.cpp:      dtirotate = dtfrotate / (radius[i]*radius[i]*rmass[i]);
fix_nve_sphere.cpp:  // update mu for dipoles
fix_nve_sphere.cpp:      // d_mu/dt = omega cross mu
fix_nve_sphere.cpp:      // renormalize mu to dipole length
fix_nve_sphere.cpp:            scale = mu[i][3]/sqrt(msq);
fix_nve_sphere.cpp:      // integrate orientation following Dullweber-Leimkuhler-Maclachlan scheme
fix_nve_sphere.cpp:          // Construct Q from dipole:
fix_nve_sphere.cpp:          // Q is the rotation matrix from space frame to body frame
fix_nve_sphere.cpp:          // i.e. v_b = Q.v_s
fix_nve_sphere.cpp:          // define mu to lie along the z axis in the body frame
fix_nve_sphere.cpp:          // take the unit dipole to avoid getting a scaling matrix
fix_nve_sphere.cpp:          inv_len_mu = 1.0/mu[i][3];
fix_nve_sphere.cpp:          // v = a x [0 0 1] - cross product of mu in space and body frames
fix_nve_sphere.cpp:          // s = |v|
fix_nve_sphere.cpp:          // c = a.[0 0 1] = a[2]
fix_nve_sphere.cpp:          // vx = [ 0    -v[2]  v[1]
fix_nve_sphere.cpp:          //        v[2]  0    -v[0]
fix_nve_sphere.cpp:          //       -v[1]  v[0]  0    ]
fix_nve_sphere.cpp:          // then
fix_nve_sphere.cpp:          // Q = I + vx + vx^2 * (1-c)/s^2
fix_nve_sphere.cpp:          if (s2 != 0.0){ // i.e. the vectors are not parallel
fix_nve_sphere.cpp:            scale = (1.0 - a[2])/s2;
fix_nve_sphere.cpp:          } else { // if parallel then we just have I or -I
fix_nve_sphere.cpp:            Q[0][0] = 1.0/a[2];  Q[0][1] = 0.0;       Q[0][2] = 0.0;
fix_nve_sphere.cpp:            Q[1][0] = 0.0;       Q[1][1] = 1.0/a[2];  Q[1][2] = 0.0;
fix_nve_sphere.cpp:            Q[2][0] = 0.0;       Q[2][1] = 0.0;       Q[2][2] = 1.0/a[2];
fix_nve_sphere.cpp:          // Local copy of this particle's angular velocity (in space frame)
fix_nve_sphere.cpp:          // Transform omega into body frame: w_temp= Q.w
fix_nve_sphere.cpp:          // Construct rotation R1
fix_nve_sphere.cpp:          BuildRxMatrix(R, dtf/force->ftm2v*w_temp[0]);
fix_nve_sphere.cpp:          // Apply R1 to w: w = R.w_temp
fix_nve_sphere.cpp:          // Apply R1 to Q: Q_temp = R^T.Q
fix_nve_sphere.cpp:          // Construct rotation R2
fix_nve_sphere.cpp:          BuildRyMatrix(R, dtf/force->ftm2v*w[1]);
fix_nve_sphere.cpp:          // Apply R2 to w: w_temp = R.w
fix_nve_sphere.cpp:          // Apply R2 to Q: Q = R^T.Q_temp
fix_nve_sphere.cpp:          // Construct rotation R3
fix_nve_sphere.cpp:          BuildRzMatrix(R, 2.0*dtf/force->ftm2v*w_temp[2]);
fix_nve_sphere.cpp:          // Apply R3 to w: w = R.w_temp
fix_nve_sphere.cpp:          // Apply R3 to Q: Q_temp = R^T.Q
fix_nve_sphere.cpp:          // Construct rotation R4
fix_nve_sphere.cpp:          BuildRyMatrix(R, dtf/force->ftm2v*w[1]);
fix_nve_sphere.cpp:          // Apply R4 to w: w_temp = R.w
fix_nve_sphere.cpp:          // Apply R4 to Q: Q = R^T.Q_temp
fix_nve_sphere.cpp:          // Construct rotation R5
fix_nve_sphere.cpp:          BuildRxMatrix(R, dtf/force->ftm2v*w_temp[0]);
fix_nve_sphere.cpp:          // Apply R5 to w: w = R.w_temp
fix_nve_sphere.cpp:          // Apply R5 to Q: Q_temp = R^T.Q
fix_nve_sphere.cpp:          // Transform w back into space frame w_temp = Q^T.w
fix_nve_sphere.cpp:          // Set dipole according to updated Q: mu = Q^T.[0 0 1] * |mu|
fix_nve_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_nve_sphere.cpp:  // set timestep here since dt may have changed or come via rRESPA
fix_nve_sphere.cpp:  double dtfrotate = dtf / inertia;
fix_nve_sphere.cpp:  // update v,omega for all particles
fix_nve_sphere.cpp:  // d_omega/dt = torque / inertia
fix_nve_sphere.cpp:      dtfm = dtf / rmass[i];
fix_nve_sphere.cpp:      dtirotate = dtfrotate / (radius[i]*radius[i]*rmass[i]);
fix_nve_spin.cpp:/* ----------------------------------------------------------------------
fix_nve_spin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nve_spin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nve_spin.cpp:------------------------------------------------------------------------- */
fix_nve_spin.cpp:/* ---------------------------------------------------------------------- */
fix_nve_spin.cpp:  if (narg < 3) error->all(FLERR,"Illegal fix nve/spin command");	
fix_nve_spin.cpp:  if (strcmp(arg[iarg],"nve/spin") == 0) {
fix_nve_spin.cpp:	  if (iarg+1 > narg) error->all(FLERR,"Illegal fix nve/spin command");
fix_nve_spin.cpp:  // error checks
fix_nve_spin.cpp:    error->all(FLERR,"Fix nve/spin requires spin attribute mumag");
fix_nve_spin.cpp:/* ---------------------------------------------------------------------- */
fix_nve_spin.cpp:  /*int idamp;
fix_nve_spin.cpp:    if (strstr(modify->fix[idamp]->style,"damping/spin")) break;
fix_nve_spin.cpp:  */
fix_nve_spin.cpp:/* ---------------------------------------------------------------------- */
fix_nve_spin.cpp:  // Advance half spins all particles
fix_nve_spin.cpp:  //See Omelyan et al., PRL 86, 2001 and P.W. Ma et al, PRB 83, 2011
fix_nve_spin.cpp:  // update half v all particles
fix_nve_spin.cpp:      if (rmass) dtfm = dtf / rmass[i];
fix_nve_spin.cpp:      else dtfm = dtf / mass[type[i]]; 
fix_nve_spin.cpp:  // update x for all particles
fix_nve_spin.cpp://#define FORCE_PRINT
fix_nve_spin.cpp:/* ---------------------------------------------------------------------- */
fix_nve_spin.cpp:  // regular communication vs neighbor list rebuild
fix_nve_spin.cpp:  // force computations
fix_nve_spin.cpp:  // important for pair to come before bonded contributions
fix_nve_spin.cpp:  // since some bonded potentials tally pairwise energy/virial
fix_nve_spin.cpp:  // and Pair:ev_tally() needs to be called before any tallying
fix_nve_spin.cpp:  // reverse communication of forces
fix_nve_spin.cpp:  // force modifications
fix_nve_spin.cpp:/* ---------------------------------------------------------------------- */
fix_nve_spin.cpp:  g[0] /= (1+0.25*fm2*dts*dts);
fix_nve_spin.cpp:  g[1] /= (1+0.25*fm2*dts*dts);
fix_nve_spin.cpp:  g[2] /= (1+0.25*fm2*dts*dts);
fix_nve_spin.cpp:  //Renormalization (may not be necessary)
fix_nve_spin.cpp:  scale = 1.0/sqrt(msq);
fix_nve_spin.cpp:/* ---------------------------------------------------------------------- */
fix_nve_spin.cpp:  // update half v for all particles
fix_nve_spin.cpp:      if (rmass) dtfm = dtf / rmass[i];
fix_nve_spin.cpp:      else dtfm = dtf / mass[type[i]]; 
fix_nve_spin.cpp:  // Advance half spins all particles
fix_nve_spin.cpp:  //See Omelyan et al., PRL 86, 2001 and P.W. Ma et al, PRB 83, 2011
fix_nvt.cpp:/* ----------------------------------------------------------------------
fix_nvt.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nvt.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nvt.cpp:------------------------------------------------------------------------- */
fix_nvt.cpp:/* ---------------------------------------------------------------------- */
fix_nvt.cpp:  // create a new compute temp style
fix_nvt.cpp:  // id = fix-ID + temp
fix_nvt_sllod.cpp:/* ----------------------------------------------------------------------
fix_nvt_sllod.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nvt_sllod.cpp:   www.cs.sandia.gov/~sjplimp/lammps.html
fix_nvt_sllod.cpp:------------------------------------------------------------------------- */
fix_nvt_sllod.cpp:/* ----------------------------------------------------------------------
fix_nvt_sllod.cpp:------------------------------------------------------------------------- */
fix_nvt_sllod.cpp:enum{NO_REMAP,X_REMAP,V_REMAP};                   // same as fix_deform.cpp
fix_nvt_sllod.cpp:/* ---------------------------------------------------------------------- */
fix_nvt_sllod.cpp:    error->all(FLERR,"Temperature control must be used with fix nvt/sllod");
fix_nvt_sllod.cpp:    error->all(FLERR,"Pressure control can not be used with fix nvt/sllod");
fix_nvt_sllod.cpp:  // default values
fix_nvt_sllod.cpp:  // create a new compute temp style
fix_nvt_sllod.cpp:  // id = fix-ID + temp
fix_nvt_sllod.cpp:  newarg[2] = (char *) "temp/deform";
fix_nvt_sllod.cpp:/* ---------------------------------------------------------------------- */
fix_nvt_sllod.cpp:    error->all(FLERR,"Temperature for fix nvt/sllod does not have a bias");
fix_nvt_sllod.cpp:  if (strcmp(temperature->style,"temp/deform") != 0) nondeformbias = 1;
fix_nvt_sllod.cpp:  // check fix deform remap settings
fix_nvt_sllod.cpp:        error->all(FLERR,"Using fix nvt/sllod with inconsistent fix deform "
fix_nvt_sllod.cpp:    error->all(FLERR,"Using fix nvt/sllod with no fix deform defined");
fix_nvt_sllod.cpp:/* ----------------------------------------------------------------------
fix_nvt_sllod.cpp:-----------------------------------------------------------------------*/
fix_nvt_sllod.cpp:  // remove and restore bias = streaming velocity = Hrate*lamda + Hratelo
fix_nvt_sllod.cpp:  // thermostat thermal velocity only
fix_nvt_sllod.cpp:  // vdelu = SLLOD correction = Hrate*Hinv*vthermal
fix_nvt_sllod.cpp:  // for non temp/deform BIAS:
fix_nvt_sllod.cpp:  //   calculate temperature since some computes require temp
fix_nvt_sllod.cpp:  //   computed on current nlocal atoms to remove bias
fix_nvt_sphere.cpp:/* ----------------------------------------------------------------------
fix_nvt_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_nvt_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_nvt_sphere.cpp:------------------------------------------------------------------------- */
fix_nvt_sphere.cpp:/* ---------------------------------------------------------------------- */
fix_nvt_sphere.cpp:    error->all(FLERR,"Temperature control must be used with fix nvt/sphere");
fix_nvt_sphere.cpp:    error->all(FLERR,"Pressure control can not be used with fix nvt/sphere");
fix_nvt_sphere.cpp:  // create a new compute temp style
fix_nvt_sphere.cpp:  // id = fix-ID + temp
fix_nvt_sphere.cpp:  newarg[2] = (char *) "temp/sphere";
fix_planeforce.cpp:/* ----------------------------------------------------------------------
fix_planeforce.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_planeforce.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_planeforce.cpp:------------------------------------------------------------------------- */
fix_planeforce.cpp:/* ---------------------------------------------------------------------- */
fix_planeforce.cpp:  xdir /= len;
fix_planeforce.cpp:  ydir /= len;
fix_planeforce.cpp:  zdir /= len;
fix_planeforce.cpp:/* ---------------------------------------------------------------------- */
fix_planeforce.cpp:/* ---------------------------------------------------------------------- */
fix_planeforce.cpp:/* ---------------------------------------------------------------------- */
fix_planeforce.cpp:/* ---------------------------------------------------------------------- */
fix_planeforce.cpp:/* ---------------------------------------------------------------------- */
fix_planeforce.cpp:/* ---------------------------------------------------------------------- */
fix_press_berendsen.cpp:/* ----------------------------------------------------------------------
fix_press_berendsen.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_press_berendsen.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_press_berendsen.cpp:------------------------------------------------------------------------- */
fix_press_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_press_berendsen.cpp:  if (narg < 5) error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:  // Berendsen barostat applied every step
fix_press_berendsen.cpp:  // default values
fix_press_berendsen.cpp:  // process keywords
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:        error->all(FLERR,"Invalid fix press/berendsen for a 2d simulation");
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:      else error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:        error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:      else error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:    } else error->all(FLERR,"Illegal fix press/berendsen command");
fix_press_berendsen.cpp:  // error checks
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen for a 2d simulation");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen for a 2d simulation");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:               "Cannot use fix press/berendsen on a non-periodic dimension");
fix_press_berendsen.cpp:               "Cannot use fix press/berendsen on a non-periodic dimension");
fix_press_berendsen.cpp:               "Cannot use fix press/berendsen on a non-periodic dimension");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Invalid fix press/berendsen pressure settings");
fix_press_berendsen.cpp:    error->all(FLERR,"Fix press/berendsen damping parameters must be > 0.0");
fix_press_berendsen.cpp:  // pstyle = ISO if XYZ coupling or XY coupling in 2d -> 1 dof
fix_press_berendsen.cpp:  // else pstyle = ANISO -> 3 dof
fix_press_berendsen.cpp:  // create a new compute temp style
fix_press_berendsen.cpp:  // id = fix-ID + temp
fix_press_berendsen.cpp:  // compute group = all since pressure is always global (group all)
fix_press_berendsen.cpp:  //   and thus its KE/temperature contribution should use group all
fix_press_berendsen.cpp:  // create a new compute pressure style
fix_press_berendsen.cpp:  // id = fix-ID + press, compute group = all
fix_press_berendsen.cpp:  // pass id_temp as 4th arg to pressure constructor
fix_press_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_press_berendsen.cpp:  // delete temperature and pressure if fix created them
fix_press_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_press_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_press_berendsen.cpp:    error->all(FLERR,"Cannot use fix press/berendsen with triclinic box");
fix_press_berendsen.cpp:  // insure no conflict with fix deform
fix_press_berendsen.cpp:        error->all(FLERR,"Cannot use fix press/berendsen and "
fix_press_berendsen.cpp:  // set temperature and pressure ptrs
fix_press_berendsen.cpp:    error->all(FLERR,"Temperature ID for fix press/berendsen does not exist");
fix_press_berendsen.cpp:    error->all(FLERR,"Pressure ID for fix press/berendsen does not exist");
fix_press_berendsen.cpp:  // Kspace setting
fix_press_berendsen.cpp:  // detect if any rigid fixes exist so rigid bodies move when box is remapped
fix_press_berendsen.cpp:  // rfix[] = indices to each fix rigid
fix_press_berendsen.cpp:/* ----------------------------------------------------------------------
fix_press_berendsen.cpp:------------------------------------------------------------------------- */
fix_press_berendsen.cpp:  // trigger virial computation on next timestep
fix_press_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_press_berendsen.cpp:  // compute new T,P
fix_press_berendsen.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_press_berendsen.cpp:        pow(1.0 - update->dt/p_period[i] *
fix_press_berendsen.cpp:            (p_target[i]-p_current[i])/bulkmodulus,1.0/3.0);
fix_press_berendsen.cpp:  // remap simulation box and atoms
fix_press_berendsen.cpp:  // redo KSpace coeffs since volume has changed
fix_press_berendsen.cpp:  // trigger virial computation on next timestep
fix_press_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_press_berendsen.cpp:    double ave = 1.0/3.0 * (tensor[0] + tensor[1] + tensor[2]);
fix_press_berendsen.cpp:/* ----------------------------------------------------------------------
fix_press_berendsen.cpp:------------------------------------------------------------------------- */
fix_press_berendsen.cpp:  // convert pertinent atoms and rigid bodies to lamda coords
fix_press_berendsen.cpp:  // reset global and local box to new size/shape
fix_press_berendsen.cpp:  // convert pertinent atoms and rigid bodies back to box coords
fix_press_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_press_berendsen.cpp:    // reset id_temp of pressure to new temperature ID
fix_press_berendsen.cpp:      error->all(FLERR,"Pressure ID for fix press/berendsen does not exist");
fix_print.cpp:/* ----------------------------------------------------------------------
fix_print.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_print.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_print.cpp:------------------------------------------------------------------------- */
fix_print.cpp:/* ---------------------------------------------------------------------- */
fix_print.cpp:  copy = (char *) memory->smalloc(n*sizeof(char),"fix/print:copy");
fix_print.cpp:  work = (char *) memory->smalloc(n*sizeof(char),"fix/print:work");
fix_print.cpp:  // parse optional args
fix_print.cpp:  // print file comment line
fix_print.cpp:  // add nfirst to all computes that store invocation times
fix_print.cpp:  // since don't know a priori which are invoked via variables by this fix
fix_print.cpp:  // once in end_of_step() can set timestep for ones actually invoked
fix_print.cpp:  const bigint nfirst = (update->ntimestep/nevery)*nevery + nevery;
fix_print.cpp:/* ---------------------------------------------------------------------- */
fix_print.cpp:/* ---------------------------------------------------------------------- */
fix_print.cpp:/* ---------------------------------------------------------------------- */
fix_print.cpp:  // make a copy of string to work on
fix_print.cpp:  // substitute for $ variables (no printing)
fix_print.cpp:  // append a newline and print final copy
fix_print.cpp:  // variable evaluation may invoke computes so wrap with clear/add
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_property_atom.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ---------------------------------------------------------------------- */
fix_property_atom.cpp:  if (narg < 4) error->all(FLERR,"Illegal fix property/atom command");
fix_property_atom.cpp:        error->all(FLERR,"Fix property/atom mol when atom_style "
fix_property_atom.cpp:        error->all(FLERR,"Fix property/atom cannot specify mol twice");
fix_property_atom.cpp:        error->all(FLERR,"Fix property/atom q when atom_style "
fix_property_atom.cpp:        error->all(FLERR,"Fix property/atom cannot specify q twice");
fix_property_atom.cpp:        error->all(FLERR,"Fix property/atom rmass when atom_style "
fix_property_atom.cpp:        error->all(FLERR,"Fix property/atom cannot specify rmass twice");
fix_property_atom.cpp:        error->all(FLERR,"Fix property/atom vector name already exists");
fix_property_atom.cpp:        error->all(FLERR,"Fix property/atom vector name already exists");
fix_property_atom.cpp:  // optional args
fix_property_atom.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix property/atom command");
fix_property_atom.cpp:      else error->all(FLERR,"Illegal fix property/atom command");
fix_property_atom.cpp:    } else error->all(FLERR,"Illegal fix property/atom command");
fix_property_atom.cpp:  // warn if mol or charge keyword used without ghost yes
fix_property_atom.cpp:      error->warning(FLERR,"Fix property/atom mol or charge or rmass "
fix_property_atom.cpp:                     "w/out ghost communication");
fix_property_atom.cpp:  // store current atom style
fix_property_atom.cpp:  // perform initial allocation of atom-based array
fix_property_atom.cpp:  // register with Atom class
fix_property_atom.cpp:/* ---------------------------------------------------------------------- */
fix_property_atom.cpp:  // unregister callbacks to this fix from Atom class
fix_property_atom.cpp:  // deallocate per-atom vectors in Atom class
fix_property_atom.cpp:  // set ptrs to NULL, so they no longer exist for Atom class
fix_property_atom.cpp:/* ---------------------------------------------------------------------- */
fix_property_atom.cpp:/* ---------------------------------------------------------------------- */
fix_property_atom.cpp:  // error if atom style has changed since fix was defined
fix_property_atom.cpp:  // don't allow this b/c user could change to style that defines molecule,q
fix_property_atom.cpp:    error->all(FLERR,"Atom style was redefined after using fix property/atom");
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:  // loop over lines of atom info
fix_property_atom.cpp:  // tokenize the line into values
fix_property_atom.cpp:  // if I own atom tag, unpack its values
fix_property_atom.cpp:    // assign words in line to per-atom vectors
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:  // 1st column = atom tag
fix_property_atom.cpp:  // rest of columns = per-atom values
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:  // skip to Nth set of extra values
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_property_atom.cpp:/* ----------------------------------------------------------------------
fix_property_atom.cpp:------------------------------------------------------------------------- */
fix_read_restart.cpp:/* ----------------------------------------------------------------------
fix_read_restart.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_read_restart.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_read_restart.cpp:------------------------------------------------------------------------- */
fix_read_restart.cpp:/* ---------------------------------------------------------------------- */
fix_read_restart.cpp:  // perform initial allocation of atom-based array
fix_read_restart.cpp:  // register with Atom class
fix_read_restart.cpp:  // extra = copy of atom->extra
fix_read_restart.cpp:/* ---------------------------------------------------------------------- */
fix_read_restart.cpp:  // unregister callback to this fix from Atom class
fix_read_restart.cpp:  // delete locally stored arrays
fix_read_restart.cpp:/* ---------------------------------------------------------------------- */
fix_read_restart.cpp:/* ----------------------------------------------------------------------
fix_read_restart.cpp:------------------------------------------------------------------------- */
fix_read_restart.cpp:/* ----------------------------------------------------------------------
fix_read_restart.cpp:------------------------------------------------------------------------- */
fix_read_restart.cpp:/* ----------------------------------------------------------------------
fix_read_restart.cpp:------------------------------------------------------------------------- */
fix_read_restart.cpp:/* ----------------------------------------------------------------------
fix_read_restart.cpp:------------------------------------------------------------------------- */
fix_read_restart.cpp:/* ----------------------------------------------------------------------
fix_read_restart.cpp:------------------------------------------------------------------------- */
fix_recenter.cpp:/* ----------------------------------------------------------------------
fix_recenter.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_recenter.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_recenter.cpp:------------------------------------------------------------------------- */
fix_recenter.cpp:/* ----------------------------------------------------------------------
fix_recenter.cpp:------------------------------------------------------------------------- */
fix_recenter.cpp:/* ---------------------------------------------------------------------- */
fix_recenter.cpp:  // optional args
fix_recenter.cpp:  // scale xcom,ycom,zcom
fix_recenter.cpp:  // cannot have 0 atoms in group
fix_recenter.cpp:/* ---------------------------------------------------------------------- */
fix_recenter.cpp:/* ---------------------------------------------------------------------- */
fix_recenter.cpp:  // warn if any integrate fix comes after this one
fix_recenter.cpp:  // if any components of requested COM were INIT, store initial COM
fix_recenter.cpp:/* ---------------------------------------------------------------------- */
fix_recenter.cpp:  // target COM
fix_recenter.cpp:  // bounding box around domain works for both orthogonal and triclinic
fix_recenter.cpp:  // current COM
fix_recenter.cpp:  // shift coords by difference between actual COM and requested COM
fix_recenter.cpp:/* ---------------------------------------------------------------------- */
fix_recenter.cpp:  // outermost level - operate recenter
fix_recenter.cpp:  // all other levels - nothing
fix_recenter.cpp:/* ---------------------------------------------------------------------- */
fix_recenter.cpp:/* ---------------------------------------------------------------------- */
fix_respa.cpp:/* ----------------------------------------------------------------------
fix_respa.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_respa.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_respa.cpp:------------------------------------------------------------------------- */
fix_respa.cpp:/* ---------------------------------------------------------------------- */
fix_respa.cpp:  // nlevels = # of rRESPA levels
fix_respa.cpp:  // optional arguments
fix_respa.cpp:  // perform initial allocation of atom-based arrays
fix_respa.cpp:  // register with Atom class
fix_respa.cpp:/* ---------------------------------------------------------------------- */
fix_respa.cpp:  // unregister callbacks to this fix from Atom class
fix_respa.cpp:  // delete locally stored arrays
fix_respa.cpp:/* ---------------------------------------------------------------------- */
fix_respa.cpp:/* ----------------------------------------------------------------------
fix_respa.cpp:------------------------------------------------------------------------- */
fix_respa.cpp:/* ----------------------------------------------------------------------
fix_respa.cpp:------------------------------------------------------------------------- */
fix_respa.cpp:/* ----------------------------------------------------------------------
fix_respa.cpp:------------------------------------------------------------------------- */
fix_respa.cpp:/* ----------------------------------------------------------------------
fix_respa.cpp:------------------------------------------------------------------------- */
fix_respa.cpp:/* ----------------------------------------------------------------------
fix_respa.cpp:------------------------------------------------------------------------- */
fix_restrain.cpp:/* ----------------------------------------------------------------------
fix_restrain.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_restrain.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_restrain.cpp:------------------------------------------------------------------------- */
fix_restrain.cpp:/* ----------------------------------------------------------------------
fix_restrain.cpp:------------------------------------------------------------------------- */
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:  // parse args
fix_restrain.cpp:      target[nrestrain] *= MY_PI / 180.0;
fix_restrain.cpp:      target[nrestrain] *= MY_PI / 180.0;
fix_restrain.cpp:  // require atom map to lookup atom IDs
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:/* ---------------------------------------------------------------------- */
fix_restrain.cpp:/* ----------------------------------------------------------------------
fix_restrain.cpp:---------------------------------------------------------------------- */
fix_restrain.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_restrain.cpp:  // newton_bond on: only processor owning i2 computes restraint
fix_restrain.cpp:  // newton_bond off: only processors owning either of i1,i2 computes restraint
fix_restrain.cpp:  // force & energy
fix_restrain.cpp:  if (r > 0.0) fbond = -2.0*rk/r;
fix_restrain.cpp:  // apply force to each of 2 atoms
fix_restrain.cpp:/* ----------------------------------------------------------------------
fix_restrain.cpp:---------------------------------------------------------------------- */
fix_restrain.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_restrain.cpp:  // newton_bond on: only processor owning i2 computes restraint
fix_restrain.cpp:  // newton_bond off: only processors owning any of i1-i3 computes restraint
fix_restrain.cpp:  // 1st bond
fix_restrain.cpp:  // 2nd bond
fix_restrain.cpp:  // angle (cos and sin)
fix_restrain.cpp:  c /= r1*r2;
fix_restrain.cpp:  s = 1.0/s;
fix_restrain.cpp:  // force & energy
fix_restrain.cpp:  a11 = a*c / rsq1;
fix_restrain.cpp:  a12 = -a / (r1*r2);
fix_restrain.cpp:  a22 = a*c / rsq2;
fix_restrain.cpp:  // apply force to each of 3 atoms
fix_restrain.cpp:/* ----------------------------------------------------------------------
fix_restrain.cpp:---------------------------------------------------------------------- */
fix_restrain.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_restrain.cpp:  // newton_bond on: only processor owning i2 computes restraint
fix_restrain.cpp:  // newton_bond off: only processors owning any of i1-i4 computes restraint
fix_restrain.cpp:  // 1st bond
fix_restrain.cpp:  // 2nd bond
fix_restrain.cpp:  // 3rd bond
fix_restrain.cpp:  if (rg > 0) rginv = 1.0/rg;
fix_restrain.cpp:  if (rasq > 0) ra2inv = 1.0/rasq;
fix_restrain.cpp:  if (rbsq > 0) rb2inv = 1.0/rbsq;
fix_restrain.cpp:  // error check
fix_restrain.cpp:  mult = 1;  // multiplicity
fix_restrain.cpp:  // apply force to each of 4 atoms
fix_restrain.cpp:/* ----------------------------------------------------------------------
fix_restrain.cpp:------------------------------------------------------------------------- */
fix_setforce.cpp:/* ----------------------------------------------------------------------
fix_setforce.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_setforce.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_setforce.cpp:------------------------------------------------------------------------- */
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:  // optional args
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:  // check variables
fix_setforce.cpp:  // set index and check validity of region
fix_setforce.cpp:  // cannot use non-zero forces for a minimization since no energy is integrated
fix_setforce.cpp:  // use fix addforce instead
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:  // update region if necessary
fix_setforce.cpp:  // reallocate sforce array if necessary
fix_setforce.cpp:  // variable force, wrap with clear/add
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:  // set force to desired value on requested level, 0.0 on other levels
fix_setforce.cpp:/* ---------------------------------------------------------------------- */
fix_setforce.cpp:/* ----------------------------------------------------------------------
fix_setforce.cpp:------------------------------------------------------------------------- */
fix_setforce.cpp:  // only sum across procs one time
fix_setforce.cpp:/* ----------------------------------------------------------------------
fix_setforce.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_shear_history.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ---------------------------------------------------------------------- */
fix_shear_history.cpp:  if (newton_pair) comm_reverse = 1;   // just for single npartner value
fix_shear_history.cpp:                                       // variable-size history communicated via
fix_shear_history.cpp:                                       // reverse_comm_fix_variable()
fix_shear_history.cpp:  // perform initial allocation of atom-based arrays
fix_shear_history.cpp:  // register with atom class
fix_shear_history.cpp:  // initialize npartner to 0 so neighbor list creation is OK the 1st time
fix_shear_history.cpp:/* ---------------------------------------------------------------------- */
fix_shear_history.cpp:  // unregister this fix so atom class doesn't invoke it any more
fix_shear_history.cpp:  // delete locally stored arrays
fix_shear_history.cpp:  // to better detect use-after-delete errors
fix_shear_history.cpp:/* ---------------------------------------------------------------------- */
fix_shear_history.cpp:/* ---------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:   create pages if first time or if neighbor pgsize/oneatom has changed
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:     b/c there is no guarantee of a current neigh list (even on continued run)
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:   onesided version for sphere contact with line/tri particles
fix_shear_history.cpp:   neighbor list has I = sphere, J = line/tri
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:  // NOTE: all operations until very end are with nlocal_neigh <= current nlocal
fix_shear_history.cpp:  // b/c previous neigh list was built with nlocal_neigh
fix_shear_history.cpp:  // nlocal can be larger if other fixes added atoms at this pre_exchange()
fix_shear_history.cpp:  // zero npartner for owned atoms
fix_shear_history.cpp:  // clear 2 page data structures
fix_shear_history.cpp:  // 1st loop over neighbor list, I = sphere, J = tri
fix_shear_history.cpp:  // only calculate npartner for owned spheres
fix_shear_history.cpp:  // get page chunks to store atom IDs and shear history for owned atoms
fix_shear_history.cpp:  // 2nd loop over neighbor list, I = sphere, J = tri
fix_shear_history.cpp:  // store atom IDs and shear history for owned spheres
fix_shear_history.cpp:  // re-zero npartner to use as counter
fix_shear_history.cpp:  // set maxtouch = max # of partners of any owned atom
fix_shear_history.cpp:  // bump up comm->maxexchange_fix if necessary
fix_shear_history.cpp:  // zero npartner values from previous nlocal_neigh to current nlocal
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:   newton on version, for sphere/sphere contacts
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:  // NOTE: all operations until very end are with 
fix_shear_history.cpp:  //   nlocal_neigh  <= current nlocal and nall_neigh
fix_shear_history.cpp:  // b/c previous neigh list was built with nlocal_neigh,nghost_neigh
fix_shear_history.cpp:  // nlocal can be larger if other fixes added atoms at this pre_exchange()
fix_shear_history.cpp:  // zero npartner for owned+ghost atoms
fix_shear_history.cpp:  // clear 2 page data structures
fix_shear_history.cpp:  // 1st loop over neighbor list
fix_shear_history.cpp:  // calculate npartner for owned+ghost atoms
fix_shear_history.cpp:  // perform reverse comm to augment owned npartner counts with ghost counts
fix_shear_history.cpp:  // get page chunks to store atom IDs and shear history for owned+ghost atoms
fix_shear_history.cpp:  // 2nd loop over neighbor list
fix_shear_history.cpp:  // store atom IDs and shear history for owned+ghost atoms
fix_shear_history.cpp:  // re-zero npartner to use as counter
fix_shear_history.cpp:  // perform reverse comm to augment
fix_shear_history.cpp:  // owned atom partner/shearpartner with ghost info
fix_shear_history.cpp:  // use variable variant b/c size of packed data can be arbitrarily large
fix_shear_history.cpp:  //   if many touching neighbors for large particle
fix_shear_history.cpp:  // set maxtouch = max # of partners of any owned atom
fix_shear_history.cpp:  // bump up comm->maxexchange_fix if necessary
fix_shear_history.cpp:  // zero npartner values from previous nlocal_neigh to current nlocal
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:   newton off version, for sphere/sphere contacts
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:  // NOTE: all operations until very end are with nlocal_neigh <= current nlocal
fix_shear_history.cpp:  // b/c previous neigh list was built with nlocal_neigh
fix_shear_history.cpp:  // nlocal can be larger if other fixes added atoms at this pre_exchange()
fix_shear_history.cpp:  // zero npartner for owned atoms
fix_shear_history.cpp:  // clear 2 page data structures
fix_shear_history.cpp:  // 1st loop over neighbor list
fix_shear_history.cpp:  // calculate npartner for owned atoms
fix_shear_history.cpp:  // get page chunks to store atom IDs and shear history for owned atoms
fix_shear_history.cpp:  // 2nd loop over neighbor list
fix_shear_history.cpp:  // store atom IDs and shear history for owned atoms
fix_shear_history.cpp:  // re-zero npartner to use as counter
fix_shear_history.cpp:  // set maxtouch = max # of partners of any owned atom
fix_shear_history.cpp:  // bump up comm->maxexchange_fix if necessary
fix_shear_history.cpp:  // zero npartner values from previous nlocal_neigh to current nlocal
fix_shear_history.cpp:/* ---------------------------------------------------------------------- */
fix_shear_history.cpp:/* ---------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:  // just copy pointers for partner and shearpartner
fix_shear_history.cpp:  // b/c can't overwrite chunk allocation inside ipage,dpage
fix_shear_history.cpp:  // incoming atoms in unpack_exchange just grab new chunks
fix_shear_history.cpp:  // so are orphaning chunks for migrating atoms
fix_shear_history.cpp:  // OK, b/c will reset ipage,dpage on next reneighboring
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:  // NOTE: how do I know comm buf is big enough if extreme # of touching neighs
fix_shear_history.cpp:  // Comm::BUFEXTRA may need to be increased
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:  // allocate new chunks from ipage,dpage for incoming values
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:  // ipage = NULL if being called from granular pair style init()
fix_shear_history.cpp:  // skip to Nth set of extra values
fix_shear_history.cpp:  // allocate new chunks from ipage,dpage for incoming values
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_shear_history.cpp:  // maxtouch_all = max # of touching partners across all procs
fix_shear_history.cpp:/* ----------------------------------------------------------------------
fix_shear_history.cpp:------------------------------------------------------------------------- */
fix_spring_chunk.cpp:/* ----------------------------------------------------------------------
fix_spring_chunk.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_spring_chunk.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_spring_chunk.cpp:------------------------------------------------------------------------- */
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:  if (narg != 6) error->all(FLERR,"Illegal fix spring/chunk command");
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:  // decrement lock counter in compute chunk/atom, it if still exists
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:  // current indices for idchunk and idcom
fix_spring_chunk.cpp:    error->all(FLERR,"Chunk/atom compute does not exist for fix spring/chunk");
fix_spring_chunk.cpp:  if (strcmp(cchunk->style,"chunk/atom") != 0)
fix_spring_chunk.cpp:    error->all(FLERR,"Fix spring/chunk does not use chunk/atom compute");
fix_spring_chunk.cpp:    error->all(FLERR,"Com/chunk compute does not exist for fix spring/chunk");
fix_spring_chunk.cpp:  if (strcmp(ccom->style,"com/chunk") != 0)
fix_spring_chunk.cpp:    error->all(FLERR,"Fix spring/chunk does not use com/chunk compute");
fix_spring_chunk.cpp:  // check that idchunk is consistent with ccom->idchunk
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:  // check if first time cchunk will be queried via ccom
fix_spring_chunk.cpp:  // if so, lock idchunk for as long as this fix is in place
fix_spring_chunk.cpp:  // will be unlocked in destructor
fix_spring_chunk.cpp:  // necessary b/c this fix stores original COM
fix_spring_chunk.cpp:  // calculate current centers of mass for each chunk
fix_spring_chunk.cpp:  // extract pointers from idchunk and idcom
fix_spring_chunk.cpp:  // check if first time cchunk was queried via ccom
fix_spring_chunk.cpp:  // if so, allocate com0,fcom and store initial COM
fix_spring_chunk.cpp:    memory->create(com0,nchunk,3,"spring/chunk:com0");
fix_spring_chunk.cpp:    memory->create(fcom,nchunk,3,"spring/chunk:fcom");
fix_spring_chunk.cpp:  // calculate fcom = force on each COM, divided by masstotal
fix_spring_chunk.cpp:      fcom[m][0] = k_spring*dx/r / masstotal[m];
fix_spring_chunk.cpp:      fcom[m][1] = k_spring*dy/r / masstotal[m];
fix_spring_chunk.cpp:      fcom[m][2] = k_spring*dz/r / masstotal[m];
fix_spring_chunk.cpp:  // apply restoring force to atoms in each chunk
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:/* ---------------------------------------------------------------------- */
fix_spring_chunk.cpp:/* ----------------------------------------------------------------------
fix_spring_chunk.cpp:------------------------------------------------------------------------- */
fix_spring.cpp:/* ----------------------------------------------------------------------
fix_spring.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_spring.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_spring.cpp:------------------------------------------------------------------------- */
fix_spring.cpp:/* ----------------------------------------------------------------------
fix_spring.cpp:------------------------------------------------------------------------- */
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:  // recheck that group 2 has not been deleted
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:  // fx,fy,fz = components of k * (r-r0) / masstotal
fix_spring.cpp:  fx = k_spring*dx*dr/r;
fix_spring.cpp:  fy = k_spring*dy*dr/r;
fix_spring.cpp:  fz = k_spring*dz*dr/r;
fix_spring.cpp:    fx /= masstotal;
fix_spring.cpp:    fy /= masstotal;
fix_spring.cpp:    fz /= masstotal;
fix_spring.cpp:  // apply restoring force to atoms in group
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:  // fx,fy,fz = components of k * (r-r0) / masstotal
fix_spring.cpp:  // fx2,fy2,fz2 = components of k * (r-r0) / masstotal2
fix_spring.cpp:  fx = k_spring*dx*dr/r;
fix_spring.cpp:  fy = k_spring*dy*dr/r;
fix_spring.cpp:  fz = k_spring*dz*dr/r;
fix_spring.cpp:    fx2 = fx/masstotal2;
fix_spring.cpp:    fy2 = fy/masstotal2;
fix_spring.cpp:    fz2 = fz/masstotal2;
fix_spring.cpp:    fx /= masstotal;
fix_spring.cpp:    fy /= masstotal;
fix_spring.cpp:    fz /= masstotal;
fix_spring.cpp:  // apply restoring force to atoms in group
fix_spring.cpp:  // f = -k*(r-r0)*mass/masstotal
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:/* ---------------------------------------------------------------------- */
fix_spring.cpp:/* ----------------------------------------------------------------------
fix_spring.cpp:------------------------------------------------------------------------- */
fix_spring.cpp:/* ----------------------------------------------------------------------
fix_spring.cpp:------------------------------------------------------------------------- */
fix_spring_rg.cpp:/* ----------------------------------------------------------------------
fix_spring_rg.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_spring_rg.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_spring_rg.cpp:------------------------------------------------------------------------- */
fix_spring_rg.cpp:/* ----------------------------------------------------------------------
fix_spring_rg.cpp:------------------------------------------------------------------------- */
fix_spring_rg.cpp:/* ---------------------------------------------------------------------- */
fix_spring_rg.cpp:  if (narg != 5) error->all(FLERR,"Illegal fix spring/rg command");
fix_spring_rg.cpp:/* ---------------------------------------------------------------------- */
fix_spring_rg.cpp:/* ---------------------------------------------------------------------- */
fix_spring_rg.cpp:  // if rg0 was specified as NULL, compute current Rg
fix_spring_rg.cpp:  // only occurs on 1st run
fix_spring_rg.cpp:/* ---------------------------------------------------------------------- */
fix_spring_rg.cpp:/* ---------------------------------------------------------------------- */
fix_spring_rg.cpp:  // compute current Rg and center-of-mass
fix_spring_rg.cpp:  // apply restoring force to atoms in group
fix_spring_rg.cpp:  // f = -k*(r-r0)*mass/masstotal
fix_spring_rg.cpp:      term1 = 2.0 * k * (1.0 - rg0/rg);
fix_spring_rg.cpp:        if (rmass) massfrac = rmass[i]/masstotal;
fix_spring_rg.cpp:        else  massfrac = mass[type[i]]/masstotal;
fix_spring_rg.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_spring_self.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:    error->all(FLERR,"Illegal fix spring/self command");
fix_spring_self.cpp:  if (k <= 0.0) error->all(FLERR,"Illegal fix spring/self command");
fix_spring_self.cpp:    } else error->all(FLERR,"Illegal fix spring/self command");
fix_spring_self.cpp:  // perform initial allocation of atom-based array
fix_spring_self.cpp:  // register with Atom class
fix_spring_self.cpp:  // xoriginal = initial unwrapped positions of atoms
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:  // unregister callbacks to this fix from Atom class
fix_spring_self.cpp:  // delete locally stored array
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:/* ---------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:  memory->grow(xoriginal,nmax,3,"fix_spring/self:xoriginal");
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:  // skip to Nth set of extra values
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_spring_self.cpp:/* ----------------------------------------------------------------------
fix_spring_self.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_store.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ---------------------------------------------------------------------- */
fix_store.cpp:  // 4th arg determines GLOBAL vs PERATOM values
fix_store.cpp:  // syntax: id group style global nrow ncol
fix_store.cpp:  //   Nrow by Ncol array of global values
fix_store.cpp:  //   Ncol = 1 is vector, Ncol > 1 is array
fix_store.cpp:  // syntax: id group style peratom 0/1 nvalues
fix_store.cpp:  //   0/1 flag = not-store or store peratom values in restart file
fix_store.cpp:  //   nvalues = # of peratom values, N = 1 is vector, N > 1 is array
fix_store.cpp:  // GLOBAL values are always written to restart file
fix_store.cpp:  // PERATOM restart_peratom is set by caller
fix_store.cpp:  // allocate vector or array and restart buffer rbuf
fix_store.cpp:  // for PERATOM, register with Atom class
fix_store.cpp:    if (vecflag) memory->create(vstore,nrow,"fix/store:vstore");
fix_store.cpp:    else memory->create(astore,nrow,ncol,"fix/store:astore");
fix_store.cpp:    memory->create(rbuf,nrow*ncol+2,"fix/store:rbuf");
fix_store.cpp:  // zero the storage
fix_store.cpp:  // PERATOM may be comm->exchanged before filled by caller
fix_store.cpp:/* ---------------------------------------------------------------------- */
fix_store.cpp:  // unregister callbacks to this fix from Atom class
fix_store.cpp:/* ---------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:   reset size of global vector/array
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:  if (vecflag) memory->create(vstore,nrow,"fix/store:vstore");
fix_store.cpp:  else memory->create(astore,nrow,ncol,"fix/store:astore");
fix_store.cpp:  memory->create(rbuf,nrow*ncol+2,"fix/store:rbuf");
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:  // fill rbuf with size and vec/array values
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:  // first 2 values in buf are vec/array sizes
fix_store.cpp:  // if size of vec/array has changed,
fix_store.cpp:  //   means the restart file is setting size of vec or array and doing init
fix_store.cpp:  //   because caller did not know size at time this fix was instantiated
fix_store.cpp:  // reallocate vstore or astore accordingly
fix_store.cpp:    if (vecflag) memory->create(vstore,nrow,"fix/store:vstore");
fix_store.cpp:    else memory->create(astore,nrow,ncol,"fix/store:astore");
fix_store.cpp:    memory->create(rbuf,nrow*ncol+2,"fix/store:rbuf");
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:  // skip to Nth set of extra values
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store.cpp:/* ----------------------------------------------------------------------
fix_store.cpp:------------------------------------------------------------------------- */
fix_store_force.cpp:/* ----------------------------------------------------------------------
fix_store_force.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_store_force.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_store_force.cpp:------------------------------------------------------------------------- */
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:  if (narg < 3) error->all(FLERR,"Illegal fix store/coord command");
fix_store_force.cpp:  memory->create(foriginal,nmax,3,"store/force:foriginal");
fix_store_force.cpp:  // zero the array since dump may access it on timestep 0
fix_store_force.cpp:  // zero the array since a variable may access it before first run
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:    memory->create(foriginal,nmax,3,"store/force:foriginal");
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:/* ---------------------------------------------------------------------- */
fix_store_force.cpp:/* ----------------------------------------------------------------------
fix_store_force.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_store_state.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  if (narg < 5) error->all(FLERR,"Illegal fix store/state command");
fix_store_state.cpp:  if (nevery < 0) error->all(FLERR,"Illegal fix store/state command");
fix_store_state.cpp:  // parse values until one isn't recognized
fix_store_state.cpp:  // customize a new keyword by adding to if statement
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:                   "Fix store/state for atom property that isn't allocated");
fix_store_state.cpp:          error->all(FLERR,"Illegal fix store/state command");
fix_store_state.cpp:  // optional args
fix_store_state.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix store/state command");
fix_store_state.cpp:      else error->all(FLERR,"Illegal fix store/state command");
fix_store_state.cpp:    } else error->all(FLERR,"Illegal fix store/state command");
fix_store_state.cpp:  // error check
fix_store_state.cpp:        error->all(FLERR,"Compute ID for fix store/state does not exist");
fix_store_state.cpp:        error->all(FLERR,"Fix store/state compute "
fix_store_state.cpp:        error->all(FLERR,"Fix store/state compute does not "
fix_store_state.cpp:                   "Fix store/state compute does not "
fix_store_state.cpp:                   "Fix store/state compute array is accessed out-of-range");
fix_store_state.cpp:                   "Custom integer vector for fix store/state does not exist");
fix_store_state.cpp:                   "Custom floating point vector for fix store/state does not exist");
fix_store_state.cpp:                   "Fix ID for fix store/state does not exist");
fix_store_state.cpp:                   "Fix store/state fix does not calculate per-atom values");
fix_store_state.cpp:                   "Fix store/state fix does not calculate a per-atom vector");
fix_store_state.cpp:                   "Fix store/state fix does not calculate a per-atom array");
fix_store_state.cpp:                   "Fix store/state fix array is accessed out-of-range");
fix_store_state.cpp:                   "Fix for fix store/state not computed at compatible time");
fix_store_state.cpp:        error->all(FLERR,"Variable name for fix store/state does not exist");
fix_store_state.cpp:        error->all(FLERR,"Fix store/state variable is not atom-style variable");
fix_store_state.cpp:  // this fix produces either a per-atom vector or array
fix_store_state.cpp:  // perform initial allocation of atom-based array
fix_store_state.cpp:  // register with Atom class
fix_store_state.cpp:  // zero the array since dump may access it on timestep 0
fix_store_state.cpp:  // zero the array since a variable may access it before first run
fix_store_state.cpp:  // store current values for keywords but not for compute, fix, variable
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  // unregister callbacks to this fix from Atom class
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  // set indices and check validity of all computes,fixes,variables
fix_store_state.cpp:  // no error check if end_of_step() will not be called
fix_store_state.cpp:        error->all(FLERR,"Compute ID for fix store/state does not exist");
fix_store_state.cpp:		   "Custom integer vector for fix store/state does not exist");
fix_store_state.cpp:		   "Custom floating point vector for fix store/state does not exist");
fix_store_state.cpp:        error->all(FLERR,"Fix ID for fix store/state does not exist");
fix_store_state.cpp:        error->all(FLERR,"Variable name for fix store/state does not exist");
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  // if first invocation, store current values for compute, fix, variable
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  // compute com if comflag set
fix_store_state.cpp:  // if any compute/fix/variable and nevery, wrap with clear/add
fix_store_state.cpp:  // fill vector or array with per-atom values
fix_store_state.cpp:      // invoke compute if not previously invoked
fix_store_state.cpp:      // access fix fields, guaranteed to be ready
fix_store_state.cpp:      // access custom atom property fields
fix_store_state.cpp:      // evaluate atom-style variable
fix_store_state.cpp:  // if any compute/fix/variable and nevery, wrap with clear/add
fix_store_state.cpp:    const bigint nextstep = (update->ntimestep/nevery)*nevery + nevery;
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:  memory->grow(values,nmax,nvalues,"store/state:values");
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:  // skip to Nth set of extra values
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ----------------------------------------------------------------------
fix_store_state.cpp:   one method for every keyword fix store/state can archive
fix_store_state.cpp:------------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  double invxprd = 1.0/domain->xprd;
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  double invyprd = 1.0/domain->yprd;
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  double invzprd = 1.0/domain->zprd;
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  double invxprd = 1.0/domain->xprd;
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  double invyprd = 1.0/domain->yprd;
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:  double invzprd = 1.0/domain->zprd;
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_store_state.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:/* ----------------------------------------------------------------------
fix_temp_berendsen.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_temp_berendsen.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_temp_berendsen.cpp:------------------------------------------------------------------------- */
fix_temp_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:  if (narg != 6) error->all(FLERR,"Illegal fix temp/berendsen command");
fix_temp_berendsen.cpp:  // Berendsen thermostat should be applied every step
fix_temp_berendsen.cpp:  // error checks
fix_temp_berendsen.cpp:    error->all(FLERR,"Fix temp/berendsen period must be > 0.0");
fix_temp_berendsen.cpp:  // create a new compute temp style
fix_temp_berendsen.cpp:  // id = fix-ID + temp, compute group = fix group
fix_temp_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:  // delete temperature if fix created it
fix_temp_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:  // check variable
fix_temp_berendsen.cpp:      error->all(FLERR,"Variable name for fix temp/berendsen does not exist");
fix_temp_berendsen.cpp:    else error->all(FLERR,"Variable for fix temp/berendsen is invalid style");
fix_temp_berendsen.cpp:    error->all(FLERR,"Temperature ID for fix temp/berendsen does not exist");
fix_temp_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:  // there is nothing to do, if there are no degrees of freedom
fix_temp_berendsen.cpp:               "Computed temperature for fix temp/berendsen cannot be 0.0");
fix_temp_berendsen.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_temp_berendsen.cpp:  // set current t_target
fix_temp_berendsen.cpp:  // if variable temp, evaluate variable, wrap with clear/add
fix_temp_berendsen.cpp:                 "Fix temp/berendsen variable returned negative temperature");
fix_temp_berendsen.cpp:  // rescale velocities by lamda
fix_temp_berendsen.cpp:  // for BIAS:
fix_temp_berendsen.cpp:  //   temperature is current, so do not need to re-compute
fix_temp_berendsen.cpp:  //   OK to not test returned v = 0, since lamda is multiplied by v
fix_temp_berendsen.cpp:  double lamda = sqrt(1.0 + update->dt/t_period*(t_target/t_current - 1.0));
fix_temp_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:/* ---------------------------------------------------------------------- */
fix_temp_berendsen.cpp:/* ----------------------------------------------------------------------
fix_temp_berendsen.cpp:------------------------------------------------------------------------- */
fix_temp_csld.cpp:/* ----------------------------------------------------------------------
fix_temp_csld.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_temp_csld.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_temp_csld.cpp:------------------------------------------------------------------------- */
fix_temp_csld.cpp:/* ----------------------------------------------------------------------
fix_temp_csld.cpp:------------------------------------------------------------------------- */
fix_temp_csld.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csld.cpp:  if (narg != 7) error->all(FLERR,"Illegal fix temp/csld command");
fix_temp_csld.cpp:  // CSLD thermostat should be applied every step
fix_temp_csld.cpp:  // error checks
fix_temp_csld.cpp:  if (t_period <= 0.0) error->all(FLERR,"Illegal fix temp/csld command");
fix_temp_csld.cpp:  if (seed <= 0) error->all(FLERR,"Illegal fix temp/csld  command");
fix_temp_csld.cpp:  // create a new compute temp style
fix_temp_csld.cpp:  // id = fix-ID + temp, compute group = fix group
fix_temp_csld.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csld.cpp:  // delete temperature if fix created it
fix_temp_csld.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csld.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csld.cpp:  // we cannot handle constraints via rattle or shake correctly.
fix_temp_csld.cpp:    error->all(FLERR,"Fix temp/csld is not compatible with fix rattle or fix shake");
fix_temp_csld.cpp:  // check variable
fix_temp_csld.cpp:      error->all(FLERR,"Variable name for fix temp/csld does not exist");
fix_temp_csld.cpp:    else error->all(FLERR,"Variable for fix temp/csld is invalid style");
fix_temp_csld.cpp:    error->all(FLERR,"Temperature ID for fix temp/csld does not exist");
fix_temp_csld.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csld.cpp:  // set current t_target
fix_temp_csld.cpp:  // if variable temp, evaluate variable, wrap with clear/add
fix_temp_csld.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_temp_csld.cpp:                 "Fix temp/csld variable returned negative temperature");
fix_temp_csld.cpp:  // there is nothing to do, if there are no degrees of freedom
fix_temp_csld.cpp:  // adjust holding space, if needed and copy existing velocities
fix_temp_csld.cpp:  // The CSLD thermostat is a linear combination of old and new velocities,
fix_temp_csld.cpp:  // where the new ones are randomly chosen from a gaussian distribution.
fix_temp_csld.cpp:  // see Bussi and Parrinello, Phys. Rev. E (2007).
fix_temp_csld.cpp:      const double factor = 1.0/sqrt(m);
fix_temp_csld.cpp:  // mixing factors
fix_temp_csld.cpp:  const double c1 = exp(-update->dt/t_period);
fix_temp_csld.cpp:  const double c2 = sqrt((1.0-c1*c1)*t_target/temperature->compute_scalar());
fix_temp_csld.cpp:  // tally the kinetic energy transferred between heat bath and system
fix_temp_csld.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csld.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csld.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csld.cpp:/* ----------------------------------------------------------------------
fix_temp_csld.cpp:------------------------------------------------------------------------- */
fix_temp_csvr.cpp:/* ----------------------------------------------------------------------
fix_temp_csvr.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_temp_csvr.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_temp_csvr.cpp:------------------------------------------------------------------------- */
fix_temp_csvr.cpp:/* ----------------------------------------------------------------------
fix_temp_csvr.cpp:------------------------------------------------------------------------- */
fix_temp_csvr.cpp:    // make certain, that -log() doesn't overflow.
fix_temp_csvr.cpp:        y=v2/v1;
fix_temp_csvr.cpp:      if (am*log(x/am)-s*y < -700 || v1<0.00001) {
fix_temp_csvr.cpp:      e=(1.0+y*y)*exp(am*log(x/am)-s*y);
fix_temp_csvr.cpp:/* -------------------------------------------------------------------
fix_temp_csvr.cpp:---------------------------------------------------------------------- */
fix_temp_csvr.cpp:    return 2.0 * gamdev(nn / 2);
fix_temp_csvr.cpp:    return  2.0 * gamdev((nn-1) / 2) + rr*rr;
fix_temp_csvr.cpp:/* -------------------------------------------------------------------
fix_temp_csvr.cpp:---------------------------------------------------------------------- */
fix_temp_csvr.cpp:  const double c1 = exp(-update->dt/t_period);
fix_temp_csvr.cpp:  const double c2 = (1.0-c1)*ekin_new/ekin_old/tdof;
fix_temp_csvr.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csvr.cpp:  if (narg != 7) error->all(FLERR,"Illegal fix temp/csvr command");
fix_temp_csvr.cpp:  // CSVR thermostat should be applied every step
fix_temp_csvr.cpp:  // error checks
fix_temp_csvr.cpp:  if (t_period <= 0.0) error->all(FLERR,"Illegal fix temp/csvr command");
fix_temp_csvr.cpp:  if (seed <= 0) error->all(FLERR,"Illegal fix temp/csvr command");
fix_temp_csvr.cpp:  // create a new compute temp style
fix_temp_csvr.cpp:  // id = fix-ID + temp, compute group = fix group
fix_temp_csvr.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csvr.cpp:  // delete temperature if fix created it
fix_temp_csvr.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csvr.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csvr.cpp:  // check variable
fix_temp_csvr.cpp:      error->all(FLERR,"Variable name for fix temp/csvr does not exist");
fix_temp_csvr.cpp:    else error->all(FLERR,"Variable for fix temp/csvr is invalid style");
fix_temp_csvr.cpp:    error->all(FLERR,"Temperature ID for fix temp/csvr does not exist");
fix_temp_csvr.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csvr.cpp:  // set current t_target
fix_temp_csvr.cpp:  // if variable temp, evaluate variable, wrap with clear/add
fix_temp_csvr.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_temp_csvr.cpp:                 "Fix temp/csvr variable returned negative temperature");
fix_temp_csvr.cpp:  // there is nothing to do, if there are no degrees of freedom
fix_temp_csvr.cpp:  // compute velocity scaling factor on root node and broadcast
fix_temp_csvr.cpp:  // tally the kinetic energy transferred between heat bath and system
fix_temp_csvr.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csvr.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csvr.cpp:/* ---------------------------------------------------------------------- */
fix_temp_csvr.cpp:/* ----------------------------------------------------------------------
fix_temp_csvr.cpp:------------------------------------------------------------------------- */
fix_temp_rescale.cpp:/* ----------------------------------------------------------------------
fix_temp_rescale.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_temp_rescale.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_temp_rescale.cpp:------------------------------------------------------------------------- */
fix_temp_rescale.cpp:/* ---------------------------------------------------------------------- */
fix_temp_rescale.cpp:  if (narg < 8) error->all(FLERR,"Illegal fix temp/rescale command");
fix_temp_rescale.cpp:  if (nevery <= 0) error->all(FLERR,"Illegal fix temp/rescale command");
fix_temp_rescale.cpp:  // create a new compute temp
fix_temp_rescale.cpp:  // id = fix-ID + temp, compute group = fix group
fix_temp_rescale.cpp:/* ---------------------------------------------------------------------- */
fix_temp_rescale.cpp:  // delete temperature if fix created it
fix_temp_rescale.cpp:/* ---------------------------------------------------------------------- */
fix_temp_rescale.cpp:/* ---------------------------------------------------------------------- */
fix_temp_rescale.cpp:  // check variable
fix_temp_rescale.cpp:      error->all(FLERR,"Variable name for fix temp/rescale does not exist");
fix_temp_rescale.cpp:    else error->all(FLERR,"Variable for fix temp/rescale is invalid style");
fix_temp_rescale.cpp:    error->all(FLERR,"Temperature ID for fix temp/rescale does not exist");
fix_temp_rescale.cpp:/* ---------------------------------------------------------------------- */
fix_temp_rescale.cpp:  // there is nothing to do, if there are no degrees of freedom
fix_temp_rescale.cpp:  // protect against division by zero
fix_temp_rescale.cpp:    error->all(FLERR,"Computed temperature for fix temp/rescale cannot be 0.0");
fix_temp_rescale.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_temp_rescale.cpp:  // set current t_target
fix_temp_rescale.cpp:  // if variable temp, evaluate variable, wrap with clear/add
fix_temp_rescale.cpp:                 "Fix temp/rescale variable returned negative temperature");
fix_temp_rescale.cpp:  // rescale velocity of appropriate atoms if outside window
fix_temp_rescale.cpp:  // for BIAS:
fix_temp_rescale.cpp:  //   temperature is current, so do not need to re-compute
fix_temp_rescale.cpp:  //   OK to not test returned v = 0, since factor is multiplied by v
fix_temp_rescale.cpp:    double factor = sqrt(t_target/t_current);
fix_temp_rescale.cpp:/* ---------------------------------------------------------------------- */
fix_temp_rescale.cpp:/* ---------------------------------------------------------------------- */
fix_temp_rescale.cpp:/* ---------------------------------------------------------------------- */
fix_temp_rescale.cpp:/* ----------------------------------------------------------------------
fix_temp_rescale.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_tmd.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ---------------------------------------------------------------------- */
fix_tmd.cpp:  // perform initial allocation of atom-based arrays
fix_tmd.cpp:  // register with Atom class
fix_tmd.cpp:  // make sure an atom map exists before reading in target coordinates
fix_tmd.cpp:  // read from arg[4] and store coordinates of final target in xf
fix_tmd.cpp:  // open arg[6] statistics file and write header
fix_tmd.cpp:  // rho_start = initial rho
fix_tmd.cpp:  // xold = initial x or 0.0 if not in group
fix_tmd.cpp:  rho_start = sqrt(rho_start_total/masstotal);
fix_tmd.cpp:/* ---------------------------------------------------------------------- */
fix_tmd.cpp:  // unregister callbacks to this fix from Atom class
fix_tmd.cpp:  // delete locally stored arrays
fix_tmd.cpp:/* ---------------------------------------------------------------------- */
fix_tmd.cpp:/* ---------------------------------------------------------------------- */
fix_tmd.cpp:  // check that no integrator fix comes after a TMD fix
fix_tmd.cpp:  // timesteps
fix_tmd.cpp:/* ---------------------------------------------------------------------- */
fix_tmd.cpp:  if (delta != 0.0) delta /= update->endstep - update->beginstep;
fix_tmd.cpp:  // compute the Lagrange multiplier
fix_tmd.cpp:  a = abetotal[0]/masstotal;
fix_tmd.cpp:  b = 2.0*abetotal[1]/masstotal;
fix_tmd.cpp:  e = abetotal[2]/masstotal;
fix_tmd.cpp:  if (b >= 0) gamma_max = (-b - sqrt(d))/(2*a);
fix_tmd.cpp:  else        gamma_max = (-b + sqrt(d))/(2*a);
fix_tmd.cpp:  gamma_back = c/(a*gamma_max);
fix_tmd.cpp:  if (b >= 0) gamma_max = (-b - sqrt(d))/(2*a);
fix_tmd.cpp:  else        gamma_max = (-b + sqrt(d))/(2*a);
fix_tmd.cpp:  gamma_forward = c/(a*gamma_max);
fix_tmd.cpp:  // stat write of mean constraint force based on previous time step constraint
fix_tmd.cpp:      (-frtotal - kttotal/dtv/dtf)*(rho_target - rho_old)/rho_old;
fix_tmd.cpp:    lambda = gamma_back*rho_old*masstotal/dtv/dtf;
fix_tmd.cpp:  // apply the constraint and save constrained positions for next step
fix_tmd.cpp:      dtfm = dtf / mass[type[i]];
fix_tmd.cpp:      v[i][0] += gamma_forward*dxold/dtv;
fix_tmd.cpp:      f[i][0] += gamma_forward*dxold/dtv/dtfm;
fix_tmd.cpp:      v[i][1] += gamma_forward*dyold/dtv;
fix_tmd.cpp:      f[i][1] += gamma_forward*dyold/dtv/dtfm;
fix_tmd.cpp:      v[i][2] += gamma_forward*dzold/dtv;
fix_tmd.cpp:      f[i][2] += gamma_forward*dzold/dtv/dtfm;
fix_tmd.cpp:/* ---------------------------------------------------------------------- */
fix_tmd.cpp:  if (flag) return;             // only used by NPT,NPH
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:    MPI_Bcast(&eof,sizeof(char *)/sizeof(char),MPI_CHAR,0,world);
fix_tmd.cpp:  // clean up
fix_tmd.cpp:  // check that all atoms in group were listed in target file
fix_tmd.cpp:  // set xf = 0.0 for atoms not in group
fix_tmd.cpp:/* ----------------------------------------------------------------------
fix_tmd.cpp:------------------------------------------------------------------------- */
fix_tmd.cpp:/* ---------------------------------------------------------------------- */
fix_vector.cpp:/* ----------------------------------------------------------------------
fix_vector.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_vector.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_vector.cpp:------------------------------------------------------------------------- */
fix_vector.cpp:/* ---------------------------------------------------------------------- */
fix_vector.cpp:  // setup and error check
fix_vector.cpp:  // for fix inputs, check that fix frequency is acceptable
fix_vector.cpp:  // this fix produces either a global vector or array
fix_vector.cpp:  // intensive/extensive flags set by compute,fix,variable that produces value
fix_vector.cpp:                 "intensive/extensive from these inputs");
fix_vector.cpp:  // ncount = current size of vector or array
fix_vector.cpp:  // nextstep = next step on which end_of_step does something
fix_vector.cpp:  // add nextstep to all computes that store invocation times
fix_vector.cpp:  // since don't know a priori which are invoked by this fix
fix_vector.cpp:  // once in end_of_step() can set timestep for ones actually invoked
fix_vector.cpp:  nextstep = (update->ntimestep/nevery)*nevery;
fix_vector.cpp:  // initialstep = first step the vector/array will store values for
fix_vector.cpp:/* ---------------------------------------------------------------------- */
fix_vector.cpp:/* ---------------------------------------------------------------------- */
fix_vector.cpp:/* ---------------------------------------------------------------------- */
fix_vector.cpp:  // set current indices for all computes,fixes,variables
fix_vector.cpp:  // reallocate vector or array for accumulated size at end of run
fix_vector.cpp:  // use endstep to allow for subsequent runs with "pre no"
fix_vector.cpp:  // nsize = # of entries from initialstep to finalstep
fix_vector.cpp:  bigint finalstep = update->endstep/nevery * nevery;
fix_vector.cpp:  ncountmax = (finalstep-initialstep)/nevery + 1;
fix_vector.cpp:/* ----------------------------------------------------------------------
fix_vector.cpp:------------------------------------------------------------------------- */
fix_vector.cpp:/* ---------------------------------------------------------------------- */
fix_vector.cpp:  // skip if not step which requires doing something
fix_vector.cpp:  // accumulate results of computes,fixes,variables to local copy
fix_vector.cpp:  // compute/fix/variable may invoke computes so wrap with clear/add
fix_vector.cpp:    // invoke compute if not previously invoked
fix_vector.cpp:    // access fix fields, guaranteed to be ready
fix_vector.cpp:    // evaluate equal-style or vector-style variable
fix_vector.cpp:  // trigger computes on next needed step
fix_vector.cpp:  // update size of vector or array
fix_vector.cpp:/* ----------------------------------------------------------------------
fix_vector.cpp:------------------------------------------------------------------------- */
fix_vector.cpp:/* ----------------------------------------------------------------------
fix_vector.cpp:------------------------------------------------------------------------- */
fix_viscous.cpp:/* ----------------------------------------------------------------------
fix_viscous.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_viscous.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_viscous.cpp:------------------------------------------------------------------------- */
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_viscous.cpp:  // optional args
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_viscous.cpp:  // apply drag force to atoms in group
fix_viscous.cpp:  // direction is opposed to velocity vector
fix_viscous.cpp:  // magnitude depends on atom type
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_viscous.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:/* ----------------------------------------------------------------------
fix_wall.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_wall.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_wall.cpp:------------------------------------------------------------------------- */
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:  // parse args
fix_wall.cpp:        int dim = wallwhich[nwall] / 2;
fix_wall.cpp:  // error checks
fix_wall.cpp:      error->all(FLERR,"Cannot use fix wall zlo/zhi for a 2d simulation");
fix_wall.cpp:  // scale factors for wall position for CONSTANT and VARIABLE walls
fix_wall.cpp:  // set xflag if any wall positions are variable
fix_wall.cpp:  // set varflag if any wall positions or parameters are variable
fix_wall.cpp:  // set wstyle to VARIABLE if either epsilon or sigma is a variable
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:  // FLD implicit needs to invoke wall forces before pair style
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:  // setup coefficients
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:/* ----------------------------------------------------------------------
fix_wall.cpp:------------------------------------------------------------------------- */
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:  // coord = current position of wall
fix_wall.cpp:  // evaluate variables if necessary, wrap with clear/add
fix_wall.cpp:  // for epsilon/sigma variables need to re-invoke precompute()
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:/* ---------------------------------------------------------------------- */
fix_wall.cpp:/* ----------------------------------------------------------------------
fix_wall.cpp:------------------------------------------------------------------------- */
fix_wall.cpp:  // only sum across procs one time
fix_wall.cpp:/* ----------------------------------------------------------------------
fix_wall.cpp:------------------------------------------------------------------------- */
fix_wall.cpp:  // only sum across procs one time
fix_wall_harmonic.cpp:/* ----------------------------------------------------------------------
fix_wall_harmonic.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_wall_harmonic.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_wall_harmonic.cpp:------------------------------------------------------------------------- */
fix_wall_harmonic.cpp:/* ---------------------------------------------------------------------- */
fix_wall_harmonic.cpp:/* ----------------------------------------------------------------------
fix_wall_harmonic.cpp:------------------------------------------------------------------------- */
fix_wall_harmonic.cpp:  int dim = which / 2;
fix_wall_lj1043.cpp:/* ----------------------------------------------------------------------
fix_wall_lj1043.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_wall_lj1043.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_wall_lj1043.cpp:------------------------------------------------------------------------- */
fix_wall_lj1043.cpp:/* ----------------------------------------------------------------------
fix_wall_lj1043.cpp:------------------------------------------------------------------------- */
fix_wall_lj1043.cpp:/* ---------------------------------------------------------------------- */
fix_wall_lj1043.cpp:/* ---------------------------------------------------------------------- */
fix_wall_lj1043.cpp:  coeff1[m] = MY_2PI * 2.0/5.0 * epsilon[m] * pow(sigma[m],10.0);
fix_wall_lj1043.cpp:  coeff3[m] = MY_2PI * pow(2.0,1/2.0) / 3 * epsilon[m] * pow(sigma[m],3.0);
fix_wall_lj1043.cpp:  coeff4[m] = 0.61 / pow(2.0,1/2.0) * sigma[m];
fix_wall_lj1043.cpp:  double rinv = 1.0/cutoff[m];
fix_wall_lj1043.cpp:/* ---------------------------------------------------------------------- */
fix_wall_lj1043.cpp:  int dim = which / 2;
fix_wall_lj1043.cpp:      rinv = 1.0/delta;
fix_wall_lj126.cpp:/* ----------------------------------------------------------------------
fix_wall_lj126.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_wall_lj126.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_wall_lj126.cpp:------------------------------------------------------------------------- */
fix_wall_lj126.cpp:/* ---------------------------------------------------------------------- */
fix_wall_lj126.cpp:/* ---------------------------------------------------------------------- */
fix_wall_lj126.cpp:  double r2inv = 1.0/(cutoff[m]*cutoff[m]);
fix_wall_lj126.cpp:/* ----------------------------------------------------------------------
fix_wall_lj126.cpp:------------------------------------------------------------------------- */
fix_wall_lj126.cpp:  int dim = which / 2;
fix_wall_lj126.cpp:      rinv = 1.0/delta;
fix_wall_lj93.cpp:/* ----------------------------------------------------------------------
fix_wall_lj93.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_wall_lj93.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_wall_lj93.cpp:------------------------------------------------------------------------- */
fix_wall_lj93.cpp:/* ---------------------------------------------------------------------- */
fix_wall_lj93.cpp:/* ---------------------------------------------------------------------- */
fix_wall_lj93.cpp:  coeff1[m] = 6.0/5.0 * epsilon[m] * pow(sigma[m],9.0);
fix_wall_lj93.cpp:  coeff3[m] = 2.0/15.0 * epsilon[m] * pow(sigma[m],9.0);
fix_wall_lj93.cpp:  double rinv = 1.0/cutoff[m];
fix_wall_lj93.cpp:/* ----------------------------------------------------------------------
fix_wall_lj93.cpp:------------------------------------------------------------------------- */
fix_wall_lj93.cpp:  int dim = which / 2;
fix_wall_lj93.cpp:      rinv = 1.0/delta;
fix_wall_reflect.cpp:/* ----------------------------------------------------------------------
fix_wall_reflect.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_wall_reflect.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_wall_reflect.cpp:------------------------------------------------------------------------- */
fix_wall_reflect.cpp:/* ---------------------------------------------------------------------- */
fix_wall_reflect.cpp:  if (narg < 4) error->all(FLERR,"Illegal fix wall/reflect command");
fix_wall_reflect.cpp:  // parse args
fix_wall_reflect.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal fix wall/reflect command");
fix_wall_reflect.cpp:          error->all(FLERR,"Wall defined twice in fix wall/reflect command");
fix_wall_reflect.cpp:        int dim = wallwhich[nwall] / 2;
fix_wall_reflect.cpp:      if (iarg+2 > narg) error->all(FLERR,"Illegal wall/reflect command");
fix_wall_reflect.cpp:      else error->all(FLERR,"Illegal fix wall/reflect command");
fix_wall_reflect.cpp:    } else error->all(FLERR,"Illegal fix wall/reflect command");
fix_wall_reflect.cpp:  // error check
fix_wall_reflect.cpp:      error->all(FLERR,"Cannot use fix wall/reflect in periodic dimension");
fix_wall_reflect.cpp:      error->all(FLERR,"Cannot use fix wall/reflect in periodic dimension");
fix_wall_reflect.cpp:      error->all(FLERR,"Cannot use fix wall/reflect in periodic dimension");
fix_wall_reflect.cpp:                 "Cannot use fix wall/reflect zlo/zhi for a 2d simulation");
fix_wall_reflect.cpp:  // scale factors for CONSTANT and VARIABLE walls
fix_wall_reflect.cpp:  // set varflag if any wall positions are variable
fix_wall_reflect.cpp:/* ---------------------------------------------------------------------- */
fix_wall_reflect.cpp:/* ---------------------------------------------------------------------- */
fix_wall_reflect.cpp:/* ---------------------------------------------------------------------- */
fix_wall_reflect.cpp:      error->all(FLERR,"Variable name for fix wall/reflect does not exist");
fix_wall_reflect.cpp:      error->all(FLERR,"Variable for fix wall/reflect is invalid style");
fix_wall_reflect.cpp:/* ---------------------------------------------------------------------- */
fix_wall_reflect.cpp:  // coord = current position of wall
fix_wall_reflect.cpp:  // evaluate variable if necessary, wrap with clear/add
fix_wall_reflect.cpp:    dim = wallwhich[m] / 2;
fix_wall_region.cpp:/* ----------------------------------------------------------------------
fix_wall_region.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
fix_wall_region.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
fix_wall_region.cpp:------------------------------------------------------------------------- */
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:  if (narg != 8) error->all(FLERR,"Illegal fix wall/region command");
fix_wall_region.cpp:  // parse args
fix_wall_region.cpp:    error->all(FLERR,"Region ID for fix wall/region does not exist");
fix_wall_region.cpp:  else error->all(FLERR,"Illegal fix wall/region command");
fix_wall_region.cpp:  if (cutoff <= 0.0) error->all(FLERR,"Fix wall/region cutoff <= 0.0");
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:  // set index and check validity of region
fix_wall_region.cpp:    error->all(FLERR,"Region ID for fix wall/region does not exist");
fix_wall_region.cpp:  // error checks for style COLLOID
fix_wall_region.cpp:  // insure all particles in group are extended particles
fix_wall_region.cpp:      error->all(FLERR,"Fix wall/region colloid requires atom style sphere");
fix_wall_region.cpp:      error->all(FLERR,"Fix wall/region colloid requires extended particles");
fix_wall_region.cpp:  // setup coefficients for each style
fix_wall_region.cpp:    coeff1 = 6.0/5.0 * epsilon * pow(sigma,9.0);
fix_wall_region.cpp:    coeff3 = 2.0/15.0 * epsilon * pow(sigma,9.0);
fix_wall_region.cpp:    double rinv = 1.0/cutoff;
fix_wall_region.cpp:    double r2inv = 1.0/(cutoff*cutoff);
fix_wall_region.cpp:    coeff1 = -4.0/315.0 * epsilon * pow(sigma,6.0);
fix_wall_region.cpp:    coeff2 = -2.0/3.0 * epsilon;
fix_wall_region.cpp:    coeff3 = epsilon * pow(sigma,6.0)/7560.0;
fix_wall_region.cpp:    coeff4 = epsilon/6.0;
fix_wall_region.cpp:    double rinv = 1.0/cutoff;
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:  // region->match() insures particle is in region or on surface, else error
fix_wall_region.cpp:  // if returned contact dist r = 0, is on surface, also an error
fix_wall_region.cpp:  // in COLLOID case, r <= radius is an error
fix_wall_region.cpp:  // initilize ewall after region->prematch(),
fix_wall_region.cpp:  //   so a dynamic region can access last timestep values
fix_wall_region.cpp:        } else rinv = 1.0/region->contact[m].r;
fix_wall_region.cpp:                         "used in fix wall/region");
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:/* ---------------------------------------------------------------------- */
fix_wall_region.cpp:/* ----------------------------------------------------------------------
fix_wall_region.cpp:------------------------------------------------------------------------- */
fix_wall_region.cpp:  // only sum across procs one time
fix_wall_region.cpp:/* ----------------------------------------------------------------------
fix_wall_region.cpp:------------------------------------------------------------------------- */
fix_wall_region.cpp:  // only sum across procs one time
fix_wall_region.cpp:/* ----------------------------------------------------------------------
fix_wall_region.cpp:   LJ 9/3 interaction for particle with wall
fix_wall_region.cpp:------------------------------------------------------------------------- */
fix_wall_region.cpp:  double rinv = 1.0/r;
fix_wall_region.cpp:/* ----------------------------------------------------------------------
fix_wall_region.cpp:   LJ 12/6 interaction for particle with wall
fix_wall_region.cpp:------------------------------------------------------------------------- */
fix_wall_region.cpp:  double rinv = 1.0/r;
fix_wall_region.cpp:/* ----------------------------------------------------------------------
fix_wall_region.cpp:------------------------------------------------------------------------- */
fix_wall_region.cpp:  double rinv = 1.0/delta2;
fix_wall_region.cpp:  double rinv2 = 1.0/r2;
fix_wall_region.cpp:  double rinv3 = 1.0/r3;
fix_wall_region.cpp:/* ----------------------------------------------------------------------
fix_wall_region.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
force.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ---------------------------------------------------------------------- */
force.cpp:  // fill pair map with pair styles listed in style_pair.h
force.cpp:/* ---------------------------------------------------------------------- */
force.cpp:/* ---------------------------------------------------------------------- */
force.cpp:  qqrd2e = qqr2e/dielectric;
force.cpp:  if (kspace) kspace->init();         // kspace must come before pair
force.cpp:  if (pair) pair->init();             // so g_ewald is defined
force.cpp:/* ---------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:   if trysuffix = 1, try first with suffix1/2 appended
force.cpp:   return sflag = 0 for no suffix added, 1 or 2 for suffix1/2 added
force.cpp:------------------------------------------------------------------------- */
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix);
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix2);
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:  else if (strstr(pair_style,"hybrid/overlay")) {
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix);
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix2);
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix);
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix);
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix);
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix2);
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix);
force.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix2);
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:      sprintf(estyle,"%s/%s",arg[0],lmp->suffix);
force.cpp:      sprintf(estyle,"%s/%s",arg[0],lmp->suffix2);
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:   if sflag = 1/2, append suffix or suffix2 to style
force.cpp:------------------------------------------------------------------------- */
force.cpp:    if (sflag == 1) sprintf(estyle,"%s/%s",style,lmp->suffix);
force.cpp:    else sprintf(estyle,"%s/%s",style,lmp->suffix2);
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:  // defaults, but do not reset special_extra
force.cpp:      special_coul[3] = 5.0/6.0;
force.cpp:    } else if (strcmp(arg[iarg],"lj/coul") == 0) {
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:  // attempt to open file directly
force.cpp:  // if successful, return ptr
force.cpp:  // try the environment variable directory
force.cpp:  newpath[len1] = '/';
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:  // skip over the disk drive part of windows pathnames
force.cpp:    if ((*path == '\\') || (*path == '/')) pot = path + 1;
force.cpp:    if (*path == '/') pot = path + 1;
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
force.cpp:/* ----------------------------------------------------------------------
force.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
group.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
group.cpp:------------------------------------------------------------------------- */
group.cpp:// allocate space for static class variable
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // create "all" group
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // delete the group if not being used elsewhere
group.cpp:  // clear mask of each atom assigned to this group
group.cpp:  // clear the group
group.cpp:  // find group in existing list
group.cpp:  // add a new group if igroup = -1
group.cpp:  // style = region
group.cpp:  // add to group if atom is in region
group.cpp:  // style = type, molecule, id
group.cpp:  // add to group if atom matches type/molecule/id or condition
group.cpp:    // args = logical condition
group.cpp:      // add to group if meets condition
group.cpp:    // args = list of values
group.cpp:        // add to group if attribute matches value or sequence
group.cpp:  // style = variable
group.cpp:  // add to group if atom-atyle variable is non-zero
group.cpp:    // aflag = evaluation of per-atom variable
group.cpp:    // add to group if per-atom variable evaluated to non-zero
group.cpp:  // style = include
group.cpp:  // style = subtract
group.cpp:    // add to group if in 1st group in list
group.cpp:    // remove atoms if they are in any of the other groups
group.cpp:    // AND with inverse mask removes the atom from group
group.cpp:  // style = union
group.cpp:    // add to group if in any other group in list
group.cpp:  // style = intersect
group.cpp:    // add to group if in all groups in list
group.cpp:  // style = dynamic
group.cpp:  // create a new FixGroup to dynamically determine atoms in group
group.cpp:    // if group is already dynamic, delete existing FixGroup
group.cpp:  // style = static
group.cpp:  // remove dynamic FixGroup if necessary
group.cpp:  // not a valid group style
group.cpp:  // print stats for changed group
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // find group in existing list
group.cpp:  // add a new group if igroup = -1
group.cpp:  // add atoms to group whose flags are set
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // hash = unique molecule IDs of atoms already in group
group.cpp:  // list = set of unique molecule IDs for atoms to add
group.cpp:  // pass list to all other procs via comm->ring()
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // use count to not change restart format with deleted groups
group.cpp:  // remove this on next major release
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // delete existing group names
group.cpp:  // atom masks will be overwritten by reading of restart file
group.cpp:  // use count to not change restart format with deleted groups
group.cpp:  // remove this on next major release
group.cpp:// ----------------------------------------------------------------------
group.cpp:// computations on a group of atoms
group.cpp:// ----------------------------------------------------------------------
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // compute extent across all procs
group.cpp:  // flip sign of MIN to do it in one Allreduce MAX
group.cpp:  // set box by extent in shrink-wrapped dims
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // compute extent across all procs
group.cpp:  // flip sign of MIN to do it in one Allreduce MAX
group.cpp:  // set box by extent in shrink-wrapped dims
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:    cm[0] /= masstotal;
group.cpp:    cm[1] /= masstotal;
group.cpp:    cm[2] /= masstotal;
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:    cm[0] /= masstotal;
group.cpp:    cm[1] /= masstotal;
group.cpp:    cm[2] /= masstotal;
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:    cm[0] /= masstotal;
group.cpp:    cm[1] /= masstotal;
group.cpp:    cm[2] /= masstotal;
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:    cm[0] /= masstotal;
group.cpp:    cm[1] /= masstotal;
group.cpp:    cm[2] /= masstotal;
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  if (masstotal > 0.0) return sqrt(rg_all/masstotal);
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  if (masstotal > 0.0) return sqrt(rg_all/masstotal);
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:/* ----------------------------------------------------------------------
group.cpp:------------------------------------------------------------------------- */
group.cpp:  // determinant = triple product of rows of inertia matrix
group.cpp:  // non-singular I matrix
group.cpp:  // use L = Iw, inverting I to solve for w
group.cpp:  // this should give exact zeroing of angular momentum by velocity command
group.cpp:        inverse[i][j] /= determinant;
group.cpp:  // handle (nearly) singular I matrix
group.cpp:  // typically due to 2-atom group or linear molecule
group.cpp:  // use jacobi() and angmom_to_omega() to calculate valid omega
group.cpp:  // less exact answer than matrix inversion, due to iterative Jacobi method
group.cpp:    // enforce 3 evectors as a right-handed coordinate system
group.cpp:    // flip 3rd vector if needed
group.cpp:    // if any principal moment < scaled EPSILON, set to 0.0
group.cpp:    // calculate omega using diagonalized inertia matrix
image.cpp:/* ----------------------------------------------------------------------
image.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
image.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ---------------------------------------------------------------------- */
image.cpp:  // defaults for 3d viz
image.cpp:  theta = 60.0 * MY_PI/180.0;
image.cpp:  phi = 30.0 * MY_PI/180.0;
image.cpp:  // colors
image.cpp:  // define nmap colormaps, all with default settings
image.cpp:  // static parameters
image.cpp:  FOV = MY_PI/6.0;              // 30 degrees
image.cpp:  keyLightPhi = -MY_PI4;        // -45 degrees
image.cpp:  keyLightTheta = MY_PI/6.0;    // 30 degrees
image.cpp:  fillLightPhi = MY_PI/6.0;     // 30 degrees
image.cpp:  backLightPhi = MY_PI;         // 180 degrees
image.cpp:  backLightTheta = MY_PI/12.0;  // 15 degrees
image.cpp:/* ---------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:  // camDir points at the camera, view direction = -camDir
image.cpp:  // normalize up vector
image.cpp:  // adjust camDir by epsilon if camDir and up are parallel
image.cpp:  // do this by tweaking view direction, not up direction
image.cpp:  // try to insure continuous images as changing view passes thru up
image.cpp:  // sufficient to handle common cases where theta = 0 or 180 is degenerate?
image.cpp:  // camUp = camDir x (Up x camDir)
image.cpp:  // zdist = camera distance = function of zoom & bounding box
image.cpp:  // camPos = camera position = function of camDir and zdist
image.cpp:  zdist /= tan(FOV);
image.cpp:  zdist /= zoom;
image.cpp:  // light directions in terms of -camDir = z
image.cpp:  // adjust shinyness of the reflection
image.cpp:  // adjust strength of the SSAO
image.cpp:    SSAOJitter = MY_PI / 12;
image.cpp:  // param for rasterizing spheres
image.cpp:  tanPerPixel = -(maxdel / (double) height);
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:  nhalf /= 2;
image.cpp:    nhalf /= 2;
image.cpp:  // extra SSAO enhancement
image.cpp:  // bcast full image to all procs
image.cpp:  // each works on subset of pixels
image.cpp:  // gather result back to proc 0
image.cpp:    int pixelPart = height/nprocs * width*3;
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:   draw XYZ axes in red/green/blue
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:    -tanPerPixel / zoom;
image.cpp:  double pixelRadiusFull = radius / pixelWidth;
image.cpp:  double xf = xmap / pixelWidth;
image.cpp:  double yf = ymap / pixelWidth;
image.cpp:  // shift 0,0 to screen center (vs lower left)
image.cpp:  xc += width / 2;
image.cpp:  yc += height / 2;
image.cpp:      // outside the sphere in the projected image
image.cpp:      surface[0] /= radius;
image.cpp:      surface[1] /= radius;
image.cpp:      surface[2] /= radius;
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:    -tanPerPixel / zoom;
image.cpp:  double pixelHalfWidthFull = halfWidth / pixelWidth;
image.cpp:  double xf = xmap / pixelWidth;
image.cpp:  double yf = ymap / pixelWidth;
image.cpp:  // shift 0,0 to screen center (vs lower left)
image.cpp:  xc += width / 2;
image.cpp:  yc += height / 2;
image.cpp:      // iterate through each of the 6 axis-oriented planes of the box
image.cpp:      // only render up to 3 which are facing the camera
image.cpp:      // these checks short circuit a dot product, testing for > 0
image.cpp:        if (camDir[dim] > 0) {          // positive faces camera
image.cpp:          t = (radius - surface[dim]) / camDir[dim];
image.cpp:        } else if (camDir[dim] < 0) {   // negative faces camera
image.cpp:          t = -(radius + surface[dim]) / camDir[dim];
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:  if (sflag/2) draw_sphere(y,surfaceColor,diameter);
image.cpp:  MathExtra::scale3(1.0/len,zaxis);
image.cpp:    -tanPerPixel / zoom;
image.cpp:  double xf = xmap / pixelWidth;
image.cpp:  double yf = ymap / pixelWidth;
image.cpp:  // shift 0,0 to screen center (vs lower left)
image.cpp:  xc += width / 2;
image.cpp:  yc += height / 2;
image.cpp:  double pixelHalfWidthFull = (rasterWidth * 0.5) / pixelWidth;
image.cpp:  double pixelHalfHeightFull = (rasterHeight * 0.5) / pixelWidth;
image.cpp:      double t = (-b + partial) / (2*a);
image.cpp:      double t2 = (-b - partial) / (2*a);
image.cpp:      // convert surface into the surface normal
image.cpp:      normal[0] = surface[0] / radius;
image.cpp:      normal[1] = surface[1] / radius;
image.cpp:      // in camera space
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:  MathExtra::scale3 (1.0 / d1len, d1);
image.cpp:  MathExtra::scale3 (1.0 / d2len, d2);
image.cpp:  invndotd = 1.0 / MathExtra::dot3(normal, camDir);
image.cpp:  // invalid triangle (parallel)
image.cpp:    -tanPerPixel / zoom;
image.cpp:  double xf = xmap / pixelWidth;
image.cpp:  double yf = ymap / pixelWidth;
image.cpp:  // shift 0,0 to screen center (vs lower left)
image.cpp:  xc += width / 2;
image.cpp:  yc += height / 2;
image.cpp:  double pixelLeftFull = rasterLeft / pixelWidth;
image.cpp:  double pixelRightFull = rasterRight / pixelWidth;
image.cpp:  double pixelDownFull = rasterDown / pixelWidth;
image.cpp:  double pixelUpFull = rasterUp / pixelWidth;
image.cpp:      // test inside the triangle
image.cpp:/* ---------------------------------------------------------------------- */
image.cpp:  // store only the tangent relative to the camera normal (0,0,-1)
image.cpp:/* ---------------------------------------------------------------------- */
image.cpp:  // used for rasterizing the spheres
image.cpp:  double delTheta = 2.0*MY_PI / SSAOSamples;
image.cpp:  // typical neighborhood value for shading
image.cpp:        -tanPerPixel / zoom;
image.cpp:  int pixelRadius = (int) trunc (SSAORadius / pixelWidth + 0.5);
image.cpp:  int hPart = height / nprocs;
image.cpp:        // multiply by z cross surface tangent
image.cpp:        // so that dot (aka cos) works here
image.cpp:        // Bresenham's line algorithm to march over depthBuffer
image.cpp:          delta = fabs(hy / hx);
image.cpp:          delta = fabs(hx / hy);
image.cpp:        // initialize with one step
image.cpp:        // because the center point doesn't need testing
image.cpp:          // cdepth - depthBuffer B/C we want it in the negative z direction
image.cpp:          double h = atan ((cdepth - minPeak) / peakLen);
image.cpp:      ao /= (double)SSAOSamples;
image.cpp:/* ---------------------------------------------------------------------- */
image.cpp:/* ---------------------------------------------------------------------- */
image.cpp:/* ---------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:   return static/dynamic status of color map index
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:   set min/max bounds of dynamic color map index
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:    {240/255.0, 248/255.0, 255/255.0},
image.cpp:    {250/255.0, 235/255.0, 215/255.0},
image.cpp:    {0/255.0, 255/255.0, 255/255.0},
image.cpp:    {127/255.0, 255/255.0, 212/255.0},
image.cpp:    {240/255.0, 255/255.0, 255/255.0},
image.cpp:    {245/255.0, 245/255.0, 220/255.0},
image.cpp:    {255/255.0, 228/255.0, 196/255.0},
image.cpp:    {0/255.0, 0/255.0, 0/255.0},
image.cpp:    {255/255.0, 255/255.0, 205/255.0},
image.cpp:    {0/255.0, 0/255.0, 255/255.0},
image.cpp:    {138/255.0, 43/255.0, 226/255.0},
image.cpp:    {165/255.0, 42/255.0, 42/255.0},
image.cpp:    {222/255.0, 184/255.0, 135/255.0},
image.cpp:    {95/255.0, 158/255.0, 160/255.0},
image.cpp:    {127/255.0, 255/255.0, 0/255.0},
image.cpp:    {210/255.0, 105/255.0, 30/255.0},
image.cpp:    {255/255.0, 127/255.0, 80/255.0},
image.cpp:    {100/255.0, 149/255.0, 237/255.0},
image.cpp:    {255/255.0, 248/255.0, 220/255.0},
image.cpp:    {220/255.0, 20/255.0, 60/255.0},
image.cpp:    {0/255.0, 255/255.0, 255/255.0},
image.cpp:    {0/255.0, 0/255.0, 139/255.0},
image.cpp:    {0/255.0, 139/255.0, 139/255.0},
image.cpp:    {184/255.0, 134/255.0, 11/255.0},
image.cpp:    {169/255.0, 169/255.0, 169/255.0},
image.cpp:    {0/255.0, 100/255.0, 0/255.0},
image.cpp:    {189/255.0, 183/255.0, 107/255.0},
image.cpp:    {139/255.0, 0/255.0, 139/255.0},
image.cpp:    {85/255.0, 107/255.0, 47/255.0},
image.cpp:    {255/255.0, 140/255.0, 0/255.0},
image.cpp:    {153/255.0, 50/255.0, 204/255.0},
image.cpp:    {139/255.0, 0/255.0, 0/255.0},
image.cpp:    {233/255.0, 150/255.0, 122/255.0},
image.cpp:    {143/255.0, 188/255.0, 143/255.0},
image.cpp:    {72/255.0, 61/255.0, 139/255.0},
image.cpp:    {47/255.0, 79/255.0, 79/255.0},
image.cpp:    {0/255.0, 206/255.0, 209/255.0},
image.cpp:    {148/255.0, 0/255.0, 211/255.0},
image.cpp:    {255/255.0, 20/255.0, 147/255.0},
image.cpp:    {0/255.0, 191/255.0, 255/255.0},
image.cpp:    {105/255.0, 105/255.0, 105/255.0},
image.cpp:    {30/255.0, 144/255.0, 255/255.0},
image.cpp:    {178/255.0, 34/255.0, 34/255.0},
image.cpp:    {255/255.0, 250/255.0, 240/255.0},
image.cpp:    {34/255.0, 139/255.0, 34/255.0},
image.cpp:    {255/255.0, 0/255.0, 255/255.0},
image.cpp:    {220/255.0, 220/255.0, 220/255.0},
image.cpp:    {248/255.0, 248/255.0, 255/255.0},
image.cpp:    {255/255.0, 215/255.0, 0/255.0},
image.cpp:    {218/255.0, 165/255.0, 32/255.0},
image.cpp:    {128/255.0, 128/255.0, 128/255.0},
image.cpp:    {0/255.0, 128/255.0, 0/255.0},
image.cpp:    {173/255.0, 255/255.0, 47/255.0},
image.cpp:    {240/255.0, 255/255.0, 240/255.0},
image.cpp:    {255/255.0, 105/255.0, 180/255.0},
image.cpp:    {205/255.0, 92/255.0, 92/255.0},
image.cpp:    {75/255.0, 0/255.0, 130/255.0},
image.cpp:    {255/255.0, 240/255.0, 240/255.0},
image.cpp:    {240/255.0, 230/255.0, 140/255.0},
image.cpp:    {230/255.0, 230/255.0, 250/255.0},
image.cpp:    {255/255.0, 240/255.0, 245/255.0},
image.cpp:    {124/255.0, 252/255.0, 0/255.0},
image.cpp:    {255/255.0, 250/255.0, 205/255.0},
image.cpp:    {173/255.0, 216/255.0, 230/255.0},
image.cpp:    {240/255.0, 128/255.0, 128/255.0},
image.cpp:    {224/255.0, 255/255.0, 255/255.0},
image.cpp:    {250/255.0, 250/255.0, 210/255.0},
image.cpp:    {144/255.0, 238/255.0, 144/255.0},
image.cpp:    {211/255.0, 211/255.0, 211/255.0},
image.cpp:    {255/255.0, 182/255.0, 193/255.0},
image.cpp:    {255/255.0, 160/255.0, 122/255.0},
image.cpp:    {32/255.0, 178/255.0, 170/255.0},
image.cpp:    {135/255.0, 206/255.0, 250/255.0},
image.cpp:    {119/255.0, 136/255.0, 153/255.0},
image.cpp:    {176/255.0, 196/255.0, 222/255.0},
image.cpp:    {255/255.0, 255/255.0, 224/255.0},
image.cpp:    {0/255.0, 255/255.0, 0/255.0},
image.cpp:    {50/255.0, 205/255.0, 50/255.0},
image.cpp:    {250/255.0, 240/255.0, 230/255.0},
image.cpp:    {255/255.0, 0/255.0, 255/255.0},
image.cpp:    {128/255.0, 0/255.0, 0/255.0},
image.cpp:    {102/255.0, 205/255.0, 170/255.0},
image.cpp:    {0/255.0, 0/255.0, 205/255.0},
image.cpp:    {186/255.0, 85/255.0, 211/255.0},
image.cpp:    {147/255.0, 112/255.0, 219/255.0},
image.cpp:    {60/255.0, 179/255.0, 113/255.0},
image.cpp:    {123/255.0, 104/255.0, 238/255.0},
image.cpp:    {0/255.0, 250/255.0, 154/255.0},
image.cpp:    {72/255.0, 209/255.0, 204/255.0},
image.cpp:    {199/255.0, 21/255.0, 133/255.0},
image.cpp:    {25/255.0, 25/255.0, 112/255.0},
image.cpp:    {245/255.0, 255/255.0, 250/255.0},
image.cpp:    {255/255.0, 228/255.0, 225/255.0},
image.cpp:    {255/255.0, 228/255.0, 181/255.0},
image.cpp:    {255/255.0, 222/255.0, 173/255.0},
image.cpp:    {0/255.0, 0/255.0, 128/255.0},
image.cpp:    {253/255.0, 245/255.0, 230/255.0},
image.cpp:    {128/255.0, 128/255.0, 0/255.0},
image.cpp:    {107/255.0, 142/255.0, 35/255.0},
image.cpp:    {255/255.0, 165/255.0, 0/255.0},
image.cpp:    {255/255.0, 69/255.0, 0/255.0},
image.cpp:    {218/255.0, 112/255.0, 214/255.0},
image.cpp:    {238/255.0, 232/255.0, 170/255.0},
image.cpp:    {152/255.0, 251/255.0, 152/255.0},
image.cpp:    {175/255.0, 238/255.0, 238/255.0},
image.cpp:    {219/255.0, 112/255.0, 147/255.0},
image.cpp:    {255/255.0, 239/255.0, 213/255.0},
image.cpp:    {255/255.0, 239/255.0, 213/255.0},
image.cpp:    {205/255.0, 133/255.0, 63/255.0},
image.cpp:    {255/255.0, 192/255.0, 203/255.0},
image.cpp:    {221/255.0, 160/255.0, 221/255.0},
image.cpp:    {176/255.0, 224/255.0, 230/255.0},
image.cpp:    {128/255.0, 0/255.0, 128/255.0},
image.cpp:    {255/255.0, 0/255.0, 0/255.0},
image.cpp:    {188/255.0, 143/255.0, 143/255.0},
image.cpp:    {65/255.0, 105/255.0, 225/255.0},
image.cpp:    {139/255.0, 69/255.0, 19/255.0},
image.cpp:    {250/255.0, 128/255.0, 114/255.0},
image.cpp:    {244/255.0, 164/255.0, 96/255.0},
image.cpp:    {46/255.0, 139/255.0, 87/255.0},
image.cpp:    {255/255.0, 245/255.0, 238/255.0},
image.cpp:    {160/255.0, 82/255.0, 45/255.0},
image.cpp:    {192/255.0, 192/255.0, 192/255.0},
image.cpp:    {135/255.0, 206/255.0, 235/255.0},
image.cpp:    {106/255.0, 90/255.0, 205/255.0},
image.cpp:    {112/255.0, 128/255.0, 144/255.0},
image.cpp:    {255/255.0, 250/255.0, 250/255.0},
image.cpp:    {0/255.0, 255/255.0, 127/255.0},
image.cpp:    {70/255.0, 130/255.0, 180/255.0},
image.cpp:    {210/255.0, 180/255.0, 140/255.0},
image.cpp:    {0/255.0, 128/255.0, 128/255.0},
image.cpp:    {216/255.0, 191/255.0, 216/255.0},
image.cpp:    {253/255.0, 99/255.0, 71/255.0},
image.cpp:    {64/255.0, 224/255.0, 208/255.0},
image.cpp:    {238/255.0, 130/255.0, 238/255.0},
image.cpp:    {245/255.0, 222/255.0, 179/255.0},
image.cpp:    {255/255.0, 255/255.0, 255/255.0},
image.cpp:    {245/255.0, 245/255.0, 245/255.0},
image.cpp:    {255/255.0, 255/255.0, 0/255.0},
image.cpp:    {154/255.0, 205/255.0, 50/255.0}
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:// ----------------------------------------------------------------------
image.cpp:// ----------------------------------------------------------------------
image.cpp:// ColorMap class
image.cpp:// ----------------------------------------------------------------------
image.cpp:// ----------------------------------------------------------------------
image.cpp:  // default color map
image.cpp:/* ---------------------------------------------------------------------- */
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:    mbinsizeinv = 1.0/mbinsize;
image.cpp:      // NOTE: this is unfinished code, not sure how useful it is
image.cpp:      // idea is to allow a list of colors to be specified with a single arg
image.cpp:      // problem is that sequential colors in ALL are not very different
image.cpp:      // e.g. ALL or USER or ALL5:10 or USER1:10:2
image.cpp:      // current code is just 1st nentry values of ALL or USER
image.cpp:      // need to comment out error check in DumpImage::modify_param()
image.cpp:      //   for amap check on (narg < n) to get it to work
image.cpp:      // need to add extra logic here to check not accessing undefined colors
image.cpp:  // one-time call to minmax if color map is static
image.cpp:/* ----------------------------------------------------------------------
image.cpp:   set explicit values for all min/max settings in color map
image.cpp:     from min/max dynamic values
image.cpp:   set lo/hi current and lvalue/hvalue entries that are MIN/MAX VALUE
image.cpp:   called only once if mlo/mhi != MIN/MAX VALUE, else called repeatedly
image.cpp:------------------------------------------------------------------------- */
image.cpp:    // error in ABSOLUTE mode if new lo/hi current cause
image.cpp:    // first/last entry to become lo > hi with adjacent entry
image.cpp:  // OK if new lo/hi current cause an entry to have lo > hi,
image.cpp:  // since last entry will always be a match
image.cpp:/* ----------------------------------------------------------------------
image.cpp:------------------------------------------------------------------------- */
image.cpp:  double lo;//,hi;
image.cpp:    else value = (value-locurrent) / (hicurrent-locurrent);
image.cpp:    //hi = 1.0;
image.cpp:    //hi = hicurrent;
image.cpp:        double fraction = (value-mentry[i].svalue) /
imbalance.cpp:/* -*- c++ -*- ----------------------------------------------------------
imbalance.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
imbalance.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
imbalance.cpp:------------------------------------------------------------------------- */
imbalance.cpp:/* ---------------------------------------------------------------------- */
imbalance_group.cpp:/* ----------------------------------------------------------------------
imbalance_group.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
imbalance_group.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
imbalance_group.cpp:------------------------------------------------------------------------- */
imbalance_group.cpp:/* -------------------------------------------------------------------- */
imbalance_group.cpp:/* -------------------------------------------------------------------- */
imbalance_group.cpp:/* -------------------------------------------------------------------- */
imbalance_group.cpp:/* -------------------------------------------------------------------- */
imbalance_group.cpp:/* -------------------------------------------------------------------- */
imbalance_neigh.cpp:/* ----------------------------------------------------------------------
imbalance_neigh.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
imbalance_neigh.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
imbalance_neigh.cpp:------------------------------------------------------------------------- */
imbalance_neigh.cpp:/* -------------------------------------------------------------------- */
imbalance_neigh.cpp:/* -------------------------------------------------------------------- */
imbalance_neigh.cpp:/* -------------------------------------------------------------------- */
imbalance_neigh.cpp:  // find suitable neighbor list
imbalance_neigh.cpp:  // can only use certain conventional neighbor lists
imbalance_neigh.cpp:  // NOTE: why not full list, if half does not exist?
imbalance_neigh.cpp:      error->warning(FLERR,"Balance weight neigh skipped b/c no list found");
imbalance_neigh.cpp:  // neighsum = total neigh count for atoms on this proc
imbalance_neigh.cpp:  // localwt = weight assigned to each owned atom
imbalance_neigh.cpp:  if (nlocal) localwt = 1.0*neighsum/nlocal;
imbalance_neigh.cpp:  // apply factor if specified != 1.0
imbalance_neigh.cpp:  // wtlo,wthi = lo/hi values excluding 0.0 due to no atoms on this proc
imbalance_neigh.cpp:  // lo value does not change
imbalance_neigh.cpp:  // newhi = new hi value to give hi/lo ratio factor times larger/smaller
imbalance_neigh.cpp:  // expand/contract all localwt values from lo->hi to lo->newhi
imbalance_neigh.cpp:    localwt = wtlo + ((localwt-wtlo)/(wthi-wtlo)) * (newhi-wtlo);
imbalance_neigh.cpp:/* -------------------------------------------------------------------- */
imbalance_store.cpp:/* ----------------------------------------------------------------------
imbalance_store.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
imbalance_store.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
imbalance_store.cpp:------------------------------------------------------------------------- */
imbalance_store.cpp:/* -------------------------------------------------------------------- */
imbalance_store.cpp:/* -------------------------------------------------------------------- */
imbalance_store.cpp:/* -------------------------------------------------------------------- */
imbalance_store.cpp:/* -------------------------------------------------------------------- */
imbalance_store.cpp:  // property does not exist
imbalance_store.cpp:/* -------------------------------------------------------------------- */
imbalance_time.cpp:/* ----------------------------------------------------------------------
imbalance_time.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
imbalance_time.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
imbalance_time.cpp:------------------------------------------------------------------------- */
imbalance_time.cpp:/* -------------------------------------------------------------------- */
imbalance_time.cpp:/* -------------------------------------------------------------------- */
imbalance_time.cpp:/* ----------------------------------------------------------------------
imbalance_time.cpp:------------------------------------------------------------------------- */
imbalance_time.cpp:  // flag = 1 if called from FixBalance at start of run
imbalance_time.cpp:  //   init Timer, so accumulated time not carried over from previous run
imbalance_time.cpp:  // should NOT init Timer if called from Balance, it uses time from last run
imbalance_time.cpp:/* -------------------------------------------------------------------- */
imbalance_time.cpp:  // cost = CPU time for relevant timers since last invocation
imbalance_time.cpp:  // localwt = weight assigned to each owned atom
imbalance_time.cpp:  // just return if no time yet tallied
imbalance_time.cpp:  if (nlocal) localwt = cost/nlocal;
imbalance_time.cpp:  // apply factor if specified != 1.0
imbalance_time.cpp:  // wtlo,wthi = lo/hi values excluding 0.0 due to no atoms on this proc
imbalance_time.cpp:  // lo value does not change
imbalance_time.cpp:  // newhi = new hi value to give hi/lo ratio factor times larger/smaller
imbalance_time.cpp:  // expand/contract all localwt values from lo->hi to lo->newhi
imbalance_time.cpp:    localwt = wtlo + ((localwt-wtlo)/(wthi-wtlo)) * (newhi-wtlo);
imbalance_time.cpp:  // record time up to this point
imbalance_time.cpp:/* -------------------------------------------------------------------- */
imbalance_var.cpp:/* ----------------------------------------------------------------------
imbalance_var.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
imbalance_var.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
imbalance_var.cpp:------------------------------------------------------------------------- */
imbalance_var.cpp:// DEBUG
imbalance_var.cpp:/* -------------------------------------------------------------------- */
imbalance_var.cpp:/* -------------------------------------------------------------------- */
imbalance_var.cpp:/* -------------------------------------------------------------------- */
imbalance_var.cpp:/* -------------------------------------------------------------------- */
imbalance_var.cpp:/* -------------------------------------------------------------------- */
imbalance_var.cpp:/* -------------------------------------------------------------------- */
improper.cpp:/* ----------------------------------------------------------------------
improper.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
improper.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
improper.cpp:------------------------------------------------------------------------- */
improper.cpp:/* ---------------------------------------------------------------------- */
improper.cpp:/* ---------------------------------------------------------------------- */
improper.cpp:/* ----------------------------------------------------------------------
improper.cpp:------------------------------------------------------------------------- */
improper.cpp:/* ----------------------------------------------------------------------
improper.cpp:------------------------------------------------------------------------- */
improper.cpp:  eflag_atom = eflag / 2;
improper.cpp:  vflag_atom = vflag / 4;
improper.cpp:  // reallocate per-atom arrays if necessary
improper.cpp:  // zero accumulators
improper.cpp:/* ----------------------------------------------------------------------
improper.cpp:------------------------------------------------------------------------- */
improper.cpp:/* ---------------------------------------------------------------------- */
improper_hybrid.cpp:/* ----------------------------------------------------------------------
improper_hybrid.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
improper_hybrid.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
improper_hybrid.cpp:------------------------------------------------------------------------- */
improper_hybrid.cpp:/* ---------------------------------------------------------------------- */
improper_hybrid.cpp:/* ---------------------------------------------------------------------- */
improper_hybrid.cpp:/* ---------------------------------------------------------------------- */
improper_hybrid.cpp:  // save ptrs to original improperlist
improper_hybrid.cpp:  // if this is re-neighbor step, create sub-style improperlists
improper_hybrid.cpp:  // nimproperlist[] = length of each sub-style list
improper_hybrid.cpp:  // realloc sub-style improperlist if necessary
improper_hybrid.cpp:  // load sub-style improperlist with 5 values from original improperlist
improper_hybrid.cpp:  // call each sub-style's compute function
improper_hybrid.cpp:  // set neighbor->improperlist to sub-style improperlist before call
improper_hybrid.cpp:  // accumulate sub-style global/peratom energy/virial in hybrid
improper_hybrid.cpp:  // restore ptrs to original improperlist
improper_hybrid.cpp:/* ---------------------------------------------------------------------- */
improper_hybrid.cpp:/* ---------------------------------------------------------------------- */
improper_hybrid.cpp:/* ----------------------------------------------------------------------
improper_hybrid.cpp:------------------------------------------------------------------------- */
improper_hybrid.cpp:  // delete old lists, since cannot just change settings
improper_hybrid.cpp:  // count sub-styles by skipping numeric args
improper_hybrid.cpp:  // one exception is 1st arg of style "table", which is non-numeric word
improper_hybrid.cpp:  // need a better way to skip these exceptions
improper_hybrid.cpp:  // allocate list of sub-styles
improper_hybrid.cpp:  // allocate each sub-style and call its settings() with subset of args
improper_hybrid.cpp:  // allocate uses suffix, but don't store suffix version in keywords,
improper_hybrid.cpp:  //   else syntax in coeff() will not match
improper_hybrid.cpp:  // define subset of args for a sub-style by skipping numeric args
improper_hybrid.cpp:  // one exception is 1st arg of style "table", which is non-numeric
improper_hybrid.cpp:  // need a better way to skip these exceptions
improper_hybrid.cpp:/* ----------------------------------------------------------------------
improper_hybrid.cpp:---------------------------------------------------------------------- */
improper_hybrid.cpp:  // 2nd arg = improper sub-style name
improper_hybrid.cpp:  // allow for "none" as valid sub-style name
improper_hybrid.cpp:  // move 1st arg to 2nd arg
improper_hybrid.cpp:  // just copy ptrs, since arg[] points into original input line
improper_hybrid.cpp:  // invoke sub-style coeff() starting with 1st arg
improper_hybrid.cpp:  // set setflag and which type maps to which sub-style
improper_hybrid.cpp:  // if sub-style is none: set hybrid setflag, wipe out map
improper_hybrid.cpp:/* ----------------------------------------------------------------------
improper_hybrid.cpp:------------------------------------------------------------------------- */
improper_hybrid.cpp:/* ----------------------------------------------------------------------
improper_hybrid.cpp:------------------------------------------------------------------------- */
improper_hybrid.cpp:/* ----------------------------------------------------------------------
improper_hybrid.cpp:------------------------------------------------------------------------- */
improper_zero.cpp:/* ----------------------------------------------------------------------
improper_zero.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
improper_zero.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
improper_zero.cpp:------------------------------------------------------------------------- */
improper_zero.cpp:/* ----------------------------------------------------------------------
improper_zero.cpp:------------------------------------------------------------------------- */
improper_zero.cpp:/* ---------------------------------------------------------------------- */
improper_zero.cpp:/* ---------------------------------------------------------------------- */
improper_zero.cpp:/* ---------------------------------------------------------------------- */
improper_zero.cpp:/* ---------------------------------------------------------------------- */
improper_zero.cpp:/* ---------------------------------------------------------------------- */
improper_zero.cpp:/* ----------------------------------------------------------------------
improper_zero.cpp:------------------------------------------------------------------------- */
improper_zero.cpp:/* ----------------------------------------------------------------------
improper_zero.cpp:------------------------------------------------------------------------- */
improper_zero.cpp:/* ----------------------------------------------------------------------
improper_zero.cpp:------------------------------------------------------------------------- */
improper_zero.cpp:/* ----------------------------------------------------------------------
improper_zero.cpp:------------------------------------------------------------------------- */
info.cpp:/* ----------------------------------------------------------------------
info.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
info.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
info.cpp:------------------------------------------------------------------------- */
info.cpp:/* ----------------------------------------------------------------------
info.cpp:------------------------------------------------------------------------- */
info.cpp:#include <sys/time.h>
info.cpp:#include <sys/resource.h>
info.cpp:#include <sys/utsname.h>
info.cpp:// same as in variable.cpp
info.cpp:/* ---------------------------------------------------------------------- */
info.cpp:  // parse arguments
info.cpp:    fprintf(out,"\nLAMMPS version: %s / %s\n",
info.cpp:    double mbytes = bytes/1024.0/1024.0;
info.cpp:            (double)pmc.PrivateUsage/1048576.0);
info.cpp:            (double)pmc.PeakWorkingSetSize/1048576.0);
info.cpp:            (double)mi.uordblks/1048576.0+(double)mi.hblkhd/1048576.0);
info.cpp:              (double)ru.ru_maxrss/1024.0);
info.cpp:    // from MSD docs.
info.cpp:#else /* POSIX */
info.cpp:#endif /* ! _WIN32 */
info.cpp:    cpuclock = (cpuclock - cpus) / 60.0;
info.cpp:    cpuh = (cpuclock - cpum) / 60.0;
info.cpp:    wallclock = (wallclock - walls) / 60.0;
info.cpp:    wallh = (wallclock - wallm) / 60.0;
info.cpp:  // close output file pointer if opened locally thus forcing a hard sync.
info.cpp:/* ---------------------------------------------------------------------- */
info.cpp:// the is_active() function returns true if the selected style or name
info.cpp:// in the selected category is currently in use.
info.cpp:      sprintf(name_w_suffix,"%s/%s",name,lmp->suffix);
info.cpp:      sprintf(name_w_suffix,"%s/%s",name,lmp->suffix2);
info.cpp:/* ---------------------------------------------------------------------- */
info.cpp:// the is_available() function returns true if the selected style
info.cpp:// or name in the selected category is available for use (but need
info.cpp:// not be currently active).
info.cpp:        sprintf(name_w_suffix,"%s/%s",name,lmp->suffix);
info.cpp:        sprintf(name_w_suffix,"%s/%s",name,lmp->suffix2);
info.cpp:        sprintf(name_w_suffix,"%s/%s",name,lmp->suffix);
info.cpp:        sprintf(name_w_suffix,"%s/%s",name,lmp->suffix2);
info.cpp:        sprintf(name_w_suffix,"%s/%s",name,lmp->suffix);
info.cpp:        sprintf(name_w_suffix,"%s/%s",name,lmp->suffix2);
info.cpp:/* ---------------------------------------------------------------------- */
info.cpp:// the is_defined() function returns true if a particular ID of the
info.cpp:// selected category (e.g. fix ID, group ID, region ID etc.) has been
info.cpp:// defined and thus can be accessed. It does *NOT* check whether a
info.cpp:// particular ID has a particular style.
info.cpp:    // skip "secret" styles
info.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ----------------------------------------------------------------------
input.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
input.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
input.cpp:------------------------------------------------------------------------- */
input.cpp:#include "sys/stat.h"
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // fill map with commands listed in style_command.h
input.cpp:  // process command-line args
input.cpp:  // check for args "-var" and "-echo"
input.cpp:  // caller has already checked that sufficient arguments exist
input.cpp:      char **tmp = arg;        // trick echo() into using argv instead of arg
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // don't free command and arg strings
input.cpp:  // they just point to other allocated memory
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:    // read a line from input script
input.cpp:    // n = length of line including str terminator, 0 if end of file
input.cpp:    // if line ends in continuation char '&', concatenate next line
input.cpp:	// end of file reached, so break
input.cpp:	// n == 0 if nothing read, else n = line with str terminator
input.cpp:	// continue if last char read was not a newline
input.cpp:	// could happen if line is very long
input.cpp:	// continue reading if final printable char is & char
input.cpp:	// or if odd number of triple quotes
input.cpp:	// else break with n = line with str terminator
input.cpp:    // bcast the line
input.cpp:    // if n = 0, end-of-file
input.cpp:    // error if label_active is set, since label wasn't encountered
input.cpp:    // if original input file, code is done
input.cpp:    // else go back to previous input file
input.cpp:    // echo the command unless scanning for label
input.cpp:    // parse the line
input.cpp:    // if no command, skip to next line in input script
input.cpp:    // if scanning for label, skip command unless it's a label command
input.cpp:    // execute the command
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:  // error if another nested file still open, should not be possible
input.cpp:  // open new filename and set infile, infiles[0], nfile
input.cpp:  // call to file() will close filename and decrement nfile
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:  // echo the command unless scanning for label
input.cpp:  // parse the line
input.cpp:  // if no command, just return NULL
input.cpp:  // if scanning for label, skip command unless it's a label command
input.cpp:  // execute the command and return its name
input.cpp:/* ----------------------------------------------------------------------
input.cpp:   treat text between single/double/triple quotes as one arg via nextword()
input.cpp:------------------------------------------------------------------------- */
input.cpp:  // duplicate line into copy string to break into words
input.cpp:  // strip any # comment by replacing it with 0
input.cpp:  // do not strip from a # inside single/double/triple quotes
input.cpp:  // quoteflag = 1,2,3 when encounter first single/double,triple quote
input.cpp:  // quoteflag = 0 when encounter matching single/double,triple quote
input.cpp:  // perform $ variable substitution (print changes)
input.cpp:  // except if searching for a label since earlier variable may not be defined
input.cpp:  // command = 1st arg in copy string
input.cpp:  // point arg[] at each subsequent arg in copy string
input.cpp:  // nextword() inserts string terminators into copy string to delimit args
input.cpp:  // nextword() treats text between single/double/triple quotes as one arg
input.cpp:/* ----------------------------------------------------------------------
input.cpp:   treat text between single/double/triple quotes as one arg
input.cpp:------------------------------------------------------------------------- */
input.cpp:  // start = first non-whitespace char
input.cpp:  // if start is single/double/triple quote:
input.cpp:  //   start = first char beyond quote
input.cpp:  //   stop = first char of matching quote
input.cpp:  //   next = first char beyond matching quote
input.cpp:  //   next must be NULL or whitespace
input.cpp:  // if start is not single/double/triple quote:
input.cpp:  //   stop = first whitespace char after start
input.cpp:  //   next = char after stop, or stop itself if stop is NULL
input.cpp:  // set stop to NULL to terminate word
input.cpp:/* ----------------------------------------------------------------------
input.cpp:   reallocate str/str2 to hold expanded version if necessary & reset max/max2
input.cpp:------------------------------------------------------------------------- */
input.cpp:  // use str2 as scratch space to expand str, then copy back to str
input.cpp:  // reallocate str and str2 as necessary
input.cpp:  // do not replace $ inside single/double/triple quotes
input.cpp:  // var = pts at variable name, ended by NULL
input.cpp:  //   if $ is followed by '{', trailing '}' becomes NULL
input.cpp:  //   else $x becomes x followed by NULL
input.cpp:  // beyond = points to text following variable
input.cpp:    // variable substitution
input.cpp:      // value = ptr to expanded variable
input.cpp:      // variable name between curly braces, e.g. ${a}
input.cpp:      // immediate variable between parenthesis, e.g. $(1/2)
input.cpp:        // single character variable name, e.g. $a
input.cpp:      // check if storage in str2 needs to be expanded
input.cpp:      // re-initialize ptr and ptr2 to the point beyond the variable.
input.cpp:      // output substitution progress if requested
input.cpp:    // quoteflag = 1,2,3 when encounter first single/double,triple quote
input.cpp:    // quoteflag = 0 when encounter matching single/double,triple quote
input.cpp:    // copy 2 extra triple quote chars into str2
input.cpp:    // copy current character into str2
input.cpp:  // set length of input str to length of work str2
input.cpp:  // copy work string back to input str
input.cpp:/* ----------------------------------------------------------------------
input.cpp:   return new expanded # of values, and copy them w/out "*" into earg
input.cpp:------------------------------------------------------------------------- */
input.cpp:  // maxarg should always end up equal to newarg, so caller can free earg
input.cpp:              // check for global vector/array, peratom array, local array
input.cpp:              // check for global vector/array, peratom array, local array
input.cpp:	n = strlen(arg[iarg]) + 16;   // 16 = space for large inserted integer
input.cpp:  //printf("NEWARG %d\n",newarg);
input.cpp:  //for (int i = 0; i < newarg; i++)
input.cpp:  //  printf("  arg %d: %s\n",i,earg[i]);
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:  // return if command was listed above
input.cpp:  // invoke commands added via style_command.h
input.cpp:  // unrecognized command
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // substitute for variables in Boolean expression for "if"
input.cpp:  // in case expression was enclosed in quotes
input.cpp:  // must substitute on copy of arg else will step on subsequent args
input.cpp:  // evaluate Boolean expression for "if"
input.cpp:  // bound "then" commands
input.cpp:  // execute "then" commands
input.cpp:  // make copies of all arg string commands
input.cpp:  // required because re-parsing a command via one() will wipe out args
input.cpp:  // done if no "elif" or "else"
input.cpp:  // check "elif" or "else" until find commands to execute
input.cpp:  // substitute for variables and evaluate Boolean expression for "elif"
input.cpp:  // must substitute on copy of arg else will step on subsequent args
input.cpp:  // bound and execute "elif" or "else" commands
input.cpp:    // execute the list of commands
input.cpp:    // clean up
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // do not allow include inside an if command
input.cpp:  // NOTE: this check will fail if a 2nd if command was inside the if command
input.cpp:  //       and came before the include
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // copy original line to copy, since will use strtok() on it
input.cpp:  // ptr = start of 4th word
input.cpp:  // execute the remaining command line on requested partitions
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // copy 1st arg back into line (copy is being used)
input.cpp:  // check maxline since arg[0] could have been exanded by variables
input.cpp:  // substitute for $ variables (no printing) and print arg
input.cpp:  // parse optional args
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  if (narg == 0) error->done(0); // 1 would be fully backwards compatible
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // use work string to concat args back into one string separated by spaces
input.cpp:  // invoke string in shell via system()
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // must reset default extra_dof of all computes
input.cpp:  // since some were created before dimension command is encountered
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // same checks for packages existing as in LAMMPS::post_create()
input.cpp:  // since can be invoked here by package command in input script
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ----------------------------------------------------------------------
input.cpp:------------------------------------------------------------------------- */
input.cpp:        sprintf(estyle,"%s/%s",arg[0],lmp->suffix);
input.cpp:        sprintf(estyle,"%s/%s",arg[0],lmp->suffix2);
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:  // store 1-3,1-4 and dihedral/extra flag values before change
input.cpp:  // change in 1-2 coeffs will not change the special list
input.cpp:  // if simulation box defined and saved values changed, redo special list
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
input.cpp:/* ---------------------------------------------------------------------- */
integrate.cpp:/* ----------------------------------------------------------------------
integrate.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
integrate.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
integrate.cpp:------------------------------------------------------------------------- */
integrate.cpp:/* ---------------------------------------------------------------------- */
integrate.cpp:/* ---------------------------------------------------------------------- */
integrate.cpp:/* ---------------------------------------------------------------------- */
integrate.cpp:  // allow pair and Kspace compute() to be turned off via modify flags
integrate.cpp:  // should add checks:
integrate.cpp:  // for any acceleration package that has its own integrate/minimize
integrate.cpp:  // in case input script has reset the run or minimize style explicitly
integrate.cpp:  // e.g. invalid to have kokkos pair style with non-kokkos verlet
integrate.cpp:  // but OK to have kokkos verlet with non kokkos pair style (just warn)
integrate.cpp:  // making these checks would require all the pair, fix, etc styles have
integrate.cpp:  //   kokkos, intel flags
integrate.cpp:/* ----------------------------------------------------------------------
integrate.cpp:------------------------------------------------------------------------- */
integrate.cpp:/* ----------------------------------------------------------------------
integrate.cpp:   eflag/vflag based on computes that need info on this ntimestep
integrate.cpp:------------------------------------------------------------------------- */
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
irregular.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:// allocate space for static class variable
irregular.cpp:// prototype for non-class function
irregular.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
irregular.cpp:/* ---------------------------------------------------------------------- */
irregular.cpp:  // migrate work vectors
irregular.cpp:  // send buffers
irregular.cpp:  // universal work vectors
irregular.cpp:  // initialize buffers for migrate atoms, not used for datum comm
irregular.cpp:  // these can persist for multiple irregular operations
irregular.cpp:/* ---------------------------------------------------------------------- */
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:  // clear global->local map since atoms move to new procs
irregular.cpp:  // clear old ghosts so map_set() at end will operate only on local atoms
irregular.cpp:  // exchange() doesn't need to clear ghosts b/c borders()
irregular.cpp:  //   is called right after and it clears ghosts and calls map_set()
irregular.cpp:  // subbox bounds for orthogonal or triclinic box
irregular.cpp:  // if Comm will be called to assign new atom coords to procs,
irregular.cpp:  // may need to setup RCB info
irregular.cpp:  // loop over atoms, flag any that are not in my sub-box
irregular.cpp:  // fill buffer with atoms leaving my box, using < and >=
irregular.cpp:  // assign which proc it belongs to via Comm::coord2proc()
irregular.cpp:  // if coord2proc() returns me, due to round-off
irregular.cpp:  //   in triclinic x2lamda(), then keep atom and don't send
irregular.cpp:  // when atom is deleted, fill it in with last atom
irregular.cpp:  // create irregular communication plan, perform comm, destroy plan
irregular.cpp:  // returned nrecv = size of buffer needed for incoming atoms
irregular.cpp:  // add received atoms to my list
irregular.cpp:  // reset global->local map
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:  // migrate required if comm layout is tiled
irregular.cpp:  // cannot use myloc[] logic below
irregular.cpp:  // subbox bounds for orthogonal or triclinic box
irregular.cpp:  // loop over atoms, check for any that are not in my sub-box
irregular.cpp:  // assign which proc it belongs to via Comm::coord2proc()
irregular.cpp:  // if logical igx,igy,igz of newproc > one away from myloc, set flag = 1
irregular.cpp:  // this check needs to observe PBC
irregular.cpp:  // cannot check via comm->procneigh since it ignores PBC
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:  // setup for collective comm
irregular.cpp:  // work1 = 1 for procs I send a message to, not including self
irregular.cpp:  // work2 = 1 for all procs, used for ReduceScatter
irregular.cpp:  // nrecv_proc = # of procs I receive messages from, not including self
irregular.cpp:  // options for performing ReduceScatter operation
irregular.cpp:  // some are more efficient on some machines at big sizes
irregular.cpp:  // allocate receive arrays
irregular.cpp:  // nsend_proc = # of messages I send
irregular.cpp:  // allocate send arrays
irregular.cpp:  // list still stores size of message for procs I send to
irregular.cpp:  // proc_send = procs I send to
irregular.cpp:  // length_send = # of doubles I send to each proc
irregular.cpp:  // to balance pattern of send messages:
irregular.cpp:  //   each proc begins with iproc > me, continues until iproc = me
irregular.cpp:  // reset list to store which send message each proc corresponds to
irregular.cpp:  // num_send = # of atoms I send to each proc
irregular.cpp:  // work2 = offsets into index_send for each proc I send to
irregular.cpp:  // index_send = list of which atoms to send to each proc
irregular.cpp:  //   1st N1 values are atom indices for 1st proc,
irregular.cpp:  //   next N2 values are atom indices for 2nd proc, etc
irregular.cpp:  // offset_send = where each atom starts in send buffer
irregular.cpp:  // tell receivers how much data I send
irregular.cpp:  // sendmax_proc = # of doubles I send in largest single message
irregular.cpp:    MPI_Request tmpReq; // Use non-blocking send to avoid possible deadlock
irregular.cpp:    MPI_Request_free(&tmpReq); // the MPI_Barrier below marks completion
irregular.cpp:  // receive incoming messages
irregular.cpp:  // proc_recv = procs I recv from
irregular.cpp:  // length_recv = # of doubles each proc sends me
irregular.cpp:  // nrecvsize = total size of atom data I recv
irregular.cpp:  // sort proc_recv and length_recv by proc ID if requested
irregular.cpp:  // useful for debugging to insure reproducible ordering of received atoms
irregular.cpp:  // invoke by adding final arg = 1 to create_atom() call in migrate_atoms()
irregular.cpp:  // barrier to insure all MPI_ANY_SOURCE messages are received
irregular.cpp:  // else another proc could proceed to exchange_atom() and send to me
irregular.cpp:  // return size of atom data I will receive
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:  // post all receives
irregular.cpp:  // reallocate buf for largest send if necessary
irregular.cpp:  // send each message
irregular.cpp:  // pack buf with list of atoms
irregular.cpp:  // m = index of atom in sendbuf
irregular.cpp:  // wait on all incoming messages
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:  // setup for collective comm
irregular.cpp:  // work1 = 1 for procs I send a message to, not including self
irregular.cpp:  // work2 = 1 for all procs, used for ReduceScatter
irregular.cpp:  // nrecv_proc = # of procs I receive messages from, not including self
irregular.cpp:  // options for performing ReduceScatter operation
irregular.cpp:  // some are more efficient on some machines at big sizes
irregular.cpp:  // allocate receive arrays
irregular.cpp:  // work1 = # of datums I send to each proc, including self
irregular.cpp:  // nsend_proc = # of procs I send messages to, not including self
irregular.cpp:  // allocate send and self arrays
irregular.cpp:  // proc_send = procs I send to
irregular.cpp:  // num_send = # of datums I send to each proc
irregular.cpp:  // num_self = # of datums I copy to self
irregular.cpp:  // to balance pattern of send messages:
irregular.cpp:  //   each proc begins with iproc > me, continues until iproc = me
irregular.cpp:  // reset work1 to store which send message each proc corresponds to
irregular.cpp:  // work2 = offsets into index_send for each proc I send to
irregular.cpp:  // m = ptr into index_self
irregular.cpp:  // index_send = list of which datums to send to each proc
irregular.cpp:  //   1st N1 values are datum indices for 1st proc,
irregular.cpp:  //   next N2 values are datum indices for 2nd proc, etc
irregular.cpp:  // index_self = list of which datums to copy to self
irregular.cpp:  // tell receivers how much data I send
irregular.cpp:  // sendmax_proc = largest # of datums I send in a single message
irregular.cpp:    MPI_Request tmpReq; // Use non-blocking send to avoid possible deadlock
irregular.cpp:    MPI_Request_free(&tmpReq); // the MPI_Barrier below marks completion
irregular.cpp:  // receive incoming messages
irregular.cpp:  // proc_recv = procs I recv from
irregular.cpp:  // num_recv = total size of message each proc sends me
irregular.cpp:  // nrecvdatum = total size of data I recv
irregular.cpp:  // sort proc_recv and num_recv by proc ID if requested
irregular.cpp:  // useful for debugging to insure reproducible ordering of received datums
irregular.cpp:  // barrier to insure all MPI_ANY_SOURCE messages are received
irregular.cpp:  // else another proc could proceed to exchange_data() and send to me
irregular.cpp:  // return # of datums I will receive
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:  // post all receives, starting after self copies
irregular.cpp:  // reallocate buf for largest send if necessary
irregular.cpp:  // send each message
irregular.cpp:  // pack buf with list of datums
irregular.cpp:  // m = index of datum in sendbuf
irregular.cpp:  // copy datums to self, put at beginning of recvbuf
irregular.cpp:  // wait on all incoming messages
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:   if flag = 0, don't need to realloc with copy, just free/malloc
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:   free/malloc the size of the recv buffer as needed with BUFFACTOR
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:/* ----------------------------------------------------------------------
irregular.cpp:------------------------------------------------------------------------- */
irregular.cpp:  bytes += maxsend*sizeof(double);   // buf_send
irregular.cpp:  bytes += maxrecv*sizeof(double);   // buf_recv
irregular.cpp:  bytes += maxdbuf*sizeof(double);   // dbuf
irregular.cpp:  bytes += maxbuf;                   // buf
irregular.cpp:  bytes += 2*maxlocal*sizeof(int);   // mproclist,msizes
irregular.cpp:  bytes += 2*nprocs*sizeof(int);     // work1,work2
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
kspace.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:/* ---------------------------------------------------------------------- */
kspace.cpp:  // default to using MPI collectives for FFT/remap only on IBM BlueGene
kspace.cpp:    (force->qelectron * force->qelectron) /
kspace.cpp:  gcons[2][0] = 15.0 / 8.0;
kspace.cpp:  gcons[2][1] = -5.0 / 4.0;
kspace.cpp:  gcons[2][2] = 3.0 / 8.0;
kspace.cpp:  gcons[3][0] = 35.0 / 16.0;
kspace.cpp:  gcons[3][1] = -35.0 / 16.0;
kspace.cpp:  gcons[3][2] = 21.0 / 16.0;
kspace.cpp:  gcons[3][3] = -5.0 / 16.0;
kspace.cpp:  gcons[4][0] = 315.0 / 128.0;
kspace.cpp:  gcons[4][1] = -105.0 / 32.0;
kspace.cpp:  gcons[4][2] = 189.0 / 64.0;
kspace.cpp:  gcons[4][3] = -45.0 / 32.0;
kspace.cpp:  gcons[4][4] = 35.0 / 128.0;
kspace.cpp:  gcons[5][0] = 693.0 / 256.0;
kspace.cpp:  gcons[5][1] = -1155.0 / 256.0;
kspace.cpp:  gcons[5][2] = 693.0 / 128.0;
kspace.cpp:  gcons[5][3] = -495.0 / 128.0;
kspace.cpp:  gcons[5][4] = 385.0 / 256.0;
kspace.cpp:  gcons[5][5] = -63.0 / 256.0;
kspace.cpp:  gcons[6][0] = 3003.0 / 1024.0;
kspace.cpp:  gcons[6][1] = -3003.0 / 512.0;
kspace.cpp:  gcons[6][2] = 9009.0 / 1024.0;
kspace.cpp:  gcons[6][3] = -2145.0 / 256.0;
kspace.cpp:  gcons[6][4] = 5005.0 / 1024.0;
kspace.cpp:  gcons[6][5] = -819.0 / 512.0;
kspace.cpp:  gcons[6][6] = 231.0 / 1024.0;
kspace.cpp:  dgcons[2][0] = -5.0 / 2.0;
kspace.cpp:  dgcons[2][1] = 3.0 / 2.0;
kspace.cpp:  dgcons[3][0] = -35.0 / 8.0;
kspace.cpp:  dgcons[3][1] = 21.0 / 4.0;
kspace.cpp:  dgcons[3][2] = -15.0 / 8.0;
kspace.cpp:  dgcons[4][0] = -105.0 / 16.0;
kspace.cpp:  dgcons[4][1] = 189.0 / 16.0;
kspace.cpp:  dgcons[4][2] = -135.0 / 16.0;
kspace.cpp:  dgcons[4][3] = 35.0 / 16.0;
kspace.cpp:  dgcons[5][0] = -1155.0 / 128.0;
kspace.cpp:  dgcons[5][1] = 693.0 / 32.0;
kspace.cpp:  dgcons[5][2] = -1485.0 / 64.0;
kspace.cpp:  dgcons[5][3] = 385.0 / 32.0;
kspace.cpp:  dgcons[5][4] = -315.0 / 128.0;
kspace.cpp:  dgcons[6][0] = -3003.0 / 256.0;
kspace.cpp:  dgcons[6][1] = 9009.0 / 256.0;
kspace.cpp:  dgcons[6][2] = -6435.0 / 128.0;
kspace.cpp:  dgcons[6][3] = 5005.0 / 128.0;
kspace.cpp:  dgcons[6][4] = -4095.0 / 256.0;
kspace.cpp:  dgcons[6][5] = 693.0 / 256.0;
kspace.cpp:/* ---------------------------------------------------------------------- */
kspace.cpp:/* ---------------------------------------------------------------------- */
kspace.cpp:/* ---------------------------------------------------------------------- */
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:  eflag_atom = eflag / 2;
kspace.cpp:  vflag_atom = vflag / 4;
kspace.cpp:  // reallocate per-atom arrays if necessary
kspace.cpp:  // zero accumulators
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:   compute qsum,qsqsum,q2 and give error/warning if not charge neutral
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:  // not yet sure of the correction needed for non-neutral systems
kspace.cpp:  // so issue warning or error
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:   see http://www.loria.fr/~shornus/ellipsoid-bbox.html and
kspace.cpp:   http://yiningkarlli.blogspot.com/2013/02/
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:         xy*xy*yz*yz)/(lx*ly*lz);
kspace.cpp:  b[1] = r*sqrt(lz*lz + yz*yz)/(ly*lz);
kspace.cpp:  b[2] = r/lz;
kspace.cpp:/* ----------------------------------------------------------------------
kspace.cpp:------------------------------------------------------------------------- */
kspace.cpp:    } else if (strcmp(arg[iarg],"mesh/disp") == 0) {
kspace.cpp:    } else if (strcmp(arg[iarg],"order/disp") == 0) {
kspace.cpp:    } else if (strcmp(arg[iarg],"gewald/disp") == 0) {
kspace.cpp:    } else if (strcmp(arg[iarg],"cutoff/adjust") == 0) {
kspace.cpp:    } else if (strcmp(arg[iarg],"kmax/ewald") == 0) {
kspace.cpp:	error->all(FLERR,"Bad kspace_modify kmax/ewald parameter");
kspace.cpp:    } else if (strcmp(arg[iarg],"mix/disp") == 0) {
kspace.cpp:    } else if (strcmp(arg[iarg],"force/disp/real") == 0) {
kspace.cpp:    } else if (strcmp(arg[iarg],"force/disp/kspace") == 0) {
kspace.cpp:    } else if (strcmp(arg[iarg],"pressure/scalar") == 0) {
kspace.cpp:    } else if (strcmp(arg[iarg],"disp/auto") == 0) {
kspace.cpp:/* ---------------------------------------------------------------------- */
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
lammps.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
lammps.cpp:------------------------------------------------------------------------- */
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:------------------------------------------------------------------------- */
lammps.cpp:  // parse input switches
lammps.cpp:      // delimit any extra args for the Kokkos instantiation
lammps.cpp:      // delimit args for package command invocation
lammps.cpp:      // any package arg with leading "-" will be followed by numeric digit
lammps.cpp:      // hybrid option to set fall-back for suffix2
lammps.cpp:      // check for restart remap flag
lammps.cpp:      // delimit any extra args for the write_data command
lammps.cpp:  // if no partition command-line switch, universe is one world with all procs
lammps.cpp:  // sum of procs in all worlds must equal total # of procs
lammps.cpp:  // universe cannot use stdin for input file
lammps.cpp:  // if no partition command-line switch, cannot use -pscreen option
lammps.cpp:  // if no partition command-line switch, cannot use -plog option
lammps.cpp:  // set universe screen and logfile
lammps.cpp:  // make universe and single world the same, since no partition switch
lammps.cpp:  // world inherits settings from universe
lammps.cpp:  // set world screen, logfile, communicator, infile
lammps.cpp:  // open input script if from file
lammps.cpp:  // universe is one or more worlds, as setup by partition switch
lammps.cpp:  // split universe communicator into separate world communicators
lammps.cpp:  // set world screen, logfile, communicator, infile
lammps.cpp:  // open input script
lammps.cpp:    // screen and logfile messages for universe and world
lammps.cpp:  // check consistency of datatype settings in lmptype.h
lammps.cpp:  // create Kokkos class if KOKKOS installed, unless explicitly switched off
lammps.cpp:  // instantiation creates dummy Kokkos class if KOKKOS is not installed
lammps.cpp:  // add args between kkfirst and kklast to Kokkos instantiation
lammps.cpp:  // allocate CiteMe class if enabled
lammps.cpp:  // allocate input class now that MPI is fully setup
lammps.cpp:  // copy package cmdline arguments
lammps.cpp:  // allocate top-level classes
lammps.cpp:  // if helpflag set, print help and quit with "success" status
lammps.cpp:  // if restartflag set, invoke 2 commands and quit
lammps.cpp:  // add args between wdfirst and wdlast to write_data command
lammps.cpp:  // also add "noinit" to prevent write_data from doing system init
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:------------------------------------------------------------------------- */
lammps.cpp:    totalclock  = (totalclock - seconds) / 60.0;
lammps.cpp:    int hours = (totalclock - minutes) / 60.0;
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:------------------------------------------------------------------------- */
lammps.cpp:  force = NULL;         // Domain->Lattice checks if Force exists
lammps.cpp:  // Comm class must be created before Atom class
lammps.cpp:  // so that nthreads is defined when create_avec invokes grow()
lammps.cpp:    atom->create_avec("atomic/kk",0,NULL,1);
lammps.cpp:  force = new Force(this);    // must be after group, to create temperature
lammps.cpp:  output = new Output(this);  // must be after group, so "all" exists
lammps.cpp:                              // must be after modify so can create Computes
lammps.cpp:  update = new Update(this);  // must be after output, force, neighbor
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:------------------------------------------------------------------------- */
lammps.cpp:  // default package command triggered by "-k on"
lammps.cpp:  // suffix will always be set if suffix_enable = 1
lammps.cpp:  // check that KOKKOS package classes were instantiated
lammps.cpp:  // check that GPU, INTEL, USER-OMP fixes were compiled with LAMMPS
lammps.cpp:  // invoke any command-line package commands
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:------------------------------------------------------------------------- */
lammps.cpp:  force->init();         // pair must come after update due to minimizer
lammps.cpp:  atom->init();          // atom must come after force and domain
lammps.cpp:                         //   atom deletes extra array
lammps.cpp:                         //   used by fix shear_history::unpack_restart()
lammps.cpp:                         //     when force->pair->gran_history creates fix
lammps.cpp:                         //   atom_vec init uses deform_vremap
lammps.cpp:  modify->init();        // modify must come after update, force, atom, domain
lammps.cpp:  neighbor->init();      // neighbor must come after force, modify
lammps.cpp:  comm->init();          // comm must come after force, modify, neighbor, atom
lammps.cpp:  output->init();        // output must come after domain, force, modify
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:------------------------------------------------------------------------- */
lammps.cpp:  delete modify;          // modify must come after output, force, update
lammps.cpp:                          //   since they delete fixes
lammps.cpp:  delete domain;          // domain must come after modify
lammps.cpp:                          //   since fix destructors access domain
lammps.cpp:  delete atom;            // atom must come after modify, neighbor
lammps.cpp:                          //   since fixes delete callbacks in atom
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:------------------------------------------------------------------------- */
lammps.cpp:  // if output is "stdout", use a pipe to a pager for paged output.
lammps.cpp:  // this will avoid the most important help text to rush past the
lammps.cpp:  // user. scrollback buffers are often not large enough. this is most
lammps.cpp:  // beneficial to windows users, who are not used to command line.
lammps.cpp:    // reset to original state, if pipe command failed
lammps.cpp:  // general help message about command line and flags
lammps.cpp:          "\nLarge-scale Atomic/Molecular Massively Parallel Simulator - "
lammps.cpp:          "-echo none/screen/log/both  : echoing of input script (-e)\n"
lammps.cpp:          "-kokkos on/off ...          : turn KOKKOS mode on or off (-k)\n"
lammps.cpp:          "-log none/filename          : where to send log output (-l)\n"
lammps.cpp:          "-screen none/filename       : where to send screen output (-sc)\n"
lammps.cpp:          "-suffix gpu/intel/opt/omp   : style suffix to apply (-sf)\n"
lammps.cpp:  // close pipe to pager, if active
lammps.cpp:/* ----------------------------------------------------------------------
lammps.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
lattice.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ---------------------------------------------------------------------- */
lattice.cpp:  // parse style arg
lattice.cpp:    // Domain creates a default lattice of style "none"
lattice.cpp:    //   before Force class is instantiated, just use atof() in that case
lattice.cpp:  // check that lattice matches dimension
lattice.cpp:  // style CUSTOM can be either 2d or 3d
lattice.cpp:  // scale = conversion factor between lattice and box units
lattice.cpp:  // set basis atoms for each style
lattice.cpp:  // x,y,z = fractional coords within unit cell
lattice.cpp:  // style CUSTOM will be defined by optional args
lattice.cpp:    add_basis(0.5,5.0/6.0,0.5);
lattice.cpp:    add_basis(0.0,1.0/3.0,0.5);
lattice.cpp:  // set defaults for optional args
lattice.cpp:    a3[2] = sqrt(8.0/3.0);
lattice.cpp:  // process optional args
lattice.cpp:  // check settings for errors
lattice.cpp:  // reset scale for LJ units (input scale is rho*)
lattice.cpp:  // scale = (Nbasis/(Vprimitive * rho*)) ^ (1/dim)
lattice.cpp:    scale = pow(nbasis/volume/scale,1.0/dimension);
lattice.cpp:  // initialize lattice <-> box transformation matrices
lattice.cpp:  // convert 8 corners of primitive unit cell from lattice coords to box coords
lattice.cpp:  // min to max = bounding box around the pts in box space
lattice.cpp:  // xlattice,ylattice,zlattice = extent of bbox in box space
lattice.cpp:  // set xlattice,ylattice,zlattice to 0.0 initially
lattice.cpp:  //   since bbox uses them to shift origin (irrelevant for this computation)
lattice.cpp:  // print lattice spacings
lattice.cpp:/* ---------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:  // primitive = 3x3 matrix with primitive vectors as columns
lattice.cpp:  // priminv = inverse of primitive
lattice.cpp:                   primitive[1][2]*primitive[2][1]) / determinant;
lattice.cpp:                   primitive[1][0]*primitive[2][2]) / determinant;
lattice.cpp:                   primitive[1][1]*primitive[2][0]) / determinant;
lattice.cpp:                   primitive[0][1]*primitive[2][2]) / determinant;
lattice.cpp:                   primitive[0][2]*primitive[2][0]) / determinant;
lattice.cpp:                   primitive[0][0]*primitive[2][1]) / determinant;
lattice.cpp:                   primitive[0][2]*primitive[1][1]) / determinant;
lattice.cpp:                   primitive[0][0]*primitive[1][2]) / determinant;
lattice.cpp:                   primitive[0][1]*primitive[1][0]) / determinant;
lattice.cpp:  // rotaterow = 3x3 matrix with normalized orient vectors as rows
lattice.cpp:  rotaterow[0][0] = orientx[0] / length;
lattice.cpp:  rotaterow[0][1] = orientx[1] / length;
lattice.cpp:  rotaterow[0][2] = orientx[2] / length;
lattice.cpp:  rotaterow[1][0] = orienty[0] / length;
lattice.cpp:  rotaterow[1][1] = orienty[1] / length;
lattice.cpp:  rotaterow[1][2] = orienty[2] / length;
lattice.cpp:  rotaterow[2][0] = orientz[0] / length;
lattice.cpp:  rotaterow[2][1] = orientz[1] / length;
lattice.cpp:  rotaterow[2][2] = orientz[2] / length;
lattice.cpp:  // rotatecol = 3x3 matrix with normalized orient vectors as columns
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:   transformation: xyz_latt = P_inv * 1/scale * Rotate_col * (xyz_box - offset)
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:  x1 /= scale;
lattice.cpp:  y1 /= scale;
lattice.cpp:  z1 /= scale;
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
lattice.cpp:/* ----------------------------------------------------------------------
lattice.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
library.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
library.cpp:------------------------------------------------------------------------- */
library.cpp:// C or Fortran style library interface to LAMMPS
library.cpp:// customize by adding new LAMMPS-specific functions
library.cpp:// ----------------------------------------------------------------------
library.cpp:// utility macros
library.cpp:// ----------------------------------------------------------------------
library.cpp:/* ----------------------------------------------------------------------
library.cpp:     // code paths which might throw exception
library.cpp:------------------------------------------------------------------------- */
library.cpp:// ----------------------------------------------------------------------
library.cpp:// helper functions, not in library API
library.cpp:// ----------------------------------------------------------------------
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:// ----------------------------------------------------------------------
library.cpp:// library API functions to create/destroy an instance of LAMMPS
library.cpp://   and communicate commands to it
library.cpp:// ----------------------------------------------------------------------
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:  char *str = (char *) lmp->memory->smalloc(n,"lib/commands/list:str");
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:  // make copy of str so can strtok() it
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:// ----------------------------------------------------------------------
library.cpp:// library API functions to extract info from LAMMPS or set info in LAMMPS
library.cpp:// ----------------------------------------------------------------------
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:  // update->atime can be referenced as a pointer
library.cpp:  // thermo "timer" data cannot be, since it is computed on request
library.cpp:  // lammps_get_thermo() can access all thermo keywords by value
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:   returns a NULL if id is not recognized or style/type not supported
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:   returns a NULL if id is not recognized or style/type not supported
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:    // error if tags are not defined or not consecutive
library.cpp:    // copy = Natom length vector of per-atom values
library.cpp:    // use atom ID to insert each atom's values into copy
library.cpp:    // MPI_Allreduce with MPI_SUM to merge into data, ordered by atom ID
library.cpp:      lmp->memory->create(copy,count*natoms,"lib/gather:copy");
library.cpp:      lmp->memory->create(copy,count*natoms,"lib/gather:copy");
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:    // error if tags are not defined or not consecutive or no atom map
library.cpp:    // copy = Natom length vector of per-atom values
library.cpp:    // use atom ID to insert each atom's values into copy
library.cpp:    // MPI_Allreduce with MPI_SUM to merge into data, ordered by atom ID
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:    // error if box does not exist or tags not defined
library.cpp:    // loop over N atoms of entire system
library.cpp:    // if this proc owns it based on coords, invoke create_atom()
library.cpp:    // optionally set atom tags and velocities
library.cpp:    // need to reset atom->natoms inside LAMMPS
library.cpp:    // init per-atom fix/compute/variable values for created atoms
library.cpp:    // if global map exists, reset it
library.cpp:    // invoke map_init() b/c atom count has grown
library.cpp:    // warn if new natoms is not correct
library.cpp:// ----------------------------------------------------------------------
library.cpp:// library API functions for error handling
library.cpp:// ----------------------------------------------------------------------
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
library.cpp:/* ----------------------------------------------------------------------
library.cpp:------------------------------------------------------------------------- */
main.cpp:/* ----------------------------------------------------------------------
main.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
main.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
main.cpp:------------------------------------------------------------------------- */
main.cpp:/* ----------------------------------------------------------------------
main.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
math_extra.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:  // create augmented matrix for pivoting
math_extra.cpp:      double m = aug[j][i]/aug[i][i];
math_extra.cpp:  // back substitution
math_extra.cpp:  ans[2] = aug[2][3]/aug[2][2];
math_extra.cpp:    ans[i] = (aug[i][3]-sumax) / aug[i][i];
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:    if (iter < 4) tresh = 0.2*sm/(3*3);
math_extra.cpp:          if (fabs(h)+g == fabs(h)) t = (matrix[i][j])/h;
math_extra.cpp:            theta = 0.5*h/(matrix[i][j]);
math_extra.cpp:            t = 1.0/(fabs(theta)+sqrt(1.0+theta*theta));
math_extra.cpp:          c = 1.0/sqrt(1.0+t*t);
math_extra.cpp:          tau = s/(1.0+c);
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:   also returns updated omega at 1/2 step
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:  // full update from dq/dt = 1/2 w q
math_extra.cpp:  // 1st half update from dq/dt = 1/2 w q
math_extra.cpp:  // re-compute omega at 1/2 step from m at 1/2 step and q at 1/2 step
math_extra.cpp:  // recompute wq
math_extra.cpp:  // 2nd half update from dq/dt = 1/2 w q
math_extra.cpp:  // corrected Richardson update
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:  // apply permuation operator on p and q, get kp and kq
math_extra.cpp:  // obtain phi, cosines and sines
math_extra.cpp:  else phi /= 4.0 * inertia[k-1];
math_extra.cpp:  // advance p and q
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:   wbody = Mbody / Idiag
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:  else wbody[0] = (m[0]*ex[0] + m[1]*ex[1] + m[2]*ex[2]) / idiag[0];
math_extra.cpp:  else wbody[1] = (m[0]*ey[0] + m[1]*ey[1] + m[2]*ey[2]) / idiag[1];
math_extra.cpp:  else wbody[2] = (m[0]*ez[0] + m[1]*ez[1] + m[2]*ez[2]) / idiag[2];
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:  else wbody[0] /= moments[0];
math_extra.cpp:  else wbody[1] /= moments[1];
math_extra.cpp:  else wbody[2] /= moments[2];
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:  // squares of quaternion components
math_extra.cpp:  // some component must be greater than 1/4 since they sum to 1
math_extra.cpp:  // compute other components from it
math_extra.cpp:    q[1] = (ey[2] - ez[1]) / (4.0*q[0]);
math_extra.cpp:    q[2] = (ez[0] - ex[2]) / (4.0*q[0]);
math_extra.cpp:    q[3] = (ex[1] - ey[0]) / (4.0*q[0]);
math_extra.cpp:    q[0] = (ey[2] - ez[1]) / (4.0*q[1]);
math_extra.cpp:    q[2] = (ey[0] + ex[1]) / (4.0*q[1]);
math_extra.cpp:    q[3] = (ex[2] + ez[0]) / (4.0*q[1]);
math_extra.cpp:    q[0] = (ez[0] - ex[2]) / (4.0*q[2]);
math_extra.cpp:    q[1] = (ey[0] + ex[1]) / (4.0*q[2]);
math_extra.cpp:    q[3] = (ez[1] + ey[2]) / (4.0*q[2]);
math_extra.cpp:    q[0] = (ex[1] - ey[0]) / (4.0*q[3]);
math_extra.cpp:    q[1] = (ez[0] + ex[2]) / (4.0*q[3]);
math_extra.cpp:    q[2] = (ez[1] + ey[2]) / (4.0*q[3]);
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:  idiag[1] = 1.0/12.0 * mass * length*length;
math_extra.cpp:  idiag[2] = 1.0/12.0 * mass * length*length;
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:   from http://en.wikipedia.org/wiki/Inertia_tensor_of_triangle
math_extra.cpp:   inertia tensor = a/24 (v0^2 + v1^2 + v2^2 + (v0+v1+v2)^2) I - a Vt S V
math_extra.cpp:   S = 1/24 [2 1 1]
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:  double inv24 = mass/24.0;
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp:------------------------------------------------------------------------- */
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp: ------------------------------------------------------------------------- */
math_extra.cpp:  const double cosAngle = (1.0 - angleSq * 0.25) / (1.0 + angleSq * 0.25);
math_extra.cpp:  const double sinAngle = angle / (1.0 + angleSq * 0.25);
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp: ------------------------------------------------------------------------- */
math_extra.cpp:  const double cosAngle = (1.0 - angleSq * 0.25) / (1.0 + angleSq * 0.25);
math_extra.cpp:  const double sinAngle = angle / (1.0 + angleSq * 0.25);
math_extra.cpp:/* ----------------------------------------------------------------------
math_extra.cpp: ------------------------------------------------------------------------- */
math_extra.cpp:  const double cosAngle = (1.0 - angleSq * 0.25) / (1.0 + angleSq * 0.25);
math_extra.cpp:  const double sinAngle = angle / (1.0 + angleSq * 0.25);
math_extra.cpp:/* ---------------------------------------------------------------------- */
math_special.cpp:/* Library libcerf:
math_special.cpp: *   distribute, sublicense, and/or sell copies of the Software, and to
math_special.cpp: *   http://apps.jcns.fz-juelich.de/libcerf
math_special.cpp: *   ../CHANGELOG
math_special.cpp: */
math_special.cpp:/******************************************************************************/
math_special.cpp:/* Lookup-table for Chebyshev polynomials for smaller |x|                     */
math_special.cpp:/******************************************************************************/
math_special.cpp:    // Steven G. Johnson, October 2012.
math_special.cpp:    // Given y100=100*y, where y = 4/(4+x) for x >= 0, compute erfc(x).
math_special.cpp:    // Uses a look-up table of 100 different Chebyshev polynomials
math_special.cpp:    // for y intervals [0,0.01], [0.01,0.02], ...., [0.99,1], generated
math_special.cpp:    // with the help of Maple and a little shell script.  This allows
math_special.cpp:    // the Chebyshev polynomials to be of significantly lower degree (about 1/4)
math_special.cpp:    // compared to fitting the whole [0,1] interval with a single polynomial.
math_special.cpp:    /* we only get here if y = 1, i.e. |x| < 4*eps, in which case
math_special.cpp:     * erfcx is within 1e-15 of 1.. */
math_special.cpp:} /* erfcx_y100 */
math_special.cpp:/* optimizer friendly implementation of exp2(x).
math_special.cpp: */
math_special.cpp:/* IEEE 754 double precision floating point data manipulation */
math_special.cpp:/*  1.00000000000000000000e0, */
math_special.cpp:    x = 1.0 + 2.0*(px/(qx-px));
memory.cpp:/* ----------------------------------------------------------------------
memory.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
memory.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
memory.cpp:------------------------------------------------------------------------- */
memory.cpp:#include "tbb/scalable_allocator.h"
memory.cpp:/* ---------------------------------------------------------------------- */
memory.cpp:/* ----------------------------------------------------------------------
memory.cpp:------------------------------------------------------------------------- */
memory.cpp:/* ----------------------------------------------------------------------
memory.cpp:------------------------------------------------------------------------- */
memory.cpp:/* ----------------------------------------------------------------------
memory.cpp:------------------------------------------------------------------------- */
memory.cpp:/* ----------------------------------------------------------------------
memory.cpp:   erroneous usage of templated create/grow functions
memory.cpp:------------------------------------------------------------------------- */
memory.cpp:  sprintf(str,"Cannot create/grow a vector/array of pointers for %s",name);
min_cg.cpp:/* ----------------------------------------------------------------------
min_cg.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
min_cg.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
min_cg.cpp:------------------------------------------------------------------------- */
min_cg.cpp:// EPS_ENERGY = minimum normalization for energy tolerance
min_cg.cpp:/* ---------------------------------------------------------------------- */
min_cg.cpp:/* ----------------------------------------------------------------------
min_cg.cpp:------------------------------------------------------------------------- */
min_cg.cpp:  // nlimit = max # of CG iterations before restarting
min_cg.cpp:  // set to ndoftotal unless too big
min_cg.cpp:  // initialize working vectors
min_cg.cpp:    // line minimization along direction h from current atom->x
min_cg.cpp:    // function evaluation criterion
min_cg.cpp:    // energy tolerance criterion
min_cg.cpp:    // force tolerance criterion
min_cg.cpp:    // update new search direction h from new f = -Grad(x) and old g
min_cg.cpp:    // this is Polak-Ribieri formulation
min_cg.cpp:    // beta = dotall[0]/gg would be Fletcher-Reeves
min_cg.cpp:    // reinitialize CG every ndof iterations by setting beta = 0.0
min_cg.cpp:    beta = MAX(0.0,(dotall[0] - dotall[1])/gg);
min_cg.cpp:    // reinitialize CG if new search direction h is not downhill
min_cg.cpp:    // output for thermo, dump, restart files
min.cpp:/* ----------------------------------------------------------------------
min.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
min.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
min.cpp:------------------------------------------------------------------------- */
min.cpp:/* ----------------------------------------------------------------------
min.cpp:            JR Shewchuk, http://www-2.cs.cmu.edu/~jrs/jrspapers.html#cg
min.cpp:------------------------------------------------------------------------- */
min.cpp:/* ---------------------------------------------------------------------- */
min.cpp:/* ---------------------------------------------------------------------- */
min.cpp:/* ---------------------------------------------------------------------- */
min.cpp:  // create fix needed for storing atom-based quantities
min.cpp:  // will delete it at end of run
min.cpp:  // clear out extra global and per-atom dof
min.cpp:  // will receive requests for new per-atom dof during pair init()
min.cpp:  // can then add vectors to fix_minimize in setup()
min.cpp:  // virial_style:
min.cpp:  // 1 if computed explicitly by pair->compute via sum over pair interactions
min.cpp:  // 2 if computed implicitly by pair->virial_compute via sum over ghost atoms
min.cpp:  // setup lists of computes for global and per-atom PE and pressure
min.cpp:  // detect if fix omp is present for clearing force arrays
min.cpp:  // set flags for arrays to clear in force_clear()
min.cpp:  // allow pair and Kspace compute() to be turned off via modify flags
min.cpp:  // orthogonal vs triclinic simulation box
min.cpp:  // reset reneighboring criteria if necessary
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:  // setup extra global dof due to fixes
min.cpp:  // cannot be done in init() b/c update init() is before modify init()
min.cpp:  // compute for potential energy
min.cpp:  // style-specific setup does two tasks
min.cpp:  // setup extra global dof vectors
min.cpp:  // setup extra per-atom dof vectors due to requests from Pair classes
min.cpp:  // cannot be done in init() b/c update init() is before modify/pair init()
min.cpp:  // ndoftotal = total dof for entire minimization problem
min.cpp:  // dof for atoms, extra per-atom, extra global
min.cpp:  // setup domain, communication and neighboring
min.cpp:  // acquire ghosts
min.cpp:  // build neighbor lists
min.cpp:  // remove these restriction eventually
min.cpp:                 "Cannot use a damped dynamics min style with fix box/relax");
min.cpp:      error->all(FLERR, "Cannot use hftn min style with fix box/relax");
min.cpp:  // atoms may have migrated in comm->exchange()
min.cpp:  // compute all forces
min.cpp:  // update per-atom minimization variables stored by pair styles
min.cpp:  // stats for initial thermo output
min.cpp:  if (output->thermo->normflag) ecurrent /= atom->natoms;
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:  // setup domain, communication and neighboring
min.cpp:  // acquire ghosts
min.cpp:  // build neighbor lists
min.cpp:  // atoms may have migrated in comm->exchange()
min.cpp:  // compute all forces
min.cpp:  // update per-atom minimization variables stored by pair styles
min.cpp:  // stats for Finish to print
min.cpp:  if (output->thermo->normflag) ecurrent /= atom->natoms;
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:  // minimizer iterations
min.cpp:  // if early exit from iterate loop:
min.cpp:  // set update->nsteps to niter for Finish stats to print
min.cpp:  // set output->next values to this timestep
min.cpp:  // call energy_force() to insure vflag is set when forces computed
min.cpp:  // output->write does final output for thermo, dump, restart files
min.cpp:  // add ntimestep to all computes that store invocation times
min.cpp:  //   since are hardwiring call to thermo/dumps and computes may not be ready
min.cpp:/* ---------------------------------------------------------------------- */
min.cpp:  // stats for Finish to print
min.cpp:  // reset reneighboring criteria
min.cpp:  // delete fix at end of run, so its atom arrays won't persist
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:  // check for reneighboring
min.cpp:  // always communicate since minimizer moved atoms
min.cpp:  // update per-atom minimization variables stored by pair styles
min.cpp:  // fixes that affect minimization
min.cpp:  // compute potential energy of system
min.cpp:  // normalize if thermo PE does
min.cpp:  if (output->thermo->normflag) energy /= atom->natoms;
min.cpp:  // if reneighbored, atoms migrated
min.cpp:  // if resetflag = 1, update x0 of atoms crossing PBC
min.cpp:  // reset vectors used by lo-level minimizer
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:  // clear global force array
min.cpp:  // if either newton flag is set, also include ghosts
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:/* ---------------------------------------------------------------------- */
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:/* ----------------------------------------------------------------------
min.cpp:   eflag/vflag based on computes that need info on this ntimestep
min.cpp:------------------------------------------------------------------------- */
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min.cpp:/* ----------------------------------------------------------------------
min.cpp:------------------------------------------------------------------------- */
min_fire.cpp:/* ----------------------------------------------------------------------
min_fire.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
min_fire.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
min_fire.cpp:------------------------------------------------------------------------- */
min_fire.cpp:// EPS_ENERGY = minimum normalization for energy tolerance
min_fire.cpp:/* ---------------------------------------------------------------------- */
min_fire.cpp:/* ---------------------------------------------------------------------- */
min_fire.cpp:/* ---------------------------------------------------------------------- */
min_fire.cpp:/* ----------------------------------------------------------------------
min_fire.cpp:------------------------------------------------------------------------- */
min_fire.cpp:  // atomic dof
min_fire.cpp:/* ---------------------------------------------------------------------- */
min_fire.cpp:    // vdotfall = v dot f
min_fire.cpp:    // sum vdotf over replicas, if necessary
min_fire.cpp:    // this communicator would be invalid for multiprocess replicas
min_fire.cpp:    // if (v dot f) > 0:
min_fire.cpp:    // v = (1-alpha) v + alpha |v| Fhat
min_fire.cpp:    // |v| = length of v, Fhat = unit f
min_fire.cpp:    // if more than DELAYSTEP since v dot f was negative:
min_fire.cpp:    // increase timestep and decrease alpha
min_fire.cpp:      // sum vdotv over replicas, if necessary
min_fire.cpp:      // this communicator would be invalid for multiprocess replicas
min_fire.cpp:      // sum fdotf over replicas, if necessary
min_fire.cpp:      // this communicator would be invalid for multiprocess replicas
min_fire.cpp:      else scale2 = alpha * sqrt(vdotvall/fdotfall);
min_fire.cpp:    // else (v dot f) <= 0:
min_fire.cpp:    // decrease timestep, reset alpha, set v = 0
min_fire.cpp:    // limit timestep so no particle moves further than dmax
min_fire.cpp:      if (dtvone*vmax > dmax) dtvone = dmax/vmax;
min_fire.cpp:    // min dtv over replicas, if necessary
min_fire.cpp:    // this communicator would be invalid for multiprocess replicas
min_fire.cpp:    // Euler integration step
min_fire.cpp:        dtfm = dtf / rmass[i];
min_fire.cpp:        dtfm = dtf / mass[type[i]];
min_fire.cpp:    // energy tolerance criterion
min_fire.cpp:    // only check after DELAYSTEP elapsed since velocties reset to 0
min_fire.cpp:    // sync across replicas if running multi-replica minimization
min_fire.cpp:    // force tolerance criterion
min_fire.cpp:    // sync across replicas if running multi-replica minimization
min_fire.cpp:    // output for thermo, dump, restart files
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
min_hftn.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp://---- CONSTANTS MAP TO stopstrings DECLARED IN Min.run (min.cpp).
min_hftn.cpp:static const int  STOP_MAX_ITER = Min::MAXITER;        //-- MAX ITERATIONS EXCEEDED
min_hftn.cpp:static const int  STOP_MAX_FORCE_EVALS = Min::MAXEVAL; //-- MAX FORCE EVALUATIONS EXCEEDED
min_hftn.cpp:static const int  STOP_ENERGY_TOL = Min::ETOL;         //-- STEP DID NOT CHANGE ENERGY
min_hftn.cpp:static const int  STOP_FORCE_TOL = Min::FTOL;          //-- CONVERGED TO DESIRED FORCE TOL
min_hftn.cpp:static const int  STOP_TR_TOO_SMALL = Min::TRSMALL;    //-- TRUST REGION TOO SMALL
min_hftn.cpp:static const int  STOP_ERROR = Min::INTERROR;          //-- INTERNAL ERROR
min_hftn.cpp://---- WHEN TESTING ENERGY_TOL, THE ENERGY MAGNITUDE MUST BE AT LEAST THIS BIG.
min_hftn.cpp://---- MACHINE PRECISION IS SOMETIMES DEFINED BY THE C RUNTIME.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- ALLOCATE MEMORY FOR ATOMIC DEGREES OF FREEDOM.
min_hftn.cpp:  //---- ALLOCATE MEMORY FOR EXTRA GLOBAL DEGREES OF FREEDOM.
min_hftn.cpp:  //---- THE FIX MODULE TAKES CARE OF THE FIRST VECTOR, X0 (XK).
min_hftn.cpp:  //---- ALLOCATE MEMORY FOR EXTRA PER-ATOM DEGREES OF FREEDOM.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:   After an energy/force calculation, atoms may migrate from one processor
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- ATOMIC DEGREES OF FREEDOM.
min_hftn.cpp:  //---- EXTRA PER-ATOM DEGREES OF FREEDOM.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- TURN THIS ON TO GENERATE AN OPTIMIZATION PROGRESS FILE.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- DEFINE OUTPUTS PRINTED BY "Finish".
min_hftn.cpp:  //---- SAVE ATOM POSITIONS BEFORE AN ITERATION.
min_hftn.cpp:  //---- FIND THE NUMBER OF UNKNOWNS.
min_hftn.cpp:  //---- INITIALIZE THE TRUST RADIUS BASED ON THE GRADIENT.
min_hftn.cpp:  //---- TRUST RADIUS MUST KEEP STEPS FROM LETTING ATOMS MOVE SO FAR THEY
min_hftn.cpp:  //---- VIOLATE PHYSICS OR JUMP BEYOND A PARALLEL PROCESSING DOMAIN.
min_hftn.cpp:  //---- LINE SEARCH METHODS DO THIS BY RESTRICTING THE LARGEST CHANGE
min_hftn.cpp:  //---- OF ANY ATOM'S COMPONENT TO dmax.  AN EXACT CHECK IS MADE LATER,
min_hftn.cpp:  //---- BUT THIS GUIDES DETERMINATION OF A MAX TRUST RADIUS.
min_hftn.cpp:    //---- CALL THE INNER LOOP TO GET THE NEXT TRUST REGION STEP.
min_hftn.cpp:    double  dCgForce2StopTol = MIN ((dCurrentForce2 / 2.0), 0.1 / (niter+1));
min_hftn.cpp:      //---- THERE WAS AN ERROR.  RESTORE TO LAST ACCEPTED STEP.
min_hftn.cpp:    //---- STOP IF THE CURRENT POSITION WAS FOUND TO BE ALREADY GOOD ENOUGH.
min_hftn.cpp:    //---- IN THIS CASE THE ENERGY AND FORCES ARE ALREADY COMPUTED.
min_hftn.cpp:    //---- COMPUTE THE DIRECTIONAL DERIVATIVE H(x_k) p.
min_hftn.cpp:    //---- COMPUTE p^T grad(x_k) AND SAVE IT FOR PRED.
min_hftn.cpp:    //---- MOVE TO THE NEW POINT AND EVALUATE ENERGY AND FORCES.
min_hftn.cpp:    //---- THIS IS THE PLACE WHERE energy_force IS ALLOWED TO RESET.
min_hftn.cpp:    //---- STOP IF THE FORCE TOLERANCE IS MET.
min_hftn.cpp:      //---- (IMPLICITLY ACCEPT THE LAST STEP TO THE NEW POINT.)
min_hftn.cpp:    //---- STOP IF THE ACTUAL ENERGY REDUCTION IS TINY.
min_hftn.cpp:        //---- (IMPLICITLY ACCEPT THE LAST STEP TO THE NEW POINT.)
min_hftn.cpp:    //---- COMPUTE THE PREDICTED REDUCTION  - p^T grad - 0.5 p^T Hp
min_hftn.cpp:    //---- ACCEPT OR REJECT THE STEP PROPOSED BY THE INNER CG LOOP.
min_hftn.cpp:    //---- WHEN NEAR A SOLUTION, THE FORCE NORM IS PROBABLY MORE ACCURATE,
min_hftn.cpp:    //---- SO DON'T ACCEPT A STEP THAT REDUCES ENERGY SOME TINY AMOUNT
min_hftn.cpp:    //---- WHILE INCREASING THE FORCE NORM.
min_hftn.cpp:      //---- THE STEP IS ACCEPTED.
min_hftn.cpp:      //---- UPDATE THE TRUST REGION BASED ON AGREEMENT BETWEEN
min_hftn.cpp:      //---- THE ACTUAL REDUCTION AND THE PREDICTED MODEL REDUCTION.
min_hftn.cpp:      //---- DMAX VIOLATIONS TRUNCATE THE CG STEP WITHOUT COMPARISONS;
min_hftn.cpp:      //---- BETTER TO ADJUST THE TRUST REGION SO DMAX STOPS HAPPENING.
min_hftn.cpp:      //---- THE STEP IS REJECTED.
min_hftn.cpp:      //---- RESTORE THE LAST X_K POSITION.
min_hftn.cpp:      //---- UPDATE THE TRUST REGION.
min_hftn.cpp:      //---- EXPERIMENTS INDICATE NEGATIVE CURVATURE CAN TAKE A BAD
min_hftn.cpp:      //---- STEP A LONG WAY, SO BE MORE AGGRESSIVE IN THIS CASE.
min_hftn.cpp:      //---- ALSO, IF NEAR A SOLUTION AND DONE WITH NEWTON STEPS,
min_hftn.cpp:      //---- THEN REDUCE TO SOMETHING NEAR THE LAST GOOD NEWTON STEP.
min_hftn.cpp:      //---- STOP IF THE TRUST RADIUS IS TOO SMALL TO CONTINUE.
min_hftn.cpp:    //---- OUTPUT FOR thermo, dump, restart FILES.
min_hftn.cpp:      //---- IF THE LAST STEP WAS REJECTED, THEN REEVALUATE ENERGY AND
min_hftn.cpp:      //---- FORCES AT THE OLD POINT SO THE OUTPUT DOES NOT DISPLAY
min_hftn.cpp:      //---- THE INCREASED ENERGY OF THE REJECTED STEP.
min_hftn.cpp:    //---- RETURN IF NUMBER OF EVALUATIONS EXCEEDED.
min_hftn.cpp:  }     //-- END for LOOP OVER niter
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:   @param[in] nMaxEvals        - total energy/force evaluations allowed
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- SET  p_0 = 0.
min_hftn.cpp:  //---- OBTAIN THE ENERGY AND FORCES AT THE INPUT POSITION.
min_hftn.cpp:  //---- RETURN IMMEDIATELY IF THE FORCE TOLERANCE IS ALREADY MET.
min_hftn.cpp:  //---- THE STEP TYPE INFORMS THE CALLER THAT ENERGY AND FORCES HAVE
min_hftn.cpp:  //---- BEEN EVALUATED.
min_hftn.cpp:  //---- r_0 = -grad  (FIRST SEARCH DIRECTION IS STEEPEST DESCENT)
min_hftn.cpp:  //---- d_0 = r_0
min_hftn.cpp:  //---- REMEMBER THAT FORCES = -GRADIENT.
min_hftn.cpp:  //---- LIMIT THE NUMBER OF INNER CG ITERATIONS.
min_hftn.cpp:  //---- BASE IT ON THE NUMBER OF UNKNOWNS, OR MAXIMUM EVALUATIONS ASSUMING
min_hftn.cpp:  //---- FORWARD DIFFERENCES ARE USED.
min_hftn.cpp:  //---- NOTE THAT SETTING MAX=1 GIVES STEEPEST DESCENT.
min_hftn.cpp:  int  nLimit1 = _nNumUnknowns / 5;
min_hftn.cpp:  int  nLimit2 = (nMaxEvals - neval) / 2;
min_hftn.cpp:  //---- FURTHER LIMIT ITERATIONS IF NEAR MACHINE ROUNDOFF.
min_hftn.cpp:  //---- THE METHOD CAN WASTE A LOT EVALUATIONS WITH LITTLE PAYOFF PROSPECT.
min_hftn.cpp:    nMaxInnerIters = MIN (nMaxInnerIters, _nNumUnknowns / 20);
min_hftn.cpp:  //---- MAIN CG LOOP.
min_hftn.cpp:    //---- COMPUTE HESSIAN-VECTOR PRODUCT:  H(x_k) d_i.
min_hftn.cpp:    //---- CALCULATE  d_i^T H d_i AND d_i^T d_i.
min_hftn.cpp:    //---- HANDLE NEGATIVE CURVATURE.
min_hftn.cpp:      //---- PROJECT BOTH DIRECTIONS TO THE TRUST RADIUS AND DECIDE
min_hftn.cpp:      //---- WHICH MAKES A BETTER PREDICTED REDUCTION.
min_hftn.cpp:      //---- p_i^T H(x_k) d_i AND grad_i^T d_i.
min_hftn.cpp:      //---- MOVE TO X_K AND COMPUTE ENERGY AND FORCES.
min_hftn.cpp:      //---- MOVE THE POINT.
min_hftn.cpp:    //---- COMPUTE THE OPTIMAL STEP LENGTH BASED ON THE QUADRATIC CG MODEL.
min_hftn.cpp:    double  dAlpha = dRR / dDHD;
min_hftn.cpp:    //---- MIGHT WANT TO ENABLE THIS TO DEBUG INTERNAL CG STEPS.
min_hftn.cpp:    //fprintf (_fpPrint, "     alpha = %11.8f  neval=%4d\n", dAlpha, neval);
min_hftn.cpp:    //---- p_i+1 = p_i + alpha_i d_i
min_hftn.cpp:    //---- (SAVE THE CURRENT p_i IN CASE THE STEP HAS TO BE SHORTENED.)
min_hftn.cpp:    //---- COMPUTE VECTOR PRODUCTS  p_i+1^T p_i+1 AND p_i^T d_i.
min_hftn.cpp:    //---- IF STEP LENGTH IS TOO LARGE, THEN REDUCE IT AND RETURN.
min_hftn.cpp:    //---- r_i+1 = r_i - alpha * H d_i
min_hftn.cpp:    //---- IF RESIDUAL IS SMALL ENOUGH, THEN RETURN THE CURRENT STEP.
min_hftn.cpp:    //---- beta = r_i+1^T r_i+1 / r_i^T r_i
min_hftn.cpp:    //---- d_i+1 = r_i+1 + beta d_i
min_hftn.cpp:    double  dBeta = dRnewDotRnew / dRR;
min_hftn.cpp:    //---- CONTINUE THE LOOP.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- ASSUME THAT FORCES HAVE BEEN EVALUATED AT DESIRED ATOM POSITIONS.
min_hftn.cpp:  //---- REMEMBER THAT FORCES = -GRADIENT.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- STEP LENGTH IS NOT TOO LONG.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:    dAlpha = MIN (dAlpha, dmax / dPInf);
min_hftn.cpp:        dAlpha = MIN (dAlpha, extra_max[m] / dPInf);
min_hftn.cpp:    //---- IF THE MAXIMUM DISTANCE THAT THE GLOBAL BOX CONSTRAINT WILL
min_hftn.cpp:    //---- ALLOW IS SMALLER THAN THE PROPOSED DISTANCE, THEN THE STEP
min_hftn.cpp:    //---- IS TOO LONG.  PROPOSED DISTANCE IS ESTIMATED BY |P|_INF.
min_hftn.cpp:  //---- STEP LENGTH IS NOT TOO LONG.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- SOLVE A QUADRATIC EQUATION FOR TAU.
min_hftn.cpp:  //---- THE COEFFICIENTS ARE SUCH THAT THERE ARE ALWAYS TWO REAL ROOTS,
min_hftn.cpp:  //---- ONE POSITIVE AND ONE NEGATIVE.
min_hftn.cpp:  //---- CHECK FOR ERRONEOUS DATA.
min_hftn.cpp:  dDiscr = MAX (0.0, dDiscr);    //-- SHOULD NEVER BE NEGATIVE
min_hftn.cpp:  double  dRootPos = (-dPD + dDiscr) / dDD;
min_hftn.cpp:  double  dRootNeg = (-dPD - dDiscr) / dDD;
min_hftn.cpp:  //---- EVALUATE THE CG OBJECTIVE FUNCTION FOR EACH ROOT.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:  //---- COMPUTE THE MAGNITUDE OF THE DIRECTION VECTOR:  |p|_2.
min_hftn.cpp:  //---- IF THE STEP IS TOO SMALL, RETURN ZERO FOR THE DERIVATIVE.
min_hftn.cpp:  //---- FORWARD DIFFERENCES ARE LESS ACCURATE THAN CENTRAL DIFFERENCES,
min_hftn.cpp:  //---- BUT REQUIRE ONLY 2 ENERGY+FORCE EVALUATIONS VERSUS 3 EVALUATIONS.
min_hftn.cpp:  //---- STORAGE REQUIREMENTS ARE THE SAME.
min_hftn.cpp:    //---- EQUATION IS FROM THE OLD LAMMPS VERSION, SAND98-8201.
min_hftn.cpp:    double  dEps = 2.0 * sqrt (1000.0 * MACHINE_EPS) / dDirNorm2;
min_hftn.cpp:    //---- SAVE A COPY OF x.
min_hftn.cpp:    //---- EVALUATE FORCES AT x + eps*p.
min_hftn.cpp:    //---- STORE THE FORCE IN DIF2.
min_hftn.cpp:    //---- MOVE BACK TO x AND EVALUATE FORCES.
min_hftn.cpp:    //---- COMPUTE THE DIFFERENCE VECTOR:  [grad(x + eps*p) - grad(x)] / eps.
min_hftn.cpp:    //---- REMEMBER THAT FORCES = -GRADIENT.
min_hftn.cpp:      _daAVectors[nIxResult][i] = (fvec[i] - _daAVectors[VEC_DIF2][i]) / dEps;
min_hftn.cpp:          iAtom[i] = (fextra_atom[m][i] - d2Atom[i]) / dEps;
min_hftn.cpp:          = (fextra[i] - _daExtraGlobal[VEC_DIF2][i]) / dEps;
min_hftn.cpp:  else {    //-- bUseForwardDiffs == false
min_hftn.cpp:    //---- EQUATION IS FROM THE OLD LAMMPS VERSION, SAND98-8201.
min_hftn.cpp:    double  dEps = pow (3000.0 * MACHINE_EPS, 0.33333333) / dDirNorm2;
min_hftn.cpp:    //---- SAVE A COPY OF x.
min_hftn.cpp:    //---- EVALUATE FORCES AT x + eps*p.
min_hftn.cpp:    //---- STORE THE FORCE IN DIF2.
min_hftn.cpp:    //---- EVALUATE FORCES AT x - eps*p.
min_hftn.cpp:    //---- COMPUTE THE DIFFERENCE VECTOR:
min_hftn.cpp:    //----     [grad(x + eps*p) - grad(x - eps*p)] / 2*eps.
min_hftn.cpp:    //---- REMEMBER THAT FORCES = -GRADIENT.
min_hftn.cpp:        iGlobal[i] = (fextra[i] - d2Global[i]) / (2.0 + dEps);
min_hftn.cpp:        (fvec[i] - _daAVectors[VEC_DIF2][i]) / (2.0 * dEps);
min_hftn.cpp:          iAtom[i] = (fatom[i] - d2Atom[i]) / (2.0 + dEps);
min_hftn.cpp:      //---- EVALUATE FORCES AT x.
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
min_hftn.cpp:/* ----------------------------------------------------------------------
min_hftn.cpp:------------------------------------------------------------------------- */
minimize.cpp:/* ----------------------------------------------------------------------
minimize.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
minimize.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
minimize.cpp:------------------------------------------------------------------------- */
minimize.cpp:/* ---------------------------------------------------------------------- */
minimize.cpp:/* ---------------------------------------------------------------------- */
minimize.cpp:  // ignore minimize command, if walltime limit was already reached
min_linesearch.cpp:/* ----------------------------------------------------------------------
min_linesearch.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
min_linesearch.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
min_linesearch.cpp:------------------------------------------------------------------------- */
min_linesearch.cpp:/* ----------------------------------------------------------------------
min_linesearch.cpp:            JR Shewchuk, http://www-2.cs.cmu.edu/~jrs/jrspapers.html#cg
min_linesearch.cpp:------------------------------------------------------------------------- */
min_linesearch.cpp:// ALPHA_MAX = max alpha allowed to avoid long backtracks
min_linesearch.cpp:// ALPHA_REDUCE = reduction ratio, should be in range [0.5,1)
min_linesearch.cpp:// BACKTRACK_SLOPE, should be in range (0,0.5]
min_linesearch.cpp:// QUADRATIC_TOL = tolerance on alpha0, should be in range [0.1,1)
min_linesearch.cpp:// EMACH = machine accuracy limit of energy changes (1.0e-8)
min_linesearch.cpp:// EPS_QUAD = tolerance for quadratic projection
min_linesearch.cpp://#define EMACH 1.0e-8
min_linesearch.cpp:/* ---------------------------------------------------------------------- */
min_linesearch.cpp:/* ---------------------------------------------------------------------- */
min_linesearch.cpp:/* ---------------------------------------------------------------------- */
min_linesearch.cpp:/* ---------------------------------------------------------------------- */
min_linesearch.cpp:  // memory for x0,g,h for atomic dof
min_linesearch.cpp:  // memory for g,h for extra global dof, fix stores x0
min_linesearch.cpp:  // memory for x0,g,h for extra per-atom dof
min_linesearch.cpp:/* ----------------------------------------------------------------------
min_linesearch.cpp:------------------------------------------------------------------------- */
min_linesearch.cpp:  // atomic dof
min_linesearch.cpp:  // extra per-atom dof
min_linesearch.cpp:/* ----------------------------------------------------------------------
min_linesearch.cpp:                 update neval counter of eng/force function evaluations
min_linesearch.cpp:------------------------------------------------------------------------- */
min_linesearch.cpp:/* ----------------------------------------------------------------------
min_linesearch.cpp:------------------------------------------------------------------------- */
min_linesearch.cpp:  // fdothall = projection of search dir along downhill gradient
min_linesearch.cpp:  // if search direction is not downhill, exit with error
min_linesearch.cpp:  if (output->thermo->normflag) fdothall /= atom->natoms;
min_linesearch.cpp:  // set alpha so no dof is changed by more than max allowed amount
min_linesearch.cpp:  // for atom coords, max amount = dmax
min_linesearch.cpp:  // for extra per-atom dof, max amount = extra_max[]
min_linesearch.cpp:  // for extra global dof, max amount is set by fix
min_linesearch.cpp:  // also insure alpha <= ALPHA_MAX
min_linesearch.cpp:  // else will have to backtrack from huge value when forces are tiny
min_linesearch.cpp:  // if all search dir components are already 0.0, exit with error
min_linesearch.cpp:  alpha = MIN(ALPHA_MAX,dmax/hmaxall);
min_linesearch.cpp:      alpha = MIN(alpha,extra_max[m]/hmax);
min_linesearch.cpp:  // store box and values of all dof at start of linesearch
min_linesearch.cpp:  // // important diagnostic: test the gradient against energy
min_linesearch.cpp:  // double etmp;
min_linesearch.cpp:  // double alphatmp = alpha*1.0e-4;
min_linesearch.cpp:  // etmp = alpha_step(alphatmp,1);
min_linesearch.cpp:  // printf("alpha = %g dele = %g dele_force = %g err = %g\n",
min_linesearch.cpp:  //        alphatmp,etmp-eoriginal,-alphatmp*fdothall,
min_linesearch.cpp:  //        etmp-eoriginal+alphatmp*fdothall);
min_linesearch.cpp:  // alpha_step(0.0,1);
min_linesearch.cpp:  // backtrack with alpha until energy decrease is sufficient
min_linesearch.cpp:    // if energy change is better than ideal, exit with success
min_linesearch.cpp:    // reduce alpha
min_linesearch.cpp:    // backtracked too much
min_linesearch.cpp:    // reset to starting point
min_linesearch.cpp:    // if de is positive, exit with error
min_linesearch.cpp:    // if de is negative, exit with ETOL
min_linesearch.cpp:/* ----------------------------------------------------------------------
min_linesearch.cpp:    // linemin: quadratic line search (adapted from Dennis and Schnabel)
min_linesearch.cpp:    // The objective function is approximated by a quadratic
min_linesearch.cpp:    // function in alpha, for sufficiently small alpha.
min_linesearch.cpp:    // This idea is the same as that used in the well-known secant
min_linesearch.cpp:    // method. However, since the change in the objective function
min_linesearch.cpp:    // (difference of two finite numbers) is not known as accurately
min_linesearch.cpp:    // as the gradient (which is close to zero), all the expressions
min_linesearch.cpp:    // are written in terms of gradients. In this way, we can converge
min_linesearch.cpp:    // the LAMMPS forces much closer to zero.
min_linesearch.cpp:    //
min_linesearch.cpp:    // We know E,Eprev,fh,fhprev. The Taylor series about alpha_prev
min_linesearch.cpp:    // truncated at the quadratic term is:
min_linesearch.cpp:    //
min_linesearch.cpp:    //     E = Eprev - del_alpha*fhprev + (1/2)del_alpha^2*Hprev
min_linesearch.cpp:    //
min_linesearch.cpp:    // and
min_linesearch.cpp:    //
min_linesearch.cpp:    //     fh = fhprev - del_alpha*Hprev
min_linesearch.cpp:    //
min_linesearch.cpp:    // where del_alpha = alpha-alpha_prev
min_linesearch.cpp:    //
min_linesearch.cpp:    // We solve these two equations for Hprev and E=Esolve, giving:
min_linesearch.cpp:    //
min_linesearch.cpp:    //     Esolve = Eprev - del_alpha*(f+fprev)/2
min_linesearch.cpp:    //
min_linesearch.cpp:    // We define relerr to be:
min_linesearch.cpp:    //
min_linesearch.cpp:    //      relerr = |(Esolve-E)/Eprev|
min_linesearch.cpp:    //             = |1.0 - (0.5*del_alpha*(f+fprev)+E)/Eprev|
min_linesearch.cpp:    //
min_linesearch.cpp:    // If this is accurate to within a reasonable tolerance, then
min_linesearch.cpp:    // we go ahead and use a secant step to fh = 0:
min_linesearch.cpp:    //
min_linesearch.cpp:    //      alpha0 = alpha - (alpha-alphaprev)*fh/delfh;
min_linesearch.cpp:    //
min_linesearch.cpp:------------------------------------------------------------------------- */
min_linesearch.cpp:  // fdothall = projection of search dir along downhill gradient
min_linesearch.cpp:  // if search direction is not downhill, exit with error
min_linesearch.cpp:  if (output->thermo->normflag) fdothall /= atom->natoms;
min_linesearch.cpp:  // set alphamax so no dof is changed by more than max allowed amount
min_linesearch.cpp:  // for atom coords, max amount = dmax
min_linesearch.cpp:  // for extra per-atom dof, max amount = extra_max[]
min_linesearch.cpp:  // for extra global dof, max amount is set by fix
min_linesearch.cpp:  // also insure alphamax <= ALPHA_MAX
min_linesearch.cpp:  // else will have to backtrack from huge value when forces are tiny
min_linesearch.cpp:  // if all search dir components are already 0.0, exit with error
min_linesearch.cpp:  alphamax = MIN(ALPHA_MAX,dmax/hmaxall);
min_linesearch.cpp:      alphamax = MIN(alphamax,extra_max[m]/hmax);
min_linesearch.cpp:  // store box and values of all dof at start of linesearch
min_linesearch.cpp:  // backtrack with alpha until energy decrease is sufficient
min_linesearch.cpp:  // or until get to small energy change, then perform quadratic projection
min_linesearch.cpp:  // // important diagnostic: test the gradient against energy
min_linesearch.cpp:  // double etmp;
min_linesearch.cpp:  // double alphatmp = alphamax*1.0e-4;
min_linesearch.cpp:  // etmp = alpha_step(alphatmp,1);
min_linesearch.cpp:  // printf("alpha = %g dele = %g dele_force = %g err = %g\n",
min_linesearch.cpp:  //        alphatmp,etmp-eoriginal,-alphatmp*fdothall,
min_linesearch.cpp:  //        etmp-eoriginal+alphatmp*fdothall);
min_linesearch.cpp:  // alpha_step(0.0,1);
min_linesearch.cpp:    // compute new fh, alpha, delfh
min_linesearch.cpp:      ff /= atom->natoms;
min_linesearch.cpp:      fh /= atom->natoms;
min_linesearch.cpp:    // if fh or delfh is epsilon, reset to starting point, exit with error
min_linesearch.cpp:    // Check if ready for quadratic projection, equivalent to secant method
min_linesearch.cpp:    // alpha0 = projected alpha
min_linesearch.cpp:    relerr = fabs(1.0-(0.5*(alpha-alphaprev)*(fh+fhprev)+ecurrent)/engprev);
min_linesearch.cpp:    alpha0 = alpha - (alpha-alphaprev)*fh/delfh;
min_linesearch.cpp:    // if backtracking energy change is better than ideal, exit with success
min_linesearch.cpp:    // save previous state
min_linesearch.cpp:    // reduce alpha
min_linesearch.cpp:    // backtracked all the way to 0.0
min_linesearch.cpp:    // reset to starting point, exit with error
min_linesearch.cpp:/* ----------------------------------------------------------------------
min_linesearch.cpp:        // also account for nextra atom & global
min_linesearch.cpp:        alpha_max <= dmax/hmaxall
min_linesearch.cpp:        // try decreasing the energy to 1/10 of initial
min_linesearch.cpp:        alpha_init = 0.1*fabs(eoriginal)/fhCurr;
min_linesearch.cpp:        // initial alpha is smaller than alpha_max
min_linesearch.cpp:           // we have done enough in the search space
min_linesearch.cpp:           // ZERO_ENERGY = 1e-12, is max allowed energy increase
min_linesearch.cpp:           // GRAD_TOL = 0.1
min_linesearch.cpp:           if ( (not backtrack) && (fabs(fhCurr/fh0) <= GRAD_TOL) ):
min_linesearch.cpp:              // forces sufficiently reduced without energy increase
min_linesearch.cpp:           // projected force changed sign but didn't become small enough
min_linesearch.cpp:              // forces along search direction changed sign
min_linesearch.cpp:                 // force didn't change sign but only energy increased,
min_linesearch.cpp:                 // we overshot a minimum which is very close to a
min_linesearch.cpp:                 // maximum (or there is an inflection point)
min_linesearch.cpp:                 // New alpha_del should be much smaller
min_linesearch.cpp:                 // ALPHA_FACT = 0.1
min_linesearch.cpp:                 // Check to see if new 'alpha_del' isn't too small
min_linesearch.cpp:           // continue the loop with a new alpha_del
min_linesearch.cpp: ---------------------------------------------------------------------- */
min_linesearch.cpp:  // projection of: force on itself, current force on search direction,
min_linesearch.cpp:  // previous force on search direction, initial force on search direction
min_linesearch.cpp:  // current energy, previous energy
min_linesearch.cpp:  // hardcoded constants
min_linesearch.cpp:  // factor by which alpha is reduced when backtracking
min_linesearch.cpp:  // maximum amount by which we'll permit energy increase
min_linesearch.cpp:  // fraction to which we want to reduce the directional derivative
min_linesearch.cpp:  // largest alpha increment which will trigger a failed_linesearch
min_linesearch.cpp:  // fdothall = projection of search dir along downhill gradient
min_linesearch.cpp:  // if search direction is not downhill, exit with error
min_linesearch.cpp:  if (output->thermo->normflag) fdothall /= atom->natoms;
min_linesearch.cpp:  // set alpha so no dof is changed by more than max allowed amount
min_linesearch.cpp:  // for atom coords, max amount = dmax
min_linesearch.cpp:  // for extra per-atom dof, max amount = extra_max[]
min_linesearch.cpp:  // for extra global dof, max amount is set by fix
min_linesearch.cpp:  // also insure alpha <= ALPHA_MAX else will have
min_linesearch.cpp:  // to backtrack from huge value when forces are tiny
min_linesearch.cpp:  // if all search dir components are already 0.0, exit with error
min_linesearch.cpp:  alpha_max = dmax/hmaxall;
min_linesearch.cpp:      alpha_max = MIN(alpha_max,extra_max[m]/hmax);
min_linesearch.cpp:  // store box and values of all dof at start of linesearch
min_linesearch.cpp:  // initialize important variables before main linesearch loop
min_linesearch.cpp:  // stores energy difference due to the current move
min_linesearch.cpp:  // choosing the initial alpha that we'll use
min_linesearch.cpp:  // rough estimate that'll decrease energy to 1/10
min_linesearch.cpp:  alpha_init = 0.1*fabs(eoriginal)/fdothall;
min_linesearch.cpp:  // initialize aplha to 0.0
min_linesearch.cpp:  // compute increment to alpha, ensure that we
min_linesearch.cpp:  // don't take the largest allowed alpha
min_linesearch.cpp:  // first alpha that will actually apply
min_linesearch.cpp:  // main linesearch loop
min_linesearch.cpp:    // apply the increment to alpha, but first
min_linesearch.cpp:    // check whether we are still in allowed search space
min_linesearch.cpp:      // undo the increment
min_linesearch.cpp:      // exit linesearch with success: have done
min_linesearch.cpp:      // enough in allowed search space
min_linesearch.cpp:    // move the system
min_linesearch.cpp:    // '1' updates coordinates of atoms which cross PBC
min_linesearch.cpp:    // compute the new directional derivative and also f_dot_f
min_linesearch.cpp:    // energy change
min_linesearch.cpp:    // if the function value increases measurably,
min_linesearch.cpp:    // then we have to reduce alpha
min_linesearch.cpp:    // check if the directional derivative has sufficiently decreased
min_linesearch.cpp:    // NOTE: the fabs is essential here
min_linesearch.cpp:    if ((!backtrack) && (fabs(fhCurr/fhoriginal) <= GRAD_TOL)) {
min_linesearch.cpp:      // we are done
min_linesearch.cpp:    // check if the directional derivative changed sign
min_linesearch.cpp:    // but it's not small: we overshot the minima -- BACKTRACK
min_linesearch.cpp:    // backtrack by undoing step and choosing a new alpha
min_linesearch.cpp:      // move back
min_linesearch.cpp:      // choose new alpha
min_linesearch.cpp:      // if the force changed sign, linearize force and
min_linesearch.cpp:      // solve for new alpha_del
min_linesearch.cpp:        alpha_del *= fhPrev/(fhPrev - fhCurr);
min_linesearch.cpp:    // force didn't change sign but only energy increased,
min_linesearch.cpp:    // we overshot a minimum which is very close to a maxima
min_linesearch.cpp:    // (or there is an inflection point)
min_linesearch.cpp:    // new alpha_del should be much smaller
min_linesearch.cpp:      // since we moved back ...
min_linesearch.cpp:      // if new move is too small then we have failed;
min_linesearch.cpp:      // exit with 'failed_linesearch'
min_linesearch.cpp:        // undo all line minization moves
min_linesearch.cpp:      // get a new alpha by linearizing force and start over
min_linesearch.cpp:      // avoids problems near an energy inflection point
min_linesearch.cpp:        boostFactor = fhCurr/(fhPrev - fhCurr);
min_linesearch.cpp:      // don't want to boost too much
min_linesearch.cpp:/* ---------------------------------------------------------------------- */
min_linesearch.cpp:  // reset to starting point
min_linesearch.cpp:  // step forward along h
min_linesearch.cpp:  // compute and return new energy
min_linesearch.cpp:/* ---------------------------------------------------------------------- */
min_linesearch.cpp:// compute projection of force on: itself and the search direction
min_linesearch.cpp:   // compute new fh, alpha, delfh
min_linesearch.cpp:      ff /= atom->natoms;
min_linesearch.cpp:      fh /= atom->natoms;
min_quickmin.cpp:/* ----------------------------------------------------------------------
min_quickmin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
min_quickmin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
min_quickmin.cpp:------------------------------------------------------------------------- */
min_quickmin.cpp:// EPS_ENERGY = minimum normalization for energy tolerance
min_quickmin.cpp:/* ---------------------------------------------------------------------- */
min_quickmin.cpp:/* ---------------------------------------------------------------------- */
min_quickmin.cpp:/* ---------------------------------------------------------------------- */
min_quickmin.cpp:/* ----------------------------------------------------------------------
min_quickmin.cpp:------------------------------------------------------------------------- */
min_quickmin.cpp:  // atomic dof
min_quickmin.cpp:/* ----------------------------------------------------------------------
min_quickmin.cpp:------------------------------------------------------------------------- */
min_quickmin.cpp:    // zero velocity if anti-parallel to force
min_quickmin.cpp:    // else project velocity in direction of force
min_quickmin.cpp:    // sum vdotf over replicas, if necessary
min_quickmin.cpp:    // this communicator would be invalid for multiprocess replicas
min_quickmin.cpp:      // sum fdotf over replicas, if necessary
min_quickmin.cpp:      // this communicator would be invalid for multiprocess replicas
min_quickmin.cpp:      else scale = vdotfall/fdotfall;
min_quickmin.cpp:    // limit timestep so no particle moves further than dmax
min_quickmin.cpp:      if (dtvone*vmax > dmax) dtvone = dmax/vmax;
min_quickmin.cpp:    // min dtv over replicas, if necessary
min_quickmin.cpp:    // this communicator would be invalid for multiprocess replicas
min_quickmin.cpp:    // Euler integration step
min_quickmin.cpp:        dtfm = dtf / rmass[i];
min_quickmin.cpp:        dtfm = dtf / mass[type[i]];
min_quickmin.cpp:    // energy tolerance criterion
min_quickmin.cpp:    // only check after DELAYSTEP elapsed since velocties reset to 0
min_quickmin.cpp:    // sync across replicas if running multi-replica minimization
min_quickmin.cpp:    // force tolerance criterion
min_quickmin.cpp:    // sync across replicas if running multi-replica minimization
min_quickmin.cpp:    // output for thermo, dump, restart files
min_sd.cpp:/* ----------------------------------------------------------------------
min_sd.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
min_sd.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
min_sd.cpp:------------------------------------------------------------------------- */
min_sd.cpp:// EPS_ENERGY = minimum normalization for energy tolerance
min_sd.cpp:/* ---------------------------------------------------------------------- */
min_sd.cpp:/* ----------------------------------------------------------------------
min_sd.cpp:------------------------------------------------------------------------- */
min_sd.cpp:  // initialize working vectors
min_sd.cpp:    // line minimization along h from current position x
min_sd.cpp:    // h = downhill gradient direction
min_sd.cpp:    // function evaluation criterion
min_sd.cpp:    // energy tolerance criterion
min_sd.cpp:    // force tolerance criterion
min_sd.cpp:    // set new search direction h to f = -Grad(x)
min_sd.cpp:    // output for thermo, dump, restart files
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
modify.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:#define NEXCEPT 7       // change when add to exceptions in add_fix()
modify.cpp:/* ---------------------------------------------------------------------- */
modify.cpp:  // fill map with fixes listed in style_fix.h
modify.cpp:  // fill map with computes listed in style_compute.h
modify.cpp:/* ---------------------------------------------------------------------- */
modify.cpp:  // delete all fixes
modify.cpp:  // do it via delete_fix() so callbacks in Atom are also updated correctly
modify.cpp:  // delete all computes
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // delete storage of restart info since it is not valid after 1st run
modify.cpp:  // create lists of fixes to call at each stage of run
modify.cpp:  // init each fix
modify.cpp:  // not sure if now needs to come before compute init
modify.cpp:  // used to b/c temperature computes called fix->dof() in their init,
modify.cpp:  // and fix rigid required its own init before its dof() could be called,
modify.cpp:  // but computes now do their DOF in setup()
modify.cpp:  // set global flag if any fix has its restart_pbc flag set
modify.cpp:  // create list of computes that store invocation times
modify.cpp:  // init each compute
modify.cpp:  // set invoked_scalar,vector,etc to -1 to force new run to re-compute them
modify.cpp:  // add initial timestep to all computes that store invocation times
modify.cpp:  //   since any of them may be invoked by initial thermo
modify.cpp:  // do not clear out invocation times stored within a compute,
modify.cpp:  //   b/c some may be holdovers from previous run, like for ave fixes
modify.cpp:  // error if any fix or compute is using a dynamic group when not allowed
modify.cpp:  // warn if any particle is time integrated more than once
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // compute setup needs to come before fix setup
modify.cpp:  //   b/c NH fixes need DOF of temperature computes
modify.cpp:  // fix group setup() is special case since populates a dynamic group
modify.cpp:  //   needs to be done before temperature compute setup
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:   called by compute pe/atom
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:   minimizer energy/force evaluation, only for relevant fixes
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // cannot define fix before box exists unless style is in exception list
modify.cpp:  // don't like this way of checking for exceptions by adding fixes to list,
modify.cpp:  //   but can't think of better way
modify.cpp:  // too late if instantiate fix, then check flag set in fix constructor,
modify.cpp:  //   since some fixes access domain settings in their constructor
modify.cpp:  // MUST change NEXCEPT above when add new fix to this list
modify.cpp:    {"GPU","OMP","INTEL","property/atom","cmap","cmap3","rx"};
modify.cpp:  // check group ID
modify.cpp:  // if fix ID exists:
modify.cpp:  //   set newflag = 0 so create new fix in same location in fix list
modify.cpp:  //   error if new style does not match old style
modify.cpp:  //     since can't replace it (all when-to-invoke ptrs would be invalid)
modify.cpp:  //   warn if new group != old group
modify.cpp:  //   delete old fix, but do not call update_callback(),
modify.cpp:  //     since will replace this fix and thus other fix locs will not change
modify.cpp:  //   set ptr to NULL in case new fix scans list of fixes,
modify.cpp:  //     e.g. scan will occur in add_callback() if called by new fix
modify.cpp:  // if fix ID does not exist:
modify.cpp:  //   set newflag = 1 so create new fix
modify.cpp:  //   extend fix and fmask lists as necessary
modify.cpp:        sprintf(estyle,"%s/%s",arg[2],lmp->suffix);
modify.cpp:        sprintf(estyle,"%s/%s",arg[2],lmp->suffix2);
modify.cpp:  // create the Fix
modify.cpp:  // try first with suffix appended
modify.cpp:      sprintf(estyle,"%s/%s",arg[2],lmp->suffix);
modify.cpp:      sprintf(estyle,"%s/%s",arg[2],lmp->suffix2);
modify.cpp:  // check if Fix is in restart_global list
modify.cpp:  // if yes, pass state info to the Fix so it can reset itself
modify.cpp:  // check if Fix is in restart_peratom list
modify.cpp:  // if yes, loop over atoms so they can extract info from atom->extra array
modify.cpp:  // increment nfix (if new)
modify.cpp:  // set fix mask values
modify.cpp:  // post_constructor() allows new fix to create other fixes
modify.cpp:  // nfix increment comes first so that recursive call to add_fix within
modify.cpp:  //   post_constructor() will see updated nfix
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // lookup Fix ID
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // move other Fixes and fmask down in list one slot
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // error check
modify.cpp:  // extend Compute list if necessary
modify.cpp:  // create the Compute
modify.cpp:  // try first with suffix appended
modify.cpp:      sprintf(estyle,"%s/%s",arg[2],lmp->suffix);
modify.cpp:      sprintf(estyle,"%s/%s",arg[2],lmp->suffix2);
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // lookup Compute ID
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // move other Computes down in list one slot
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:  // nfix_restart_global = # of restart entries with global state info
modify.cpp:  // allocate space for each entry
modify.cpp:  // read each entry and Bcast to all procs
modify.cpp:  // each entry has id string, style string, chunk of state data
modify.cpp:  // nfix_restart_peratom = # of restart entries with peratom info
modify.cpp:  // allocate space for each entry
modify.cpp:  // read each entry and Bcast to all procs
modify.cpp:  // each entry has id string, style string, maxsize of one atom's data
modify.cpp:  // set index = which set of extra data this fix represents
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
modify.cpp:/* ----------------------------------------------------------------------
modify.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
molecule.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:#define SINERTIA 0.4            // moment of inertia prefactor for sphere
molecule.cpp:/* ---------------------------------------------------------------------- */
molecule.cpp:  // parse args until reach unknown arg (next file)
molecule.cpp:  // last molecule if have scanned all args
molecule.cpp:  // initialize all fields to empty
molecule.cpp:  // scan file for sizes of all fields and allocate them
molecule.cpp:  // read file again to populate all fields
molecule.cpp:  // stats
molecule.cpp:/* ---------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  center[0] /= natoms;
molecule.cpp:  center[1] /= natoms;
molecule.cpp:  center[2] /= natoms;
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:      com[0] /= masstotal;
molecule.cpp:      com[1] /= masstotal;
molecule.cpp:      com[2] /= masstotal;
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  // diagonalize inertia tensor for each body via Jacobi rotations
molecule.cpp:  // inertia = 3 eigenvalues = principal moments of inertia
molecule.cpp:  // evectors and exzy = 3 evectors = principal axes of rigid body
molecule.cpp:  // if any principal moment < scaled EPSILON, set to 0.0
molecule.cpp:  // enforce 3 evectors as a right-handed coordinate system
molecule.cpp:  // flip 3rd vector if needed
molecule.cpp:  // create quaternion
molecule.cpp:  // compute displacements in body frame defined by quat
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  // skip 1st line of file
molecule.cpp:  // read header lines
molecule.cpp:  // skip blank lines or lines that start with "#"
molecule.cpp:  // stop when read an unrecognized line
molecule.cpp:    // trim anything from '#' onward
molecule.cpp:    // if line is blank, continue
molecule.cpp:    // search line for header keywords and set corresponding variable
molecule.cpp:  // error checks
molecule.cpp:  // count = vector for tallying bonds,angles,etc per atom
molecule.cpp:  // grab keyword and skip next line
molecule.cpp:  // loop over sections of molecule file
molecule.cpp:  // clean up
molecule.cpp:  // error check
molecule.cpp:  // auto-generate special bonds if needed and not in file
molecule.cpp:  // set maxspecial on first pass, so allocate() has a size
molecule.cpp:  // body particle must have natom = 1
molecule.cpp:  // set radius by having body class compute its own radius
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:   if flag = 0, just count bonds/atom
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  // bond_per_atom = max of count vector
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:   if flag = 0, just count angles/atom
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  // angle_per_atom = max of count vector
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:   if flag = 0, just count dihedrals/atom
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  // dihedral_per_atom = max of count vector
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:   if flag = 0, just count impropers/atom
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  // improper_per_atom = max of count vector
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  // 1-2 neighbors
molecule.cpp:  // 1-3 neighbors with no duplicates
molecule.cpp:  // 1-4 neighbors with no duplicates
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:   pflag = 0/1 for integer/double params
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:    // check per-atom attributes of molecule
molecule.cpp:    // warn if not a match
molecule.cpp:    // for all atom styles, check nbondtype,etc
molecule.cpp:    // for molecular atom styles, check bond_per_atom,etc + maxspecial
molecule.cpp:    // do not check for atom style template, since nothing stored per atom
molecule.cpp:        error->all(FLERR,"Molecule topology/atom exceeds system topology/atom");
molecule.cpp:    // warn if molecule topology defined but no special settings
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:  // always allocate num_bond,num_angle,etc and special+nspecial
molecule.cpp:  // even if not in molecule file, initialize to 0
molecule.cpp:  // this is so methods that use these arrays don't have to check they exist
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:    // read upto non-blank line plus 1 following line
molecule.cpp:    // eof is set to 1 if any read hits end-of-file
molecule.cpp:    // if eof, set keyword empty and return
molecule.cpp:    // bcast keyword line to all procs
molecule.cpp:  // copy non-whitespace portion of line into keyword
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/* ----------------------------------------------------------------------
molecule.cpp:------------------------------------------------------------------------- */
molecule.cpp:/*
molecule.cpp:*/
nbin.cpp:/* ----------------------------------------------------------------------
nbin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nbin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nbin.cpp:------------------------------------------------------------------------- */
nbin.cpp:/* ---------------------------------------------------------------------- */
nbin.cpp:  // geometry settings
nbin.cpp:/* ---------------------------------------------------------------------- */
nbin.cpp:/* ---------------------------------------------------------------------- */
nbin.cpp:/* ----------------------------------------------------------------------
nbin.cpp:------------------------------------------------------------------------- */
nbin.cpp:  // overwrite Neighbor cutoff with custom value set by requestor
nbin.cpp:  // only works for style = BIN (checked by Neighbor class)
nbin.cpp:/* ----------------------------------------------------------------------
nbin.cpp:------------------------------------------------------------------------- */
nbin.cpp:  // binhead = per-bin vector, mbins in length
nbin.cpp:  // add 1 bin for USER-INTEL package
nbin.cpp:  // bins = per-atom vector
nbin.cpp:/* ----------------------------------------------------------------------
nbin.cpp:     take special care to insure ghosts are in correct bins even w/ roundoff
nbin.cpp:------------------------------------------------------------------------- */
nbin.cpp:/* ---------------------------------------------------------------------- */
nbin_standard.cpp:/* ----------------------------------------------------------------------
nbin_standard.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nbin_standard.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nbin_standard.cpp:------------------------------------------------------------------------- */
nbin_standard.cpp:enum{NSQ,BIN,MULTI};       // also in Neighbor
nbin_standard.cpp:/* ---------------------------------------------------------------------- */
nbin_standard.cpp:/* ----------------------------------------------------------------------
nbin_standard.cpp:     binsize = 1/2 of cutoff is roughly optimal
nbin_standard.cpp:------------------------------------------------------------------------- */
nbin_standard.cpp:  // bbox = size of bbox of entire domain
nbin_standard.cpp:  // bsubbox lo/hi = bounding box of my subdomain extended by comm->cutghost
nbin_standard.cpp:  // for triclinic:
nbin_standard.cpp:  //   bbox bounds all 8 corners of tilted box
nbin_standard.cpp:  //   subdomain is in lamda coords
nbin_standard.cpp:  //   include dimension-dependent extension via comm->cutghost
nbin_standard.cpp:  //   domain->bbox() converts lamda extent to box coords and computes bbox
nbin_standard.cpp:  // optimal bin size is roughly 1/2 the cutoff
nbin_standard.cpp:  // for BIN style, binsize = 1/2 of max neighbor cutoff
nbin_standard.cpp:  // for MULTI style, binsize = 1/2 of min neighbor cutoff
nbin_standard.cpp:  // special case of all cutoffs = 0.0, binsize = box size
nbin_standard.cpp:  double binsizeinv = 1.0/binsize_optimal;
nbin_standard.cpp:  // test for too many global bins in any dimension due to huge global domain
nbin_standard.cpp:  // create actual bins
nbin_standard.cpp:  // always have one bin even if cutoff > bbox
nbin_standard.cpp:  // for 2d, nbinz = 1
nbin_standard.cpp:  // compute actual bin size for nbins to fit into box exactly
nbin_standard.cpp:  // error if actual bin size << cutoff, since will create a zillion bins
nbin_standard.cpp:  // this happens when nbin = 1 and box size << cutoff
nbin_standard.cpp:  // typically due to non-periodic, flat system in a particular dim
nbin_standard.cpp:  // in that extreme case, should use NSQ not BIN neighbor style
nbin_standard.cpp:  binsizex = bbox[0]/nbinx;
nbin_standard.cpp:  binsizey = bbox[1]/nbiny;
nbin_standard.cpp:  binsizez = bbox[2]/nbinz;
nbin_standard.cpp:  bininvx = 1.0 / binsizex;
nbin_standard.cpp:  bininvy = 1.0 / binsizey;
nbin_standard.cpp:  bininvz = 1.0 / binsizez;
nbin_standard.cpp:  // mbinlo/hi = lowest and highest global bins my ghost atoms could be in
nbin_standard.cpp:  // coord = lowest and highest values of coords for my ghost atoms
nbin_standard.cpp:  // static_cast(-1.5) = -1, so subract additional -1
nbin_standard.cpp:  // add in SMALL for round-off safety
nbin_standard.cpp:  // extend bins by 1 to insure stencil extent is included
nbin_standard.cpp:  // for 2d, only 1 bin in z
nbin_standard.cpp:/* ----------------------------------------------------------------------
nbin_standard.cpp:------------------------------------------------------------------------- */
nbin_standard.cpp:  // bin in reverse order so linked list will be in forward order
nbin_standard.cpp:  // also puts ghost atoms at end of list, which is necessary
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
neighbor.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:enum{NSQ,BIN,MULTI};     // also in NBin, NeighList, NStencil
neighbor.cpp://#define NEIGH_LIST_DEBUG 1
neighbor.cpp:/* ---------------------------------------------------------------------- */
neighbor.cpp:  // pairwise neighbor lists and associated data structs
neighbor.cpp:  // topology lists
neighbor.cpp:  // coords at last neighboring
neighbor.cpp:  // pair exclusion list info
neighbor.cpp:  // Kokkos setting
neighbor.cpp:/* ---------------------------------------------------------------------- */
neighbor.cpp:/* ---------------------------------------------------------------------- */
neighbor.cpp:  // error check
neighbor.cpp:  // ------------------------------------------------------------------
neighbor.cpp:  // settings
neighbor.cpp:  // bbox lo/hi ptrs = bounding box of entire domain, stored by Domain
neighbor.cpp:  // set neighbor cutoffs (force cutoff + skin)
neighbor.cpp:  // trigger determines when atoms migrate and neighbor lists are rebuilt
neighbor.cpp:  //   needs to be non-zero for migration distance check
neighbor.cpp:  //   even if pair = NULL and no neighbor lists are used
neighbor.cpp:  // cutneigh = force cutoff + skin if cutforce > 0, else cutneigh = 0
neighbor.cpp:  // cutneighghost = pair cutghost if it requests it, else same as cutneigh
neighbor.cpp:  // rRESPA cutoffs
neighbor.cpp:  // fixchecklist = other classes that can induce reneighboring in decide()
neighbor.cpp:  // set special_flag for 1-2, 1-3, 1-4 neighbors
neighbor.cpp:  // flag[0] is not used, flag[1] = 1-2, flag[2] = 1-3, flag[3] = 1-4
neighbor.cpp:  // flag = 0 if both LJ/Coulomb special values are 0.0
neighbor.cpp:  // flag = 1 if both LJ/Coulomb special values are 1.0
neighbor.cpp:  // flag = 2 otherwise or if KSpace solver is enabled
neighbor.cpp:  // pairwise portion of KSpace solver uses all 1-2,1-3,1-4 neighbors
neighbor.cpp:  // or selected Coulomb-approixmation pair styles require it
neighbor.cpp:  if (force->kspace || force->pair_match("coul/wolf",0) ||
neighbor.cpp:      force->pair_match("coul/dsf",0) || force->pair_match("thole",0))
neighbor.cpp:  // maxwt = max multiplicative factor on atom indices stored in neigh list
neighbor.cpp:  // ------------------------------------------------------------------
neighbor.cpp:  // xhold array
neighbor.cpp:  // free if not needed for this run
neighbor.cpp:  // first time allocation
neighbor.cpp:  // ------------------------------------------------------------------
neighbor.cpp:  // exclusion lists
neighbor.cpp:  // depend on type, group, molecule settings from neigh_modify
neighbor.cpp:  // warn if exclusions used with KSpace solver
neighbor.cpp:  // ------------------------------------------------------------------
neighbor.cpp:  // create pairwise lists
neighbor.cpp:  // one-time call to init_styles() to scan style files and setup
neighbor.cpp:  // init_pair() creates auxiliary classes: NBin, NStencil, NPair
neighbor.cpp:  // invoke copy_neighbor_info() in Bin,Stencil,Pair classes
neighbor.cpp:  // copied once per run in case any cutoff, exclusion, special info changed
neighbor.cpp:  // can now delete requests so next run can make new ones
neighbor.cpp:  // print_pairwise_info() made use of requests
neighbor.cpp:  // set of NeighLists now stores all needed info
neighbor.cpp:  // ------------------------------------------------------------------
neighbor.cpp:  // create topology lists
neighbor.cpp:  // instantiated topo styles can change from run to run
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:   cannot do this in constructor, b/c too early to instantiate classes
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // extract info from NBin classes listed in style_nbin.h
neighbor.cpp:  // extract info from NStencil classes listed in style_nstencil.h
neighbor.cpp:  // extract info from NPair classes listed in style_npair.h
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // test if pairwise lists need to be re-created
neighbor.cpp:  // no need to re-create if:
neighbor.cpp:  //   neigh style, triclinic, pgsize, oneatom have not changed
neighbor.cpp:  //   current requests = old requests
neighbor.cpp:  // so just return:
neighbor.cpp:  //   delete requests so next run can make new ones
neighbor.cpp:  //   current set of NeighLists already stores all needed info
neighbor.cpp:  // requests are compared via identical() before:
neighbor.cpp:  //   any requests are morphed using logic below
neighbor.cpp:  //   any requests are added below, e.g. as parents of pair hybrid skip lists
neighbor.cpp:  // copy them via requests_new2old() BEFORE any changes made to requests
neighbor.cpp:  //   necessary b/c morphs can change requestor settings (see comment below)
neighbor.cpp:  // delete old lists since creating new ones
neighbor.cpp:  // morph requests in various ways
neighbor.cpp:  // purpose is to avoid duplicate or inefficient builds
neighbor.cpp:  // may add new requests if a needed request to derive from does not exist
neighbor.cpp:  // methods:
neighbor.cpp:  //   (1) other = point history and rRESPA lists at their partner lists
neighbor.cpp:  //   (2) skip = create any new non-skip lists needed by pair hybrid skip lists
neighbor.cpp:  //   (3) granular = adjust parent and skip lists for granular onesided usage
neighbor.cpp:  //   (4) h/f = pair up any matching half/full lists
neighbor.cpp:  //   (5) copy = convert as many lists as possible to copy lists
neighbor.cpp:  // order of morph methods matters:
neighbor.cpp:  //   (1) before (2), b/c (2) needs to know history partner pairings
neighbor.cpp:  //   (2) after (1), b/c (2) may also need to create new history lists
neighbor.cpp:  //   (3) after (2), b/c it adjusts lists created by (2)
neighbor.cpp:  //   (4) after (2) and (3), 
neighbor.cpp:  //       b/c (2) may create new full lists, (3) may change them
neighbor.cpp:  //   (5) last, after all lists are finalized, so all possible copies found
neighbor.cpp:  morph_granular();     // this method can change flags set by requestor
neighbor.cpp:  // create new lists, one per request including added requests
neighbor.cpp:  // wait to allocate initial pages until copy lists are detected
neighbor.cpp:  // NOTE: can I allocate now, instead of down below?
neighbor.cpp:  // allocate new lists
neighbor.cpp:  // pass list ptr back to requestor (except for Command class)
neighbor.cpp:  // only for original requests, not ones added by Neighbor class
neighbor.cpp:  // invoke post_constructor() for all lists
neighbor.cpp:  // copies info from requests to lists, sets ptrs to related lists
neighbor.cpp:  // assign Bin,Stencil,Pair style to each list
neighbor.cpp:  // instantiate unique Bin,Stencil classes in neigh_bin & neigh_stencil vecs
neighbor.cpp:  // unique = only one of its style, or request unique flag set (custom cutoff)
neighbor.cpp:  // instantiate one Pair class per list in neigh_pair vec
neighbor.cpp:  // allocate initial pages for each list, except if copy flag set
neighbor.cpp:  // allocate dnum vector of zeroes if set
neighbor.cpp:  // first-time allocation of per-atom data for lists that are built and store
neighbor.cpp:  // lists that are not built: granhistory, respa inner/middle (no neigh_pair)
neighbor.cpp:  // lists that do not store: copy 
neighbor.cpp:  // use atom->nmax for both grow() args
neighbor.cpp:  //   i.e. grow first time to expanded size to avoid future reallocs
neighbor.cpp:  // also Kokkos list initialization
neighbor.cpp:  // plist = indices of perpetual NPair classes
neighbor.cpp:  //         perpetual = non-occasional, re-built at every reneighboring
neighbor.cpp:  // slist = indices of perpetual NStencil classes
neighbor.cpp:  //         perpetual = used by any perpetual NPair class
neighbor.cpp:  // reorder plist vector if necessary
neighbor.cpp:  // relevant for lists that are derived from a parent list:
neighbor.cpp:  //   half-full,copy,skip
neighbor.cpp:  // the child index must appear in plist after the parent index
neighbor.cpp:  // swap two indices within plist when dependency is mis-ordered
neighbor.cpp:  // start double loop check again whenever a swap is made
neighbor.cpp:  // done when entire double loop test results in no swaps
neighbor.cpp:        int tmp = plist[i];     // swap I,J indices
neighbor.cpp:  // debug output
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:    // if history, point this list and partner list at each other
neighbor.cpp:    // if respaouter, point all associated rRESPA lists at each other
neighbor.cpp:    // if cut flag set by requestor, set unique flag
neighbor.cpp:    // this forces Pair,Stencil,Bin styles to be instantiated separately
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:    // only processing skip lists
neighbor.cpp:    // these lists are created other ways, no need for skipping
neighbor.cpp:    // halffull list and its full parent may both skip,
neighbor.cpp:    //   but are checked to insure matching skip info
neighbor.cpp:    // check all other lists
neighbor.cpp:      // can only skip from a perpetual non-skip list
neighbor.cpp:      // both lists must be half, or both full
neighbor.cpp:      // both lists must be newton on, or both newton off
neighbor.cpp:      // IJ newton = 1 for newton on, 2 for newton off
neighbor.cpp:      // these flags must be same,
neighbor.cpp:      //   else 2 lists do not store same pairs
neighbor.cpp:      //   or their data structures are different
neighbor.cpp:      // this includes custom cutoff set by requestor
neighbor.cpp:      // no need to check respaouter b/c it stores same pairs
neighbor.cpp:      // no need to check dnum b/c only set for history
neighbor.cpp:      // NOTE: need check for 2 Kokkos flags?
neighbor.cpp:      // 2 lists are a match
neighbor.cpp:    // if matching list exists, point to it
neighbor.cpp:    // else create a new identical list except non-skip
neighbor.cpp:    // for new list, set neigh = 1, skip = 0, no skip vec/array,
neighbor.cpp:    //   copy unique flag (since copy_request() will not do it)
neighbor.cpp:    // note: parents of skip lists do not have associated history list
neighbor.cpp:    //   b/c child skip lists store their own history info
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:   adjust newton/oneside parent settings if children require onesided skipping
neighbor.cpp:   this is needed because line/gran and tri/gran pair styles
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:    // only examine NeighRequests added by morph_skip()
neighbor.cpp:    // only those with size attribute for granular systems
neighbor.cpp:    // check children of this list
neighbor.cpp:      // only consider JRQ pair, size lists that skip from Irq list
neighbor.cpp:      // onesided = -1 if no children
neighbor.cpp:      // onesided = 0/1 = child granonesided value if same for all children
neighbor.cpp:      // onesided = 2 if children have different granonesided values
neighbor.cpp:    // if onesided = 2, parent has children with both granonesided = 0/1
neighbor.cpp:    // force parent newton off (newton = 2) to enable onesided skip by child
neighbor.cpp:    // set parent granonesided = 0, so it stores all neighs in usual manner
neighbor.cpp:    // set off2on = 1 for all children, since they expect newton on lists
neighbor.cpp:    //   this is b/c granonesided only set by line/gran and tri/gran which
neighbor.cpp:    //   both require system newton on
neighbor.cpp:        // only consider JRQ pair, size lists that skip from Irq list
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:    // only processing half lists
neighbor.cpp:    // Kokkos doesn't yet support half from full
neighbor.cpp:    // these lists are created other ways, no need for halffull
neighbor.cpp:    // do want to process skip lists
neighbor.cpp:    // check all other lists
neighbor.cpp:      // can only derive from a perpetual full list
neighbor.cpp:      // newton setting of derived list does not matter
neighbor.cpp:      // these flags must be same,
neighbor.cpp:      //   else 2 lists do not store same pairs
neighbor.cpp:      //   or their data structures are different
neighbor.cpp:      // this includes custom cutoff set by requestor
neighbor.cpp:      // no need to check respaouter b/c it stores same pairs
neighbor.cpp:      // no need to check dnum b/c only set for history
neighbor.cpp:      // skip flag must be same
neighbor.cpp:      // if both are skip lists, skip info must match
neighbor.cpp:      // 2 lists are a match
neighbor.cpp:    // if matching list exists, point to it
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:    // this list is already a copy list due to another morph method
neighbor.cpp:    // these lists are created other ways, no need to copy
neighbor.cpp:    // skip lists are eligible to become a copy list
neighbor.cpp:    // check all other lists
neighbor.cpp:      // other list is already copied from this one
neighbor.cpp:      // other list (jrq) to copy from must be perpetual
neighbor.cpp:      // list that becomes a copy list (irq) can be perpetual or occasional
neighbor.cpp:      // if both lists are perpetual, require j < i
neighbor.cpp:      //   to prevent circular dependence with 3 or more copies of a list
neighbor.cpp:      // both lists must be half, or both full
neighbor.cpp:      // both lists must be newton on, or both newton off
neighbor.cpp:      // IJ newton = 1 for newton on, 2 for newton off
neighbor.cpp:      // ok for non-ghost list to copy from ghost list, but not vice versa
neighbor.cpp:      // these flags must be same,
neighbor.cpp:      //   else 2 lists do not store same pairs
neighbor.cpp:      //   or their data structures are different
neighbor.cpp:      // this includes custom cutoff set by requestor
neighbor.cpp:      // no need to check respaouter b/c it stores same pairs
neighbor.cpp:      // no need to check omp b/c it stores same pairs
neighbor.cpp:      // no need to check dnum b/c only set for history
neighbor.cpp:      // NOTE: need check for 2 Kokkos flags?
neighbor.cpp:      // skip flag must be same
neighbor.cpp:      // if both are skip lists, skip info must match
neighbor.cpp:      // 2 lists are a match
neighbor.cpp:    // turn list I into a copy of list J
neighbor.cpp:    // do not copy a list from another copy list, but from its parent list
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // set flags that determine which topology neighbor classes to use
neighbor.cpp:  // these settings could change from run to run, depending on fixes defined
neighbor.cpp:  // bonds,etc can only be broken for atom->molecular = 1, not 2
neighbor.cpp:  // SHAKE sets bonds and angles negative
neighbor.cpp:  // gcmc sets all bonds, angles, etc negative
neighbor.cpp:  // bond_quartic sets bonds to 0
neighbor.cpp:  // delete_bonds sets all interactions negative
neighbor.cpp:  // sync on/off settings across all procs
neighbor.cpp:  // instantiate NTopo classes
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:      fprintf(out,"  max neighbors/atom: %d, page size: %d\n",
neighbor.cpp:                ceil(bbox[0]/binsize), ceil(bbox[1]/binsize),
neighbor.cpp:                ceil(bbox[2]/binsize));
neighbor.cpp:              "perpetual/occasional/extra = %d %d %d\n",
neighbor.cpp:        // order these to get single output of most relevant
neighbor.cpp:          fprintf(out,", half/full from (%d)",rq->halffulllist+1);
neighbor.cpp:        // list of neigh list attributes
neighbor.cpp:      /*
neighbor.cpp:      */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // no binning needed
neighbor.cpp:  // use request settings to match exactly one NBin class mask
neighbor.cpp:  // checks are bitwise using NeighConst bit masks
neighbor.cpp:    // require match of these request flags and mask bits
neighbor.cpp:    // (!A != !B) is effectively a logical xor
neighbor.cpp:  // error return if matched none
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // no stencil creation needed
neighbor.cpp:  // convert newton request to newtflag = on or off
neighbor.cpp:  //printf("STENCIL RQ FLAGS: hff %d %d n %d g %d s %d newtflag %d\n",
neighbor.cpp:  //       rq->half,rq->full,rq->newton,rq->ghost,rq->ssa,
neighbor.cpp:  //       newtflag);
neighbor.cpp:  // use request and system settings to match exactly one NStencil class mask
neighbor.cpp:  // checks are bitwise using NeighConst bit masks
neighbor.cpp:    //printf("III %d: half %d full %d newton %d newtoff %d ghost %d ssa %d\n",
neighbor.cpp:    //       i,mask & NS_HALF,mask & NS_FULL,mask & NS_NEWTON,
neighbor.cpp:    //       mask & NS_NEWTOFF,mask & NS_GHOST,mask & NS_SSA);
neighbor.cpp:    // exactly one of half or full is set and must match
neighbor.cpp:    // newtflag is on or off and must match
neighbor.cpp:    // require match of these request flags and mask bits 
neighbor.cpp:    // (!A != !B) is effectively a logical xor
neighbor.cpp:    // neighbor style is BIN or MULTI and must match
neighbor.cpp:    // dimension is 2 or 3 and must match
neighbor.cpp:    // domain triclinic flag is on or off and must match
neighbor.cpp:  // error return if matched none
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // no neighbor list build performed
neighbor.cpp:  // error check for includegroup with ghost neighbor request
neighbor.cpp:  // convert newton request to newtflag = on or off
neighbor.cpp:  //printf("PAIR RQ FLAGS: hf %d %d n %d g %d sz %d gos %d r %d b %d o %d i %d "
neighbor.cpp:  //       "kk %d %d ss %d dn %d sk %d cp %d hf %d oo %d\n",
neighbor.cpp:  //        rq->half,rq->full,rq->newton,rq->ghost,rq->size,
neighbor.cpp:  //        rq->granonesided,rq->respaouter,rq->bond,rq->omp,rq->intel,
neighbor.cpp:  //       rq->kokkos_host,rq->kokkos_device,rq->ssa,rq->dnum,
neighbor.cpp:  //      rq->skip,rq->copy,rq->halffull,rq->off2on);
neighbor.cpp:  // use request and system settings to match exactly one NPair class mask
neighbor.cpp:  // checks are bitwise using NeighConst bit masks
neighbor.cpp:    //printf("  PAIR NAMES i %d %d name %s mask %d\n",i,nrequest,
neighbor.cpp:    //       pairnames[i],pairmasks[i]);
neighbor.cpp:    // if copy request, no further checks needed, just return or continue
neighbor.cpp:    // Kokkos device/host flags must also match in order to copy
neighbor.cpp:    // exactly one of half or full is set and must match
neighbor.cpp:    // newtflag is on or off and must match
neighbor.cpp:    // if molecular on, do not match ATOMONLY (b/c a MOLONLY Npair exists)
neighbor.cpp:    // if molecular off, do not match MOLONLY (b/c an ATOMONLY Npair exists)
neighbor.cpp:    // require match of these request flags and mask bits 
neighbor.cpp:    // (!A != !B) is effectively a logical xor
neighbor.cpp:    // neighbor style is one of NSQ,BIN,MULTI and must match
neighbor.cpp:    // domain triclinic flag is on or off and must match
neighbor.cpp:  // error return if matched none
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:   called before run and every reneighbor if box size/shape changes
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // invoke setup_bins() for all NBin
neighbor.cpp:  // actual binning is performed in build()
neighbor.cpp:  // invoke create_setup() and create() for all perpetual NStencil
neighbor.cpp:  // same ops performed for occasional lists in build_one()
neighbor.cpp:/* ---------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:     new trigger = 1/2 of reduced skin distance
neighbor.cpp:   for orthogonal box, only need 2 lo/hi corners
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // check that using special bond flags will not overflow neigh lists
neighbor.cpp:  // store current atom positions and box size if needed
neighbor.cpp:  // bin atoms for all NBin instances
neighbor.cpp:  // not just NBin associated with perpetual lists
neighbor.cpp:  // b/c cannot wait to bin occasional lists in build_one() call
neighbor.cpp:  // if bin then, atoms may have moved outside of proc domain & bin extent,
neighbor.cpp:  //   leading to errors or even a crash
neighbor.cpp:  // build pairwise lists for all perpetual NPair/NeighList
neighbor.cpp:  // grow() with nlocal/nall args so that only realloc if have to
neighbor.cpp:  // build topology lists for bonds/angles/etc
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:   copy their list info back to Neighbor for access by bond/angle/etc classes
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:  // check if list structure is initialized
neighbor.cpp:  // build_one() should never be invoked on a perpetual list
neighbor.cpp:  // no need to build if already built since last re-neighbor
neighbor.cpp:  // preflag is set by fix bond/create and fix bond/swap
neighbor.cpp:  //   b/c they invoke build_one() on same step neigh list is re-built,
neighbor.cpp:  //   but before re-build, so need to use ">" instead of ">="
neighbor.cpp:  // if this is copy list and parent is occasional list,
neighbor.cpp:  // or this is halffull and parent is occasional list,
neighbor.cpp:  // insure parent is current 
neighbor.cpp:  // create stencil if hasn't been created since last setup_bins() call
neighbor.cpp:  // build the list
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:      } else if (strcmp(arg[iarg+1],"molecule/inter") == 0 ||
neighbor.cpp:		 strcmp(arg[iarg+1],"molecule/intra") == 0) {
neighbor.cpp:	if (strcmp(arg[iarg+1],"molecule/intra") == 0)
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neighbor.cpp:/* ----------------------------------------------------------------------
neighbor.cpp:------------------------------------------------------------------------- */
neigh_list.cpp:/* ----------------------------------------------------------------------
neigh_list.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
neigh_list.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
neigh_list.cpp:------------------------------------------------------------------------- */
neigh_list.cpp:enum{NSQ,BIN,MULTI};     // also in Neighbor
neigh_list.cpp:/* ---------------------------------------------------------------------- */
neigh_list.cpp:  // initializations
neigh_list.cpp:  // defaults, but may be reset by post_constructor()
neigh_list.cpp:  // ptrs
neigh_list.cpp:  // Kokkos package
neigh_list.cpp:  // USER-DPD package
neigh_list.cpp:/* ---------------------------------------------------------------------- */
neigh_list.cpp:/* ----------------------------------------------------------------------
neigh_list.cpp:   cannot do this in constructor b/c not all NeighLists are allocated yet
neigh_list.cpp:   respaouter -> set listinner/listmiddle for other rRESPA lists
neigh_list.cpp:------------------------------------------------------------------------- */
neigh_list.cpp:  // copy request settings used by list itself
neigh_list.cpp:/* ---------------------------------------------------------------------- */
neigh_list.cpp:/* ----------------------------------------------------------------------
neigh_list.cpp:   grow per-atom data to allow for nlocal/nall atoms
neigh_list.cpp:------------------------------------------------------------------------- */
neigh_list.cpp:  // trigger grow() in children before possible return
neigh_list.cpp:  // skip if data structs are already big enough
neigh_list.cpp:/* ----------------------------------------------------------------------
neigh_list.cpp:------------------------------------------------------------------------- */
neigh_list.cpp:  printf("Neighbor list/request %d:\n",index);
neigh_list.cpp:  printf("  %d = half/full\n",rq->halffull);
neigh_list.cpp:  printf("  %d = history/partner\n",rq->history_partner);
neigh_list.cpp:/* ----------------------------------------------------------------------
neigh_list.cpp:------------------------------------------------------------------------- */
neigh_request.cpp:/* ----------------------------------------------------------------------
neigh_request.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
neigh_request.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
neigh_request.cpp:------------------------------------------------------------------------- */
neigh_request.cpp:/* ---------------------------------------------------------------------- */
neigh_request.cpp:  // default ID = 0
neigh_request.cpp:  // class user of list: default is pair request
neigh_request.cpp:  // only one is set to 1
neigh_request.cpp:  // kind of list: default is half neighbor list
neigh_request.cpp:  // only one is set to 1
neigh_request.cpp:  // attribute flags, mutiple can be set to 1
neigh_request.cpp:  // default is every reneighboring, not occasional
neigh_request.cpp:  // default is use newton_pair setting in force
neigh_request.cpp:  // default is no neighbors of ghosts
neigh_request.cpp:  // default is use cutoffs, not size of particles
neigh_request.cpp:  // default is no additional neighbor history info
neigh_request.cpp:  // default is no one-sided sphere/surface interactions (when size = 1)
neigh_request.cpp:  // default is neighbors of atoms, not bonds
neigh_request.cpp:  // default is no multilevel rRESPA neighbors
neigh_request.cpp:  // default is no OpenMP multi-threaded neighbor list build
neigh_request.cpp:  // default is no Intel-specific neighbor list build
neigh_request.cpp:  // default is no Kokkos neighbor list build
neigh_request.cpp:  // default is no Shardlow Splitting Algorithm (SSA) neighbor list build
neigh_request.cpp:  // default is no storage of auxiliary floating point values
neigh_request.cpp:  // skip info, default is no skipping
neigh_request.cpp:  // only set when command = 1;
neigh_request.cpp:  // info set by Neighbor class when morphing original requests
neigh_request.cpp:  // internal settings
neigh_request.cpp:/* ---------------------------------------------------------------------- */
neigh_request.cpp:/* ----------------------------------------------------------------------
neigh_request.cpp:------------------------------------------------------------------------- */
neigh_request.cpp:  // check for match of requestor_instance and instance counter
neigh_request.cpp:  // prevents an old fix from being unfix/refix in same memory location
neigh_request.cpp:  //   stored in requestor, and thus appearing old, when really new
neigh_request.cpp:  // only needed for classes with persistent neigh lists: Pair, Fix, Compute
neigh_request.cpp:  // only compare settings made by requestors
neigh_request.cpp:  // not settings made later by Neighbor class
neigh_request.cpp:/* ----------------------------------------------------------------------
neigh_request.cpp:------------------------------------------------------------------------- */
neigh_request.cpp:/* ----------------------------------------------------------------------
neigh_request.cpp:   skipflag = 1 to copy skip vector/array
neigh_request.cpp:------------------------------------------------------------------------- */
npair_copy.cpp:/* ----------------------------------------------------------------------
npair_copy.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_copy.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_copy.cpp:------------------------------------------------------------------------- */
npair_copy.cpp:/* ---------------------------------------------------------------------- */
npair_copy.cpp:/* ----------------------------------------------------------------------
npair_copy.cpp:------------------------------------------------------------------------- */
npair.cpp:/* ----------------------------------------------------------------------
npair.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair.cpp:------------------------------------------------------------------------- */
npair.cpp:/* ---------------------------------------------------------------------- */
npair.cpp:/* ---------------------------------------------------------------------- */
npair.cpp:/* ---------------------------------------------------------------------- */
npair.cpp:/* ----------------------------------------------------------------------
npair.cpp:------------------------------------------------------------------------- */
npair.cpp:  // general params
npair.cpp:  // exclusion info
npair.cpp:  // special info
npair.cpp:  // overwrite per-type Neighbor cutoffs with custom value set by requestor
npair.cpp:  // only works for style = BIN (checked by Neighbor class)
npair.cpp:/* ----------------------------------------------------------------------
npair.cpp:------------------------------------------------------------------------- */
npair.cpp:/* ----------------------------------------------------------------------
npair.cpp:------------------------------------------------------------------------- */
npair.cpp:/* ----------------------------------------------------------------------
npair.cpp:------------------------------------------------------------------------- */
npair.cpp:  // set here, since build_setup() always called before build()
npair.cpp:/* ----------------------------------------------------------------------
npair.cpp:------------------------------------------------------------------------- */
npair.cpp:      // intra-chain: exclude i-j pair if in same molecule 
npair.cpp:      // inter-chain: exclude i-j pair if in different molecules 
npair.cpp:/* ----------------------------------------------------------------------
npair.cpp:     take special care to insure ghosts are in correct bins even w/ roundoff
npair.cpp:------------------------------------------------------------------------- */
npair.cpp:/* ----------------------------------------------------------------------
npair.cpp:------------------------------------------------------------------------- */
npair_full_bin_atomonly.cpp:/* ----------------------------------------------------------------------
npair_full_bin_atomonly.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_full_bin_atomonly.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_full_bin_atomonly.cpp:------------------------------------------------------------------------- */
npair_full_bin_atomonly.cpp:/* ---------------------------------------------------------------------- */
npair_full_bin_atomonly.cpp:/* ----------------------------------------------------------------------
npair_full_bin_atomonly.cpp:------------------------------------------------------------------------- */
npair_full_bin_atomonly.cpp:    // loop over all atoms in surrounding bins in stencil including self
npair_full_bin_atomonly.cpp:    // skip i = j
npair_full_bin.cpp:/* ----------------------------------------------------------------------
npair_full_bin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_full_bin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_full_bin.cpp:------------------------------------------------------------------------- */
npair_full_bin.cpp:/* ---------------------------------------------------------------------- */
npair_full_bin.cpp:/* ----------------------------------------------------------------------
npair_full_bin.cpp:------------------------------------------------------------------------- */
npair_full_bin.cpp:    // loop over all atoms in surrounding bins in stencil including self
npair_full_bin.cpp:    // skip i = j
npair_full_bin_ghost.cpp:/* ----------------------------------------------------------------------
npair_full_bin_ghost.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_full_bin_ghost.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_full_bin_ghost.cpp:------------------------------------------------------------------------- */
npair_full_bin_ghost.cpp:/* ---------------------------------------------------------------------- */
npair_full_bin_ghost.cpp:/* ----------------------------------------------------------------------
npair_full_bin_ghost.cpp:------------------------------------------------------------------------- */
npair_full_bin_ghost.cpp:  // loop over owned & ghost atoms, storing neighbors
npair_full_bin_ghost.cpp:    // loop over all atoms in surrounding bins in stencil including self
npair_full_bin_ghost.cpp:    // when i is a ghost atom, must check if stencil bin is out of bounds
npair_full_bin_ghost.cpp:    // skip i = j
npair_full_bin_ghost.cpp:    // no molecular test when i = ghost atom
npair_full_multi.cpp:/* ----------------------------------------------------------------------
npair_full_multi.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_full_multi.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_full_multi.cpp:------------------------------------------------------------------------- */
npair_full_multi.cpp:/* ---------------------------------------------------------------------- */
npair_full_multi.cpp:/* ----------------------------------------------------------------------
npair_full_multi.cpp:------------------------------------------------------------------------- */
npair_full_multi.cpp:    // loop over all atoms in other bins in stencil, including self
npair_full_multi.cpp:    // skip if i,j neighbor cutoff is less than bin distance
npair_full_multi.cpp:    // skip i = j
npair_full_nsq.cpp:/* ----------------------------------------------------------------------
npair_full_nsq.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_full_nsq.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_full_nsq.cpp:------------------------------------------------------------------------- */
npair_full_nsq.cpp:/* ---------------------------------------------------------------------- */
npair_full_nsq.cpp:/* ----------------------------------------------------------------------
npair_full_nsq.cpp:------------------------------------------------------------------------- */
npair_full_nsq.cpp:    // loop over all atoms, owned and ghost
npair_full_nsq.cpp:    // skip i = j
npair_full_nsq_ghost.cpp:/* ----------------------------------------------------------------------
npair_full_nsq_ghost.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_full_nsq_ghost.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_full_nsq_ghost.cpp:------------------------------------------------------------------------- */
npair_full_nsq_ghost.cpp:/* ---------------------------------------------------------------------- */
npair_full_nsq_ghost.cpp:/* ----------------------------------------------------------------------
npair_full_nsq_ghost.cpp:------------------------------------------------------------------------- */
npair_full_nsq_ghost.cpp:  // loop over owned & ghost atoms, storing neighbors
npair_full_nsq_ghost.cpp:    // loop over all atoms, owned and ghost
npair_full_nsq_ghost.cpp:    // skip i = j
npair_full_nsq_ghost.cpp:    // no molecular test when i = ghost atom
npair_half_bin_atomonly_newton.cpp:/* ----------------------------------------------------------------------
npair_half_bin_atomonly_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_bin_atomonly_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_bin_atomonly_newton.cpp:------------------------------------------------------------------------- */
npair_half_bin_atomonly_newton.cpp:/* ---------------------------------------------------------------------- */
npair_half_bin_atomonly_newton.cpp:/* ----------------------------------------------------------------------
npair_half_bin_atomonly_newton.cpp:------------------------------------------------------------------------- */
npair_half_bin_atomonly_newton.cpp:    // loop over rest of atoms in i's bin, ghosts are at end of linked list
npair_half_bin_atomonly_newton.cpp:    // if j is owned atom, store it, since j is beyond i in linked list
npair_half_bin_atomonly_newton.cpp:    // if j is ghost, only store if j coords are "above and to the right" of i
npair_half_bin_atomonly_newton.cpp:    // loop over all atoms in other bins in stencil, store every pair
npair_half_bin_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_bin_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_bin_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_bin_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_bin_newtoff.cpp:/* ---------------------------------------------------------------------- */
npair_half_bin_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_bin_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_bin_newtoff.cpp:    // loop over all atoms in other bins in stencil including self
npair_half_bin_newtoff.cpp:    // only store pair if i < j
npair_half_bin_newtoff.cpp:    // stores own/own pairs only once
npair_half_bin_newtoff.cpp:    // stores own/ghost pairs on both procs
npair_half_bin_newtoff.cpp:            // OLD: if (which >= 0) neighptr[n++] = j ^ (which << SBBITS);
npair_half_bin_newtoff_ghost.cpp:/* ----------------------------------------------------------------------
npair_half_bin_newtoff_ghost.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_bin_newtoff_ghost.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_bin_newtoff_ghost.cpp:------------------------------------------------------------------------- */
npair_half_bin_newtoff_ghost.cpp:/* ---------------------------------------------------------------------- */
npair_half_bin_newtoff_ghost.cpp:/* ----------------------------------------------------------------------
npair_half_bin_newtoff_ghost.cpp:------------------------------------------------------------------------- */
npair_half_bin_newtoff_ghost.cpp:    // loop over all atoms in other bins in stencil including self
npair_half_bin_newtoff_ghost.cpp:    // when i is a ghost atom, must check if stencil bin is out of bounds
npair_half_bin_newtoff_ghost.cpp:    // only store pair if i < j
npair_half_bin_newtoff_ghost.cpp:    // stores own/own pairs only once
npair_half_bin_newtoff_ghost.cpp:    // stores own/ghost pairs with owned atom only, on both procs
npair_half_bin_newtoff_ghost.cpp:    // stores ghost/ghost pairs only once
npair_half_bin_newtoff_ghost.cpp:    // no molecular test when i = ghost atom
npair_half_bin_newton.cpp:/* ----------------------------------------------------------------------
npair_half_bin_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_bin_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_bin_newton.cpp:------------------------------------------------------------------------- */
npair_half_bin_newton.cpp:/* ---------------------------------------------------------------------- */
npair_half_bin_newton.cpp:/* ----------------------------------------------------------------------
npair_half_bin_newton.cpp:------------------------------------------------------------------------- */
npair_half_bin_newton.cpp:    // loop over rest of atoms in i's bin, ghosts are at end of linked list
npair_half_bin_newton.cpp:    // if j is owned atom, store it, since j is beyond i in linked list
npair_half_bin_newton.cpp:    // if j is ghost, only store if j coords are "above and to the right" of i
npair_half_bin_newton.cpp:          // OLD: if (which >= 0) neighptr[n++] = j ^ (which << SBBITS);
npair_half_bin_newton.cpp:    // loop over all atoms in other bins in stencil, store every pair
npair_half_bin_newton.cpp:            // OLD: if (which >= 0) neighptr[n++] = j ^ (which << SBBITS);
npair_half_bin_newton_tri.cpp:/* ----------------------------------------------------------------------
npair_half_bin_newton_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_bin_newton_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_bin_newton_tri.cpp:------------------------------------------------------------------------- */
npair_half_bin_newton_tri.cpp:/* ---------------------------------------------------------------------- */
npair_half_bin_newton_tri.cpp:/* ----------------------------------------------------------------------
npair_half_bin_newton_tri.cpp:------------------------------------------------------------------------- */
npair_half_bin_newton_tri.cpp:    // loop over all atoms in bins in stencil
npair_half_bin_newton_tri.cpp:    // pairs for atoms j "below" i are excluded
npair_half_bin_newton_tri.cpp:    // below = lower z or (equal z and lower y) or (equal zy and lower x)
npair_half_bin_newton_tri.cpp:    //         (equal zyx and j <= i)
npair_half_bin_newton_tri.cpp:    // latter excludes self-self interaction but allows superposed atoms
npair_halffull_newtoff.cpp:/* ----------------------------------------------------------------------
npair_halffull_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_halffull_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_halffull_newtoff.cpp:------------------------------------------------------------------------- */
npair_halffull_newtoff.cpp:/* ---------------------------------------------------------------------- */
npair_halffull_newtoff.cpp:/* ----------------------------------------------------------------------
npair_halffull_newtoff.cpp:------------------------------------------------------------------------- */
npair_halffull_newtoff.cpp:  // loop over atoms in full list
npair_halffull_newtoff.cpp:    // loop over parent full list
npair_halffull_newton.cpp:/* ----------------------------------------------------------------------
npair_halffull_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_halffull_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_halffull_newton.cpp:------------------------------------------------------------------------- */
npair_halffull_newton.cpp:/* ---------------------------------------------------------------------- */
npair_halffull_newton.cpp:/* ----------------------------------------------------------------------
npair_halffull_newton.cpp:------------------------------------------------------------------------- */
npair_halffull_newton.cpp:  // loop over parent full list
npair_halffull_newton.cpp:    // loop over full neighbor list
npair_half_multi_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_multi_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_multi_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_multi_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_multi_newtoff.cpp:/* ---------------------------------------------------------------------- */
npair_half_multi_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_multi_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_multi_newtoff.cpp:    // loop over all atoms in other bins in stencil including self
npair_half_multi_newtoff.cpp:    // only store pair if i < j
npair_half_multi_newtoff.cpp:    // skip if i,j neighbor cutoff is less than bin distance
npair_half_multi_newtoff.cpp:    // stores own/own pairs only once
npair_half_multi_newtoff.cpp:    // stores own/ghost pairs on both procs
npair_half_multi_newton.cpp:/* ----------------------------------------------------------------------
npair_half_multi_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_multi_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_multi_newton.cpp:------------------------------------------------------------------------- */
npair_half_multi_newton.cpp:/* ---------------------------------------------------------------------- */
npair_half_multi_newton.cpp:/* ----------------------------------------------------------------------
npair_half_multi_newton.cpp:------------------------------------------------------------------------- */
npair_half_multi_newton.cpp:    // loop over rest of atoms in i's bin, ghosts are at end of linked list
npair_half_multi_newton.cpp:    // if j is owned atom, store it, since j is beyond i in linked list
npair_half_multi_newton.cpp:    // if j is ghost, only store if j coords are "above and to the right" of i
npair_half_multi_newton.cpp:    // loop over all atoms in other bins in stencil, store every pair
npair_half_multi_newton.cpp:    // skip if i,j neighbor cutoff is less than bin distance
npair_half_multi_newton_tri.cpp:/* ----------------------------------------------------------------------
npair_half_multi_newton_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_multi_newton_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_multi_newton_tri.cpp:------------------------------------------------------------------------- */
npair_half_multi_newton_tri.cpp:/* ---------------------------------------------------------------------- */
npair_half_multi_newton_tri.cpp:/* ----------------------------------------------------------------------
npair_half_multi_newton_tri.cpp:------------------------------------------------------------------------- */
npair_half_multi_newton_tri.cpp:    // loop over all atoms in bins, including self, in stencil
npair_half_multi_newton_tri.cpp:    // skip if i,j neighbor cutoff is less than bin distance
npair_half_multi_newton_tri.cpp:    // bins below self are excluded from stencil
npair_half_multi_newton_tri.cpp:    // pairs for atoms j "below" i are excluded
npair_half_multi_newton_tri.cpp:    // below = lower z or (equal z and lower y) or (equal zy and lower x)
npair_half_multi_newton_tri.cpp:    //         (equal zyx and j <= i)
npair_half_multi_newton_tri.cpp:    // latter excludes self-self interaction but allows superposed atoms
npair_half_nsq_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_nsq_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_nsq_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_nsq_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_nsq_newtoff.cpp:/* ---------------------------------------------------------------------- */
npair_half_nsq_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_nsq_newtoff.cpp:   N^2 / 2 search for neighbor pairs with partial Newton's 3rd law
npair_half_nsq_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_nsq_newtoff.cpp:    // loop over remaining atoms, owned and ghost
npair_half_nsq_newtoff.cpp:    // only store pair if i < j
npair_half_nsq_newtoff_ghost.cpp:/* ----------------------------------------------------------------------
npair_half_nsq_newtoff_ghost.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_nsq_newtoff_ghost.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_nsq_newtoff_ghost.cpp:------------------------------------------------------------------------- */
npair_half_nsq_newtoff_ghost.cpp:/* ---------------------------------------------------------------------- */
npair_half_nsq_newtoff_ghost.cpp:/* ----------------------------------------------------------------------
npair_half_nsq_newtoff_ghost.cpp:   N^2 / 2 search for neighbor pairs with partial Newton's 3rd law
npair_half_nsq_newtoff_ghost.cpp:------------------------------------------------------------------------- */
npair_half_nsq_newtoff_ghost.cpp:  // loop over owned & ghost atoms, storing neighbors
npair_half_nsq_newtoff_ghost.cpp:    // loop over remaining atoms, owned and ghost
npair_half_nsq_newtoff_ghost.cpp:    // only store pair if i < j
npair_half_nsq_newtoff_ghost.cpp:    // stores own/own pairs only once
npair_half_nsq_newtoff_ghost.cpp:    // stores own/ghost pairs with owned atom only, on both procs
npair_half_nsq_newtoff_ghost.cpp:    // stores ghost/ghost pairs only once
npair_half_nsq_newtoff_ghost.cpp:    // no molecular test when i = ghost atom
npair_half_nsq_newton.cpp:/* ----------------------------------------------------------------------
npair_half_nsq_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_nsq_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_nsq_newton.cpp:------------------------------------------------------------------------- */
npair_half_nsq_newton.cpp:/* ---------------------------------------------------------------------- */
npair_half_nsq_newton.cpp:/* ----------------------------------------------------------------------
npair_half_nsq_newton.cpp:   N^2 / 2 search for neighbor pairs with full Newton's 3rd law
npair_half_nsq_newton.cpp:------------------------------------------------------------------------- */
npair_half_nsq_newton.cpp:    // loop over remaining atoms, owned and ghost
npair_half_nsq_newton.cpp:    // itag = jtag is possible for long cutoffs that include images of self
npair_half_respa_bin_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_respa_bin_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_respa_bin_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_respa_bin_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_respa_bin_newtoff.cpp:/* ---------------------------------------------------------------------- */
npair_half_respa_bin_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_respa_bin_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_respa_bin_newtoff.cpp:    // loop over all atoms in surrounding bins in stencil including self
npair_half_respa_bin_newtoff.cpp:    // only store pair if i < j
npair_half_respa_bin_newtoff.cpp:    // stores own/own pairs only once
npair_half_respa_bin_newtoff.cpp:    // stores own/ghost pairs on both procs
npair_half_respa_bin_newton.cpp:/* ----------------------------------------------------------------------
npair_half_respa_bin_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_respa_bin_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_respa_bin_newton.cpp:------------------------------------------------------------------------- */
npair_half_respa_bin_newton.cpp:/* ---------------------------------------------------------------------- */
npair_half_respa_bin_newton.cpp:/* ----------------------------------------------------------------------
npair_half_respa_bin_newton.cpp:------------------------------------------------------------------------- */
npair_half_respa_bin_newton.cpp:    // loop over rest of atoms in i's bin, ghosts are at end of linked list
npair_half_respa_bin_newton.cpp:    // if j is owned atom, store it, since j is beyond i in linked list
npair_half_respa_bin_newton.cpp:    // if j is ghost, only store if j coords are "above and to the right" of i
npair_half_respa_bin_newton.cpp:    // loop over all atoms in other bins in stencil, store every pair
npair_half_respa_bin_newton_tri.cpp:/* ----------------------------------------------------------------------
npair_half_respa_bin_newton_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_respa_bin_newton_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_respa_bin_newton_tri.cpp:------------------------------------------------------------------------- */
npair_half_respa_bin_newton_tri.cpp:/* ---------------------------------------------------------------------- */
npair_half_respa_bin_newton_tri.cpp:/* ----------------------------------------------------------------------
npair_half_respa_bin_newton_tri.cpp:------------------------------------------------------------------------- */
npair_half_respa_bin_newton_tri.cpp:    // loop over all atoms in bins in stencil
npair_half_respa_bin_newton_tri.cpp:    // pairs for atoms j "below" i are excluded
npair_half_respa_bin_newton_tri.cpp:    // below = lower z or (equal z and lower y) or (equal zy and lower x)
npair_half_respa_bin_newton_tri.cpp:    //         (equal zyx and j <= i)
npair_half_respa_bin_newton_tri.cpp:    // latter excludes self-self interaction but allows superposed atoms
npair_half_respa_nsq_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_respa_nsq_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_respa_nsq_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_respa_nsq_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_respa_nsq_newtoff.cpp:/* ---------------------------------------------------------------------- */
npair_half_respa_nsq_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_respa_nsq_newtoff.cpp:   N^2 / 2 search for neighbor pairs with partial Newton's 3rd law
npair_half_respa_nsq_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_respa_nsq_newtoff.cpp:    // loop over remaining atoms, owned and ghost
npair_half_respa_nsq_newton.cpp:/* ----------------------------------------------------------------------
npair_half_respa_nsq_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_respa_nsq_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_respa_nsq_newton.cpp:------------------------------------------------------------------------- */
npair_half_respa_nsq_newton.cpp:/* ---------------------------------------------------------------------- */
npair_half_respa_nsq_newton.cpp:/* ----------------------------------------------------------------------
npair_half_respa_nsq_newton.cpp:   N^2 / 2 search for neighbor pairs with full Newton's 3rd law
npair_half_respa_nsq_newton.cpp:------------------------------------------------------------------------- */
npair_half_respa_nsq_newton.cpp:    // loop over remaining atoms, owned and ghost
npair_half_size_bin_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_size_bin_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_size_bin_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_size_bin_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_size_bin_newtoff.cpp:/* ---------------------------------------------------------------------- */
npair_half_size_bin_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_size_bin_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_size_bin_newtoff.cpp:    // loop over all atoms in surrounding bins in stencil including self
npair_half_size_bin_newtoff.cpp:    // only store pair if i < j
npair_half_size_bin_newtoff.cpp:    // stores own/own pairs only once
npair_half_size_bin_newtoff.cpp:    // stores own/ghost pairs on both procs
npair_half_size_bin_newton.cpp:/* ----------------------------------------------------------------------
npair_half_size_bin_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_size_bin_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_size_bin_newton.cpp:------------------------------------------------------------------------- */
npair_half_size_bin_newton.cpp:/* ---------------------------------------------------------------------- */
npair_half_size_bin_newton.cpp:/* ----------------------------------------------------------------------
npair_half_size_bin_newton.cpp:------------------------------------------------------------------------- */
npair_half_size_bin_newton.cpp:    // loop over rest of atoms in i's bin, ghosts are at end of linked list
npair_half_size_bin_newton.cpp:    // if j is owned atom, store it, since j is beyond i in linked list
npair_half_size_bin_newton.cpp:    // if j is ghost, only store if j coords are "above and to the right" of i
npair_half_size_bin_newton.cpp:    // loop over all atoms in other bins in stencil, store every pair
npair_half_size_bin_newton_tri.cpp:/* ----------------------------------------------------------------------
npair_half_size_bin_newton_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_size_bin_newton_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_size_bin_newton_tri.cpp:------------------------------------------------------------------------- */
npair_half_size_bin_newton_tri.cpp:/* ---------------------------------------------------------------------- */
npair_half_size_bin_newton_tri.cpp:/* ----------------------------------------------------------------------
npair_half_size_bin_newton_tri.cpp:------------------------------------------------------------------------- */
npair_half_size_bin_newton_tri.cpp:    // loop over all atoms in bins in stencil
npair_half_size_bin_newton_tri.cpp:    // pairs for atoms j "below" i are excluded
npair_half_size_bin_newton_tri.cpp:    // below = lower z or (equal z and lower y) or (equal zy and lower x)
npair_half_size_bin_newton_tri.cpp:    //         (equal zyx and j <= i)
npair_half_size_bin_newton_tri.cpp:    // latter excludes self-self interaction but allows superposed atoms
npair_half_size_nsq_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_size_nsq_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_size_nsq_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_size_nsq_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_size_nsq_newtoff.cpp:/* ---------------------------------------------------------------------- */
npair_half_size_nsq_newtoff.cpp:/* ----------------------------------------------------------------------
npair_half_size_nsq_newtoff.cpp:   N^2 / 2 search for neighbor pairs with partial Newton's 3rd law
npair_half_size_nsq_newtoff.cpp:------------------------------------------------------------------------- */
npair_half_size_nsq_newtoff.cpp:    // loop over remaining atoms, owned and ghost
npair_half_size_nsq_newton.cpp:/* ----------------------------------------------------------------------
npair_half_size_nsq_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_half_size_nsq_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_half_size_nsq_newton.cpp:------------------------------------------------------------------------- */
npair_half_size_nsq_newton.cpp:/* ---------------------------------------------------------------------- */
npair_half_size_nsq_newton.cpp:/* ----------------------------------------------------------------------
npair_half_size_nsq_newton.cpp:   N^2 / 2 search for neighbor pairs with full Newton's 3rd law
npair_half_size_nsq_newton.cpp:------------------------------------------------------------------------- */
npair_half_size_nsq_newton.cpp:    // loop over remaining atoms, owned and ghost
npair_skip.cpp:/* ----------------------------------------------------------------------
npair_skip.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_skip.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_skip.cpp:------------------------------------------------------------------------- */
npair_skip.cpp:/* ---------------------------------------------------------------------- */
npair_skip.cpp:/* ----------------------------------------------------------------------
npair_skip.cpp:------------------------------------------------------------------------- */
npair_skip.cpp:  // loop over atoms in other list
npair_skip.cpp:  // skip I atom entirely if iskip is set for type[I]
npair_skip.cpp:  // skip I,J pair if ijskip is set for type[I],type[J]
npair_skip.cpp:    // loop over parent non-skip list
npair_skip_respa.cpp:/* ----------------------------------------------------------------------
npair_skip_respa.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_skip_respa.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_skip_respa.cpp:------------------------------------------------------------------------- */
npair_skip_respa.cpp:/* ---------------------------------------------------------------------- */
npair_skip_respa.cpp:/* ----------------------------------------------------------------------
npair_skip_respa.cpp:   this is for respa lists, copy the inner/middle values from parent
npair_skip_respa.cpp:------------------------------------------------------------------------- */
npair_skip_respa.cpp:  // loop over atoms in other list
npair_skip_respa.cpp:  // skip I atom entirely if iskip is set for type[I]
npair_skip_respa.cpp:  // skip I,J pair if ijskip is set for type[I],type[J]
npair_skip_respa.cpp:    // loop over parent outer rRESPA list
npair_skip_respa.cpp:    // loop over parent inner rRESPA list
npair_skip_respa.cpp:    // loop over parent middle rRESPA list
npair_skip_size.cpp:/* ----------------------------------------------------------------------
npair_skip_size.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_skip_size.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_skip_size.cpp:------------------------------------------------------------------------- */
npair_skip_size.cpp:/* ---------------------------------------------------------------------- */
npair_skip_size.cpp:/* ----------------------------------------------------------------------
npair_skip_size.cpp:   if list requests it, preserve shear history via fix shear/history 
npair_skip_size.cpp:------------------------------------------------------------------------- */
npair_skip_size.cpp:  // loop over atoms in other list
npair_skip_size.cpp:  // skip I atom entirely if iskip is set for type[I]
npair_skip_size.cpp:  // skip I,J pair if ijskip is set for type[I],type[J]
npair_skip_size.cpp:    // loop over parent non-skip size list and optionally its history info
npair_skip_size.cpp:      // no numeric test for current touch
npair_skip_size.cpp:      // just use FSH partner list to infer it
npair_skip_size.cpp:      // would require distance calculation for spheres
npair_skip_size.cpp:      // more complex calculation for surfs
npair_skip_size_off2on.cpp:/* ----------------------------------------------------------------------
npair_skip_size_off2on.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_skip_size_off2on.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_skip_size_off2on.cpp:------------------------------------------------------------------------- */
npair_skip_size_off2on.cpp:/* ---------------------------------------------------------------------- */
npair_skip_size_off2on.cpp:/* ----------------------------------------------------------------------
npair_skip_size_off2on.cpp:   if list requests it, preserve shear history via fix shear/history 
npair_skip_size_off2on.cpp:------------------------------------------------------------------------- */
npair_skip_size_off2on.cpp:  // loop over atoms in other list
npair_skip_size_off2on.cpp:  // skip I atom entirely if iskip is set for type[I]
npair_skip_size_off2on.cpp:  // skip I,J pair if ijskip is set for type[I],type[J]
npair_skip_size_off2on.cpp:    // loop over parent non-skip size list and optionally its history info
npair_skip_size_off2on.cpp:      // only keep I,J when J = ghost if Itag < Jtag
npair_skip_size_off2on.cpp:      // no numeric test for current touch
npair_skip_size_off2on.cpp:      // just use FSH partner list to infer it
npair_skip_size_off2on.cpp:      // would require distance calculation for spheres
npair_skip_size_off2on.cpp:      // more complex calculation for surfs
npair_skip_size_off2on_oneside.cpp:/* ----------------------------------------------------------------------
npair_skip_size_off2on_oneside.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
npair_skip_size_off2on_oneside.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
npair_skip_size_off2on_oneside.cpp:------------------------------------------------------------------------- */
npair_skip_size_off2on_oneside.cpp:/* ---------------------------------------------------------------------- */
npair_skip_size_off2on_oneside.cpp:/* ----------------------------------------------------------------------
npair_skip_size_off2on_oneside.cpp:   if list requests it, preserve shear history via fix shear/history 
npair_skip_size_off2on_oneside.cpp:------------------------------------------------------------------------- */
npair_skip_size_off2on_oneside.cpp:  // two loops over parent list required, one to count, one to store
npair_skip_size_off2on_oneside.cpp:  // because onesided constraint means pair I,J may be stored with I or J
npair_skip_size_off2on_oneside.cpp:  // so don't know in advance how much space to alloc for each atom's neighs
npair_skip_size_off2on_oneside.cpp:  // first loop over atoms in other list to count neighbors
npair_skip_size_off2on_oneside.cpp:  // skip I atom entirely if iskip is set for type[I]
npair_skip_size_off2on_oneside.cpp:  // skip I,J pair if ijskip is set for type[I],type[J]
npair_skip_size_off2on_oneside.cpp:    // loop over parent non-skip size list
npair_skip_size_off2on_oneside.cpp:      // flip I,J if necessary to satisfy onesided constraint
npair_skip_size_off2on_oneside.cpp:      // do not keep if I is now ghost
npair_skip_size_off2on_oneside.cpp:  // allocate all per-atom neigh list chunks, including history
npair_skip_size_off2on_oneside.cpp:  // second loop over atoms in other list to store neighbors
npair_skip_size_off2on_oneside.cpp:  // skip I atom entirely if iskip is set for type[I]
npair_skip_size_off2on_oneside.cpp:  // skip I,J pair if ijskip is set for type[I],type[J]
npair_skip_size_off2on_oneside.cpp:    // loop over parent non-skip size list and optionally its history info
npair_skip_size_off2on_oneside.cpp:      // flip I,J if necessary to satisfy onesided constraint
npair_skip_size_off2on_oneside.cpp:      // do not keep if I is now ghost
npair_skip_size_off2on_oneside.cpp:      // store j in neigh list, not joriginal, like other neigh methods
npair_skip_size_off2on_oneside.cpp:      // OK, b/c there is no special list flagging for surfs
npair_skip_size_off2on_oneside.cpp:      // no numeric test for current touch
npair_skip_size_off2on_oneside.cpp:      // just use FSH partner list to infer it
npair_skip_size_off2on_oneside.cpp:      // would require complex calculation for surfs
npair_skip_size_off2on_oneside.cpp:    // only add atom I to ilist if it has neighbors
npair_skip_size_off2on_oneside.cpp:    // fix shear/history allows for this in pre_exchange_onesided()
nstencil.cpp:/* ----------------------------------------------------------------------
nstencil.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil.cpp:------------------------------------------------------------------------- */
nstencil.cpp:enum{NSQ,BIN,MULTI};     // also in Neighbor
nstencil.cpp:/* ----------------------------------------------------------------------
nstencil.cpp:     invoked each time simulation box size/shape changes
nstencil.cpp:     regardless of newton on/off or triclinic
nstencil.cpp:     stencil follows same rules for half/full, newton on/off, triclinic
nstencil.cpp:------------------------------------------------------------------------- */
nstencil.cpp:/* ---------------------------------------------------------------------- */
nstencil.cpp:/* ---------------------------------------------------------------------- */
nstencil.cpp:/* ----------------------------------------------------------------------
nstencil.cpp:------------------------------------------------------------------------- */
nstencil.cpp:  // overwrite Neighbor cutoff with custom value set by requestor
nstencil.cpp:  // only works for style = BIN (checked by Neighbor class)
nstencil.cpp:/* ----------------------------------------------------------------------
nstencil.cpp:------------------------------------------------------------------------- */
nstencil.cpp:/* ----------------------------------------------------------------------
nstencil.cpp:------------------------------------------------------------------------- */
nstencil.cpp:  // sx,sy,sz = max range of stencil in each dim
nstencil.cpp:  // smax = max possible size of entire 3d stencil
nstencil.cpp:  // stencil will be empty if cutneighmax = 0.0
nstencil.cpp:  // reallocate stencil structs if necessary
nstencil.cpp:  // for BIN and MULTI styles
nstencil.cpp:/* ----------------------------------------------------------------------
nstencil.cpp:------------------------------------------------------------------------- */
nstencil.cpp:/* ---------------------------------------------------------------------- */
nstencil_full_bin_2d.cpp:/* ----------------------------------------------------------------------
nstencil_full_bin_2d.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_full_bin_2d.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_full_bin_2d.cpp:------------------------------------------------------------------------- */
nstencil_full_bin_2d.cpp:/* ---------------------------------------------------------------------- */
nstencil_full_bin_2d.cpp:/* ----------------------------------------------------------------------
nstencil_full_bin_2d.cpp:------------------------------------------------------------------------- */
nstencil_full_bin_3d.cpp:/* ----------------------------------------------------------------------
nstencil_full_bin_3d.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_full_bin_3d.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_full_bin_3d.cpp:------------------------------------------------------------------------- */
nstencil_full_bin_3d.cpp:/* ---------------------------------------------------------------------- */
nstencil_full_bin_3d.cpp:/* ----------------------------------------------------------------------
nstencil_full_bin_3d.cpp:------------------------------------------------------------------------- */
nstencil_full_ghost_bin_2d.cpp:/* ----------------------------------------------------------------------
nstencil_full_ghost_bin_2d.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_full_ghost_bin_2d.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_full_ghost_bin_2d.cpp:------------------------------------------------------------------------- */
nstencil_full_ghost_bin_2d.cpp:/* ---------------------------------------------------------------------- */
nstencil_full_ghost_bin_2d.cpp:/* ----------------------------------------------------------------------
nstencil_full_ghost_bin_2d.cpp:------------------------------------------------------------------------- */
nstencil_full_ghost_bin_3d.cpp:/* ----------------------------------------------------------------------
nstencil_full_ghost_bin_3d.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_full_ghost_bin_3d.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_full_ghost_bin_3d.cpp:------------------------------------------------------------------------- */
nstencil_full_ghost_bin_3d.cpp:/* ---------------------------------------------------------------------- */
nstencil_full_ghost_bin_3d.cpp:/* ----------------------------------------------------------------------
nstencil_full_ghost_bin_3d.cpp:------------------------------------------------------------------------- */
nstencil_full_multi_2d.cpp:/* ----------------------------------------------------------------------
nstencil_full_multi_2d.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_full_multi_2d.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_full_multi_2d.cpp:------------------------------------------------------------------------- */
nstencil_full_multi_2d.cpp:/* ---------------------------------------------------------------------- */
nstencil_full_multi_2d.cpp:/* ----------------------------------------------------------------------
nstencil_full_multi_2d.cpp:------------------------------------------------------------------------- */
nstencil_full_multi_3d.cpp:/* ----------------------------------------------------------------------
nstencil_full_multi_3d.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_full_multi_3d.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_full_multi_3d.cpp:------------------------------------------------------------------------- */
nstencil_full_multi_3d.cpp:/* ---------------------------------------------------------------------- */
nstencil_full_multi_3d.cpp:/* ----------------------------------------------------------------------
nstencil_full_multi_3d.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_2d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_2d_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_bin_2d_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_bin_2d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_2d_newtoff.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_bin_2d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_2d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_2d_newton.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_2d_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_bin_2d_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_bin_2d_newton.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_2d_newton.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_bin_2d_newton.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_2d_newton.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_2d_newton_tri.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_2d_newton_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_bin_2d_newton_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_bin_2d_newton_tri.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_2d_newton_tri.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_bin_2d_newton_tri.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_2d_newton_tri.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_3d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_3d_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_bin_3d_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_bin_3d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_3d_newtoff.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_bin_3d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_3d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_3d_newton.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_3d_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_bin_3d_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_bin_3d_newton.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_3d_newton.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_bin_3d_newton.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_3d_newton.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_3d_newton_tri.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_3d_newton_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_bin_3d_newton_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_bin_3d_newton_tri.cpp:------------------------------------------------------------------------- */
nstencil_half_bin_3d_newton_tri.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_bin_3d_newton_tri.cpp:/* ----------------------------------------------------------------------
nstencil_half_bin_3d_newton_tri.cpp:------------------------------------------------------------------------- */
nstencil_half_ghost_bin_2d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_ghost_bin_2d_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_ghost_bin_2d_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_ghost_bin_2d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_ghost_bin_2d_newtoff.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_ghost_bin_2d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_ghost_bin_2d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_ghost_bin_3d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_ghost_bin_3d_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_ghost_bin_3d_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_ghost_bin_3d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_ghost_bin_3d_newtoff.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_ghost_bin_3d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_ghost_bin_3d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_2d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_2d_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_multi_2d_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_multi_2d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_2d_newtoff.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_multi_2d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_2d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_2d_newton.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_2d_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_multi_2d_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_multi_2d_newton.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_2d_newton.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_multi_2d_newton.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_2d_newton.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_2d_newton_tri.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_2d_newton_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_multi_2d_newton_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_multi_2d_newton_tri.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_2d_newton_tri.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_multi_2d_newton_tri.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_2d_newton_tri.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_3d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_3d_newtoff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_multi_3d_newtoff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_multi_3d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_3d_newtoff.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_multi_3d_newtoff.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_3d_newtoff.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_3d_newton.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_3d_newton.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_multi_3d_newton.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_multi_3d_newton.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_3d_newton.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_multi_3d_newton.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_3d_newton.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_3d_newton_tri.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_3d_newton_tri.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
nstencil_half_multi_3d_newton_tri.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
nstencil_half_multi_3d_newton_tri.cpp:------------------------------------------------------------------------- */
nstencil_half_multi_3d_newton_tri.cpp:/* ---------------------------------------------------------------------- */
nstencil_half_multi_3d_newton_tri.cpp:/* ----------------------------------------------------------------------
nstencil_half_multi_3d_newton_tri.cpp:------------------------------------------------------------------------- */
ntopo_angle_all.cpp:/* ----------------------------------------------------------------------
ntopo_angle_all.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_angle_all.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_angle_all.cpp:------------------------------------------------------------------------- */
ntopo_angle_all.cpp:/* ---------------------------------------------------------------------- */
ntopo_angle_all.cpp:/* ---------------------------------------------------------------------- */
ntopo_angle_partial.cpp:/* ----------------------------------------------------------------------
ntopo_angle_partial.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_angle_partial.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_angle_partial.cpp:------------------------------------------------------------------------- */
ntopo_angle_partial.cpp:/* ---------------------------------------------------------------------- */
ntopo_angle_partial.cpp:/* ---------------------------------------------------------------------- */
ntopo_angle_template.cpp:/* ----------------------------------------------------------------------
ntopo_angle_template.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_angle_template.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_angle_template.cpp:------------------------------------------------------------------------- */
ntopo_angle_template.cpp:/* ---------------------------------------------------------------------- */
ntopo_angle_template.cpp:/* ---------------------------------------------------------------------- */
ntopo_bond_all.cpp:/* ----------------------------------------------------------------------
ntopo_bond_all.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_bond_all.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_bond_all.cpp:------------------------------------------------------------------------- */
ntopo_bond_all.cpp:/* ---------------------------------------------------------------------- */
ntopo_bond_all.cpp:/* ---------------------------------------------------------------------- */
ntopo_bond_partial.cpp:/* ----------------------------------------------------------------------
ntopo_bond_partial.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_bond_partial.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_bond_partial.cpp:------------------------------------------------------------------------- */
ntopo_bond_partial.cpp:/* ---------------------------------------------------------------------- */
ntopo_bond_partial.cpp:/* ---------------------------------------------------------------------- */
ntopo_bond_template.cpp:/* ----------------------------------------------------------------------
ntopo_bond_template.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_bond_template.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_bond_template.cpp:------------------------------------------------------------------------- */
ntopo_bond_template.cpp:/* ---------------------------------------------------------------------- */
ntopo_bond_template.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:/* ----------------------------------------------------------------------
ntopo.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo.cpp:------------------------------------------------------------------------- */
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:  else maxbond = static_cast<int> (LB_FACTOR * atom->nbonds / nprocs);
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:  else maxangle = static_cast<int> (LB_FACTOR * atom->nangles / nprocs);
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:  else maxdihedral = static_cast<int> (LB_FACTOR * atom->ndihedrals / nprocs);
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:  else maximproper = static_cast<int> (LB_FACTOR * atom->nimpropers / nprocs);
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:  // check all 3 distances
ntopo.cpp:  // in case angle potential computes any of them
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo.cpp:  // check all 6 distances
ntopo.cpp:  // in case dihedral/improper potential computes any of them
ntopo.cpp:    error->all(FLERR,"Dihedral/improper extent > half of periodic box length");
ntopo.cpp:/* ---------------------------------------------------------------------- */
ntopo_dihedral_all.cpp:/* ----------------------------------------------------------------------
ntopo_dihedral_all.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_dihedral_all.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_dihedral_all.cpp:------------------------------------------------------------------------- */
ntopo_dihedral_all.cpp:/* ---------------------------------------------------------------------- */
ntopo_dihedral_all.cpp:/* ---------------------------------------------------------------------- */
ntopo_dihedral_partial.cpp:/* ----------------------------------------------------------------------
ntopo_dihedral_partial.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_dihedral_partial.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_dihedral_partial.cpp:------------------------------------------------------------------------- */
ntopo_dihedral_partial.cpp:/* ---------------------------------------------------------------------- */
ntopo_dihedral_partial.cpp:/* ---------------------------------------------------------------------- */
ntopo_dihedral_template.cpp:/* ----------------------------------------------------------------------
ntopo_dihedral_template.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_dihedral_template.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_dihedral_template.cpp:------------------------------------------------------------------------- */
ntopo_dihedral_template.cpp:/* ---------------------------------------------------------------------- */
ntopo_dihedral_template.cpp:/* ---------------------------------------------------------------------- */
ntopo_improper_all.cpp:/* ----------------------------------------------------------------------
ntopo_improper_all.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_improper_all.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_improper_all.cpp:------------------------------------------------------------------------- */
ntopo_improper_all.cpp:/* ---------------------------------------------------------------------- */
ntopo_improper_all.cpp:/* ---------------------------------------------------------------------- */
ntopo_improper_partial.cpp:/* ----------------------------------------------------------------------
ntopo_improper_partial.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
ntopo_improper_partial.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_improper_partial.cpp:------------------------------------------------------------------------- */
ntopo_improper_partial.cpp:/* ---------------------------------------------------------------------- */
ntopo_improper_partial.cpp:/* ---------------------------------------------------------------------- */
ntopo_improper_template.cpp:/* ----------------------------------------------------------------------
ntopo_improper_template.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Templatel Simulator
ntopo_improper_template.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
ntopo_improper_template.cpp:------------------------------------------------------------------------- */
ntopo_improper_template.cpp:/* ---------------------------------------------------------------------- */
ntopo_improper_template.cpp:/* ---------------------------------------------------------------------- */
output.cpp:/* ----------------------------------------------------------------------
output.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
output.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
output.cpp:------------------------------------------------------------------------- */
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:  // create default computes for temp,pressure,pe
output.cpp:  // create default Thermo class
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:/* ---------------------------------------------------------------------- */
output.cpp:/* ----------------------------------------------------------------------
output.cpp:   perform output for setup of run/min
output.cpp:   memflag = 0/1 for printing out memory usage
output.cpp:------------------------------------------------------------------------- */
output.cpp:  // perform dump at start of run only if:
output.cpp:  //   current timestep is multiple of every and last dump not >= this step
output.cpp:  //   this is first run after dump created and firstflag is set
output.cpp:  //   note that variable freq will not write unless triggered by firstflag
output.cpp:  // set next_dump to multiple of every or variable value
output.cpp:  // set next_dump_any to smallest next_dump
output.cpp:  // wrap dumps that invoke computes and variable eval with clear/add
output.cpp:  // if dump not written now, use addstep_compute_all() since don't know
output.cpp:  //   what computes the dump write would invoke
output.cpp:  // if no dumps, set next_dump_any to last+1 so will not influence next
output.cpp:          (ntimestep/every_dump[idump])*every_dump[idump] + every_dump[idump];
output.cpp:  // do not write restart files at start of run
output.cpp:  // set next_restart values to multiple of every or variable value
output.cpp:  // wrap variable eval with clear/add
output.cpp:  // if no restarts, set next_restart to last+1 so will not influence next
output.cpp:          (ntimestep/restart_every_single)*restart_every_single +
output.cpp:          (ntimestep/restart_every_double)*restart_every_double +
output.cpp:  // print memory usage unless being called between multiple runs
output.cpp:  // set next_thermo to multiple of every or variable eval if var defined
output.cpp:  // insure thermo output on last step of run
output.cpp:  // thermo may invoke computes so wrap with clear/add
output.cpp:    next_thermo = (ntimestep/thermo_every)*thermo_every + thermo_every;
output.cpp:  // next = next timestep any output will be done
output.cpp:/* ----------------------------------------------------------------------
output.cpp:   do dump/restart before thermo so thermo CPU time will include them
output.cpp:------------------------------------------------------------------------- */
output.cpp:  // next_dump does not force output on last step of run
output.cpp:  // wrap dumps that invoke computes or eval of variable with clear/add
output.cpp:  // next_restart does not force output on last step of run
output.cpp:  // for toggle = 0, replace "*" with current timestep in restart filename
output.cpp:  // eval of variable may invoke computes so wrap with clear/add
output.cpp:  // insure next_thermo forces output on last step of run
output.cpp:  // thermo may invoke computes so wrap with clear/add
output.cpp:  // next = next timestep any output will be done
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:      next_dump[idump] = (ntimestep/every_dump[idump])*every_dump[idump];
output.cpp:      // ivar_dump may not be initialized
output.cpp:        (ntimestep/restart_every_single)*restart_every_single;
output.cpp:        (ntimestep/restart_every_double)*restart_every_double;
output.cpp:    next_thermo = (ntimestep/thermo_every)*thermo_every;
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:  // error checks
output.cpp:  // extend Dump list if necessary
output.cpp:  // initialize per-dump data to suitable default values
output.cpp:  // create the Dump
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:  // find which dump it is
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:  // find which dump it is and delete it
output.cpp:  // move other dumps down in list one slot
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:  // don't allow this so that dipole style can safely allocate inertia vector
output.cpp:  // warn if previous thermo had been modified via thermo_modify command
output.cpp:  // set thermo = NULL in case new Thermo throws an error
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:  // check for multiproc output and an MPI-IO filename
output.cpp:  // if 2 filenames, must be consistent
output.cpp:  // setup output style and process optional args
output.cpp:/* ----------------------------------------------------------------------
output.cpp:------------------------------------------------------------------------- */
output.cpp:  double mbytes = bytes/1024.0/1024.0;
output.cpp:  mbavg /= comm->nprocs;
output.cpp:      fprintf(screen,"Per MPI rank memory allocation (min/avg/max) = "
output.cpp:      fprintf(logfile,"Per MPI rank memory allocation (min/avg/max) = "
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_beck.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ---------------------------------------------------------------------- */
pair_beck.cpp:/* ---------------------------------------------------------------------- */
pair_beck.cpp:/* ---------------------------------------------------------------------- */
pair_beck.cpp:  // loop over neighbors of my atoms
pair_beck.cpp:        rinv  = 1.0/r;
pair_beck.cpp:          term1inv = 1.0/term1;
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:  // reset cutoffs that have been explicitly set
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ----------------------------------------------------------------------
pair_beck.cpp:------------------------------------------------------------------------- */
pair_beck.cpp:/* ---------------------------------------------------------------------- */
pair_beck.cpp:  rinv  = 1.0/r;
pair_beck.cpp:  term1inv = 1.0/term1;
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_born_coul_dsf.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:  // loop over neighbors of my atoms
pair_born_coul_dsf.cpp:    // self coulombic energy
pair_born_coul_dsf.cpp:      double e_self = -(e_shift/2.0 + alpha/MY_PIS) * qtmp*qtmp*qqrd2e;
pair_born_coul_dsf.cpp:        r2inv = 1.0/rsq;
pair_born_coul_dsf.cpp:          prefactor = qqrd2e*qtmp*q[j]/r;
pair_born_coul_dsf.cpp:          forcecoul = prefactor * (erfcc/r + 2.0*alpha/MY_PIS * erfcd +
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:    error->all(FLERR,"Pair style born/coul/dsf requires atom attribute q");
pair_born_coul_dsf.cpp:  f_shift = -(erfcc/cut_coulsq + 2.0/MY_PIS*alpha*erfcd/cut_coul);
pair_born_coul_dsf.cpp:  e_shift = erfcc/cut_coul - f_shift*cut_coul;
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:  rhoinv[i][j] = 1.0/rho[i][j];
pair_born_coul_dsf.cpp:  born1[i][j] = a[i][j]/rho[i][j];
pair_born_coul_dsf.cpp:    offset[i][j] = a[i][j]*rexp - c[i][j]/pow(cut_lj[i][j],6.0)
pair_born_coul_dsf.cpp:      + d[i][j]/pow(cut_lj[i][j],8.0);
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_born_coul_dsf.cpp:  r2inv = 1.0/rsq;
pair_born_coul_dsf.cpp:    prefactor = factor_coul * force->qqrd2e * atom->q[i]*atom->q[j]/r;
pair_born_coul_dsf.cpp:    forcecoul = prefactor * (erfcc/r + 2.0*alpha/MY_PIS*erfcd +
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_born_coul_wolf.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ---------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ---------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ---------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:  // self and shifted coulombic energy
pair_born_coul_wolf.cpp:  e_shift = erfc(alf*cut_coul)/cut_coul;
pair_born_coul_wolf.cpp:  f_shift = -(e_shift+ 2.0*alf/MY_PIS * exp(-alf*alf*cut_coul*cut_coul)) /
pair_born_coul_wolf.cpp:  // loop over neighbors of my atoms
pair_born_coul_wolf.cpp:    e_self = -(e_shift/2.0 + alf/MY_PIS) * qisq*qqrd2e;
pair_born_coul_wolf.cpp:        r2inv = 1.0/rsq;
pair_born_coul_wolf.cpp:          prefactor = qqrd2e*qtmp*q[j]/r;
pair_born_coul_wolf.cpp:          dvdrr = (erfcc/rsq + 2.0*alf/MY_PIS * erfcd/r) + f_shift;
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:    error->all(FLERR,"Pair style born/coul/wolf requires atom attribute q");
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:  rhoinv[i][j] = 1.0/rho[i][j];
pair_born_coul_wolf.cpp:  born1[i][j] = a[i][j]/rho[i][j];
pair_born_coul_wolf.cpp:    offset[i][j] = a[i][j]*rexp - c[i][j]/pow(cut_lj[i][j],6.0)
pair_born_coul_wolf.cpp:      + d[i][j]/pow(cut_lj[i][j],8.0);
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_born_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_born_coul_wolf.cpp:  r2inv = 1.0/rsq;
pair_born_coul_wolf.cpp:  e_shift = erfc(alf*cut_coul) / cut_coul;
pair_born_coul_wolf.cpp:  f_shift = -(e_shift+2*alf/MY_PIS * exp(-alf*alf*cut_coul*cut_coul)) /
pair_born_coul_wolf.cpp:    prefactor = force->qqrd2e * atom->q[i]*atom->q[j]/r;
pair_born_coul_wolf.cpp:    dvdrr = (erfcc/rsq + 2.0*alf/MY_PIS * erfcd/r) + f_shift;
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_born.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ---------------------------------------------------------------------- */
pair_born.cpp:/* ---------------------------------------------------------------------- */
pair_born.cpp:/* ---------------------------------------------------------------------- */
pair_born.cpp:  // loop over neighbors of my atoms
pair_born.cpp:        r2inv = 1.0/rsq;
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:  // reset cutoffs that have been explicitly set
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:  rhoinv[i][j] = 1.0/rho[i][j];
pair_born.cpp:  born1[i][j] = a[i][j]/rho[i][j];
pair_born.cpp:    offset[i][j] = a[i][j]*rexp - c[i][j]/pow(cut[i][j],6.0) +
pair_born.cpp:      d[i][j]/pow(cut[i][j],8.0);
pair_born.cpp:  // compute I,J contribution to long-range tail correction
pair_born.cpp:  // count total # of atoms of type I and J via Allreduce
pair_born.cpp:       (a[i][j]*exp((sigma[i][j]-rc)/rho1)*rho1*
pair_born.cpp:        c[i][j]/(3.0*rc3) + d[i][j]/(5.0*rc5));
pair_born.cpp:     ptail_ij = (-1/3.0)*2.0*MY_PI*all[0]*all[1] *
pair_born.cpp:       (-a[i][j]*exp((sigma[i][j]-rc)/rho1) *
pair_born.cpp:        2.0*c[i][j]/rc3 - 8.0*d[i][j]/(5.0*rc5));
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ----------------------------------------------------------------------
pair_born.cpp:------------------------------------------------------------------------- */
pair_born.cpp:/* ---------------------------------------------------------------------- */
pair_born.cpp:  r2inv = 1.0/rsq;
pair_born.cpp:/* ---------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_buck_coul_cut.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:  // loop over neighbors of my atoms
pair_buck_coul_cut.cpp:        r2inv = 1.0/rsq;
pair_buck_coul_cut.cpp:          forcecoul = qqrd2e * qtmp*q[j]/r;
pair_buck_coul_cut.cpp:            ecoul = factor_coul * qqrd2e * qtmp*q[j]/r;
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:  // reset cutoffs that have been explicitly set
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:    error->all(FLERR,"Pair style buck/coul/cut requires atom attribute q");
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:  rhoinv[i][j] = 1.0/rho[i][j];
pair_buck_coul_cut.cpp:  buck1[i][j] = a[i][j]/rho[i][j];
pair_buck_coul_cut.cpp:    double rexp = exp(-cut_lj[i][j]/rho[i][j]);
pair_buck_coul_cut.cpp:    offset[i][j] = a[i][j]*rexp - c[i][j]/pow(cut_lj[i][j],6.0);
pair_buck_coul_cut.cpp:  // compute I,J contribution to long-range tail correction
pair_buck_coul_cut.cpp:  // count total # of atoms of type I and J via Allreduce
pair_buck_coul_cut.cpp:      (a[i][j]*exp(-rc/rho1)*rho1*(rc2 + 2.0*rho1*rc + 2.0*rho2) -
pair_buck_coul_cut.cpp:       c[i][j]/(3.0*rc3));
pair_buck_coul_cut.cpp:    ptail_ij = (-1/3.0)*2.0*MY_PI*all[0]*all[1]*
pair_buck_coul_cut.cpp:      (-a[i][j]*exp(-rc/rho1)*
pair_buck_coul_cut.cpp:       (rc3 + 3.0*rho1*rc2 + 6.0*rho2*rc + 6.0*rho3) + 2.0*c[i][j]/rc3);
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_buck_coul_cut.cpp:------------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_buck_coul_cut.cpp:  r2inv = 1.0/rsq;
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_buck.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ---------------------------------------------------------------------- */
pair_buck.cpp:/* ---------------------------------------------------------------------- */
pair_buck.cpp:/* ---------------------------------------------------------------------- */
pair_buck.cpp:  // loop over neighbors of my atoms
pair_buck.cpp:        r2inv = 1.0/rsq;
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:  // reset cutoffs that have been explicitly set
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:  rhoinv[i][j] = 1.0/rho[i][j];
pair_buck.cpp:  buck1[i][j] = a[i][j]/rho[i][j];
pair_buck.cpp:    double rexp = exp(-cut[i][j]/rho[i][j]);
pair_buck.cpp:    offset[i][j] = a[i][j]*rexp - c[i][j]/pow(cut[i][j],6.0);
pair_buck.cpp:  // compute I,J contribution to long-range tail correction
pair_buck.cpp:  // count total # of atoms of type I and J via Allreduce
pair_buck.cpp:      (a[i][j]*exp(-rc/rho1)*rho1*(rc2 + 2.0*rho1*rc + 2.0*rho2) -
pair_buck.cpp:       c[i][j]/(3.0*rc3));
pair_buck.cpp:    ptail_ij = (-1/3.0)*2.0*MY_PI*all[0]*all[1]*
pair_buck.cpp:      (-a[i][j]*exp(-rc/rho1)*
pair_buck.cpp:       (rc3 + 3.0*rho1*rc2 + 6.0*rho2*rc + 6.0*rho3) + 2.0*c[i][j]/rc3);
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ----------------------------------------------------------------------
pair_buck.cpp:------------------------------------------------------------------------- */
pair_buck.cpp:/* ---------------------------------------------------------------------- */
pair_buck.cpp:  r2inv = 1.0/rsq;
pair_buck.cpp:/* ---------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_coul_cut.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_coul_cut.cpp:  // loop over neighbors of my atoms
pair_coul_cut.cpp:        r2inv = 1.0/rsq;
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:  // reset cutoffs that have been explicitly set
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:    error->all(FLERR,"Pair style coul/cut requires atom attribute q");
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_coul_cut.cpp:------------------------------------------------------------------------- */
pair_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_coul_cut.cpp:  r2inv = 1.0/rsq;
pair_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_coul_debye.cpp:/* ----------------------------------------------------------------------
pair_coul_debye.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_coul_debye.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_coul_debye.cpp:------------------------------------------------------------------------- */
pair_coul_debye.cpp:/* ---------------------------------------------------------------------- */
pair_coul_debye.cpp:/* ---------------------------------------------------------------------- */
pair_coul_debye.cpp:  // loop over neighbors of my atoms
pair_coul_debye.cpp:        r2inv = 1.0/rsq;
pair_coul_debye.cpp:        rinv = 1.0/r;
pair_coul_debye.cpp:/* ----------------------------------------------------------------------
pair_coul_debye.cpp:------------------------------------------------------------------------- */
pair_coul_debye.cpp:  // reset cutoffs that have been explicitly set
pair_coul_debye.cpp:/* ----------------------------------------------------------------------
pair_coul_debye.cpp:------------------------------------------------------------------------- */
pair_coul_debye.cpp:/* ----------------------------------------------------------------------
pair_coul_debye.cpp:------------------------------------------------------------------------- */
pair_coul_debye.cpp:/* ---------------------------------------------------------------------- */
pair_coul_debye.cpp:  r2inv = 1.0/rsq;
pair_coul_debye.cpp:  rinv = 1.0/r;
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_coul_dsf.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_coul_dsf.cpp:  // loop over neighbors of my atoms
pair_coul_dsf.cpp:      double e_self = -(e_shift/2.0 + alpha/MY_PIS) * qtmp*qtmp*qqrd2e;
pair_coul_dsf.cpp:        r2inv = 1.0/rsq;
pair_coul_dsf.cpp:        prefactor = qqrd2e*qtmp*q[j]/r;
pair_coul_dsf.cpp:        t = 1.0 / (1.0 + EWALD_P*alpha*r);
pair_coul_dsf.cpp:        forcecoul = prefactor * (erfcc/r + 2.0*alpha/MY_PIS * erfcd +
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:    error->all(FLERR,"Pair style coul/dsf requires atom attribute q");
pair_coul_dsf.cpp:  f_shift = -(erfcc/cut_coulsq + 2.0/MY_PIS*alpha*erfcd/cut_coul);
pair_coul_dsf.cpp:  e_shift = erfcc/cut_coul - f_shift*cut_coul;
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_coul_dsf.cpp:  r2inv = 1.0/rsq;
pair_coul_dsf.cpp:    prefactor = factor_coul * force->qqrd2e * atom->q[i]*atom->q[j]/r;
pair_coul_dsf.cpp:    t = 1.0 / (1.0 + EWALD_P*alpha*r);
pair_coul_dsf.cpp:    forcecoul = prefactor * (erfcc/r + 2.0*alpha/MY_PIS*erfcd +
pair_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ----------------------------------------------------------------------
pair_coul_streitz.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_coul_streitz.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_coul_streitz.cpp:------------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ----------------------------------------------------------------------
pair_coul_streitz.cpp:------------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ----------------------------------------------------------------------
pair_coul_streitz.cpp:------------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ----------------------------------------------------------------------
pair_coul_streitz.cpp:------------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ----------------------------------------------------------------------
pair_coul_streitz.cpp:------------------------------------------------------------------------- */
pair_coul_streitz.cpp:  // insure I,J args are * *
pair_coul_streitz.cpp:  // read args that map atom types to elements in potential file
pair_coul_streitz.cpp:  // map[i] = which element the Ith atom type is, -1 if NULL
pair_coul_streitz.cpp:  // nelements = # of unique elements
pair_coul_streitz.cpp:  // elements = list of element names
pair_coul_streitz.cpp:  // read potential file and initialize potential parameters
pair_coul_streitz.cpp:  // clear setflag since coeff() called once with I,J = * *
pair_coul_streitz.cpp:  // set setflag i,j for type pairs where both are mapped to elements
pair_coul_streitz.cpp:/* ----------------------------------------------------------------------
pair_coul_streitz.cpp:------------------------------------------------------------------------- */
pair_coul_streitz.cpp:    error->all(FLERR,"Pair style coul/streitz requires atom attribute q");
pair_coul_streitz.cpp:  // insure use of KSpace long-range solver when ewald specified, set g_ewald
pair_coul_streitz.cpp:  // ptr to QEQ fix
pair_coul_streitz.cpp:  //for (i = 0; i < modify->nfix; i++)
pair_coul_streitz.cpp:  //  if (strcmp(modify->fix[i]->style,"qeq") == 0) break;
pair_coul_streitz.cpp:  //if (i < modify->nfix) fixqeq = (FixQEQ *) modify->fix[i];
pair_coul_streitz.cpp:  //else fixqeq = NULL;
pair_coul_streitz.cpp:/* ----------------------------------------------------------------------
pair_coul_streitz.cpp:------------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:  // open file on proc 0
pair_coul_streitz.cpp:      sprintf(str,"Cannot open coul/streitz potential file %s",file);
pair_coul_streitz.cpp:  // read each line out of file, skipping blank lines or leading '#'
pair_coul_streitz.cpp:  // store line of params if all 3 element tags are in element list
pair_coul_streitz.cpp:    // strip comment, skip line if blank
pair_coul_streitz.cpp:    // concatenate additional lines until have params_per_line words
pair_coul_streitz.cpp:      error->all(FLERR,"Incorrect format in coul/streitz potential file");
pair_coul_streitz.cpp:    // words = ptrs to all words in line
pair_coul_streitz.cpp:    // ielement = 1st args
pair_coul_streitz.cpp:    // load up parameter settings and error check their values
pair_coul_streitz.cpp:    // parameter sanity check
pair_coul_streitz.cpp:      error->all(FLERR,"Illegal coul/streitz parameter");
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:  // set elem2param
pair_coul_streitz.cpp:  // Wolf sum self energy
pair_coul_streitz.cpp:    woself = 0.50*erfc(ar)/r + a/MY_PIS;  // kc constant not yet multiplied
pair_coul_streitz.cpp:    dwoself = -(erfc(ar)/r/r + 2.0*a/MY_PIS*exp(-ar*ar)/r);
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:  // Wolf sum
pair_coul_streitz.cpp:    // self energy: ionization + wolf sum
pair_coul_streitz.cpp:    // two-body interaction
pair_coul_streitz.cpp:      // Streitz-Mintmire Coulomb integrals
pair_coul_streitz.cpp:      // Wolf Sum
pair_coul_streitz.cpp:      // Forces
pair_coul_streitz.cpp:      fpair = -forcecoul / r;
pair_coul_streitz.cpp:  // Ewald Sum
pair_coul_streitz.cpp:    // self ionizition energy, only on i atom
pair_coul_streitz.cpp:    // two-body interaction
pair_coul_streitz.cpp:      // Streitz-Mintmire Coulomb integrals
pair_coul_streitz.cpp:      // Ewald: real-space
pair_coul_streitz.cpp:      // Forces
pair_coul_streitz.cpp:      fpair = -forcecoul / r;
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:  double rinv = 1.0/r;
pair_coul_streitz.cpp:  double sm1 = 11.0/8.0;
pair_coul_streitz.cpp:  double sm2 = 3.00/4.0;
pair_coul_streitz.cpp:  double sm3 = 1.00/6.0;
pair_coul_streitz.cpp:  double rcinv = 1.0/rc;
pair_coul_streitz.cpp:		(2.0 + 7.0/6.0*zei*rc + 1.0/3.0*zei2*rc*rc));
pair_coul_streitz.cpp:		(2.0 + 7.0/6.0*zei*r + 1.0/3.0*zei2*r*r)) - fshift;
pair_coul_streitz.cpp:    e1 = zei*zej4/((zei+zej)*(zei+zej)*(zei-zej)*(zei-zej));
pair_coul_streitz.cpp:    e2 = zej*zei4/((zei+zej)*(zei+zej)*(zej-zei)*(zej-zei));
pair_coul_streitz.cpp:    e3 = (3.0*zei2*zej4-zej6) /
pair_coul_streitz.cpp:    e4 = (3.0*zej2*zei4-zei6) /
pair_coul_streitz.cpp:    eshift = -exp2zirsh*(e1+e3/rc) - exp2zjrsh*(e2+e4/rc);
pair_coul_streitz.cpp:    fshift = (exp2zirsh*(2.0*zei*(e1+e3/rc) + e3*rcinv2)
pair_coul_streitz.cpp:            + exp2zjrsh*(2.0*zej*(e2+e4/rc) + e4*rcinv2));
pair_coul_streitz.cpp:    ci_fifj = -exp2zir*(e1+e3/r) - exp2zjr*(e2+e4/r)
pair_coul_streitz.cpp:    dci_fifj = (exp2zir*(2.0*zei*(e1+e3/r) + e3*rinv2) +
pair_coul_streitz.cpp:                exp2zjr*(2.0*zej*(e2+e4/r) + e4*rinv2)) - fshift;
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:  etmp1 = erfcr/r - erfcrc/rc;
pair_coul_streitz.cpp:  ftmp1 = -erfcr/r/r - 2.0*a/MY_PIS*derfcr/r - dwoself;
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:  double rinv = 1.0/r;
pair_coul_streitz.cpp:  double sm1 = 11.0/8.0;
pair_coul_streitz.cpp:  double sm2 = 3.00/4.0;
pair_coul_streitz.cpp:  double sm3 = 1.00/6.0;
pair_coul_streitz.cpp:	   	zei2*(2.0 + 7.0/6.0*zei*r + 1.0/3.0*zei2*r*r));
pair_coul_streitz.cpp:    e1 = zei*zej4/((zei+zej)*(zei+zej)*(zei-zej)*(zei-zej));
pair_coul_streitz.cpp:    e2 = zej*zei4/((zei+zej)*(zei+zej)*(zej-zei)*(zej-zei));
pair_coul_streitz.cpp:    e3 = (3.0*zei2*zej4-zej6) /
pair_coul_streitz.cpp:    e4 = (3.0*zej2*zei4-zei6) /
pair_coul_streitz.cpp:    ci_fifj = -exp2zir*(e1+e3/r) - exp2zjr*(e2+e4/r);
pair_coul_streitz.cpp:    dci_fifj = (exp2zir*(2.0*zei*(e1+e3/r) + e3*rinv2)
pair_coul_streitz.cpp:              + exp2zjr*(2.0*zej*(e2+e4/r) + e4*rinv2));
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_streitz.cpp:  etmp4 = qqrd2e * 0.50*qi*qj/r;
pair_coul_streitz.cpp:  ftmp4 = etmp4 * (erfcr + 2.0/MY_PIS*a*r*derfcr);
pair_coul_streitz.cpp:  ftmp = ftmp3 - ftmp4/r;
pair_coul_streitz.cpp:/* ----------------------------------------------------------------------
pair_coul_streitz.cpp:------------------------------------------------------------------------- */
pair_coul_streitz.cpp:/* ---------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_coul_wolf.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ---------------------------------------------------------------------- */
pair_coul_wolf.cpp:  single_enable = 0;        // NOTE: single() method below is not yet correct
pair_coul_wolf.cpp:/* ---------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ---------------------------------------------------------------------- */
pair_coul_wolf.cpp:  // self and shifted coulombic energy
pair_coul_wolf.cpp:  e_shift = erfc(alf*cut_coul)/cut_coul;
pair_coul_wolf.cpp:  f_shift = -(e_shift+ 2.0*alf/MY_PIS * exp(-alf*alf*cut_coul*cut_coul)) /
pair_coul_wolf.cpp:  // loop over neighbors of my atoms
pair_coul_wolf.cpp:    e_self = -(e_shift/2.0 + alf/MY_PIS) * qisq*qqrd2e;
pair_coul_wolf.cpp:        prefactor = qqrd2e*qtmp*q[j]/r;
pair_coul_wolf.cpp:        dvdrr = (erfcc/rsq + 2.0*alf/MY_PIS * erfcd/r) + f_shift;
pair_coul_wolf.cpp:        fpair = forcecoul / rsq;
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:    error->all(FLERR,"Pair coul/wolf requires atom attribute q");
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:/* ----------------------------------------------------------------------
pair_coul_wolf.cpp:------------------------------------------------------------------------- */
pair_coul_wolf.cpp:  e_shift = erfc(alf*cut_coul) / cut_coul;
pair_coul_wolf.cpp:  f_shift = -(e_shift+ 2.0*alf/MY_PIS * exp(-alf*alf*cut_coul*cut_coul)) /
pair_coul_wolf.cpp:    prefactor = force->qqrd2e * atom->q[i]*atom->q[j]/r;
pair_coul_wolf.cpp:    dvdrr = (erfcc/rsq + 2.0*alf/MY_PIS * erfcd/r) + f_shift;
pair_coul_wolf.cpp:  fforce = forcecoul / rsq;
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:// allocate space for static class instance variable and initialize it
pair.cpp:/* ---------------------------------------------------------------------- */
pair.cpp:  // pair_modify settingsx
pair.cpp:  // KOKKOS per-fix data masks
pair.cpp:/* ---------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:    } else if (strcmp(arg[iarg],"table/disp") == 0) {
pair.cpp:    } else if (strcmp(arg[iarg],"tabinner/disp") == 0) {
pair.cpp:/* ---------------------------------------------------------------------- */
pair.cpp:  // for manybody potentials
pair.cpp:  // check if bonded exclusions could invalidate the neighbor list
pair.cpp:                     "bonds/angles/dihedrals and special_bond exclusions");
pair.cpp:  // I,I coeffs must be set
pair.cpp:  // init_one() will check if I,J is set explicitly or inferred by mixing
pair.cpp:  // style-specific initialization
pair.cpp:  // call init_one() for each I,J
pair.cpp:  // set cutsq for each I,J, used to neighbor
pair.cpp:  // cutforce = max of all I,J cutoffs
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:  // generalize this error message if reinit() is used by more than fix adapt
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:  // linear lookup tables of length N = 2^ncoultablebits
pair.cpp:  // stored value = value at lower edge of bin
pair.cpp:  // d values = delta from lower edge to upper edge of bin
pair.cpp:      egamma = 1.0 - (r/cut_coul)*force->kspace->gamma(r/cut_coul);
pair.cpp:      fgamma = 1.0 + (rsq_lookup.f/cut_coulsq)*
pair.cpp:        force->kspace->dgamma(r/cut_coul);
pair.cpp:      ctable[i] = qqrd2e/r;
pair.cpp:        ftable[i] = qqrd2e/r * fgamma;
pair.cpp:        etable[i] = qqrd2e/r * egamma;
pair.cpp:        ftable[i] = qqrd2e/r * (derfc + MY_ISPI4*grij*expm2);
pair.cpp:        etable[i] = qqrd2e/r * derfc;
pair.cpp:      ptable[i] = qqrd2e/r;
pair.cpp:        ftable[i] = qqrd2e/r * (fgamma - 1.0);
pair.cpp:        etable[i] = qqrd2e/r * egamma;
pair.cpp:        vtable[i] = qqrd2e/r * fgamma;
pair.cpp:        ftable[i] = qqrd2e/r * (derfc + MY_ISPI4*grij*expm2 - 1.0);
pair.cpp:        etable[i] = qqrd2e/r * derfc;
pair.cpp:        vtable[i] = qqrd2e/r * (derfc + MY_ISPI4*grij*expm2);
pair.cpp:          rsw = (r - cut_respa[2])/(cut_respa[3] - cut_respa[2]);
pair.cpp:          ftable[i] += qqrd2e/r * rsw*rsw*(3.0 - 2.0*rsw);
pair.cpp:          ctable[i] = qqrd2e/r * rsw*rsw*(3.0 - 2.0*rsw);
pair.cpp:          if (msmflag) ftable[i] = qqrd2e/r * fgamma;
pair.cpp:          else ftable[i] = qqrd2e/r * (derfc + MY_ISPI4*grij*expm2);
pair.cpp:          ctable[i] = qqrd2e/r;
pair.cpp:    drtable[i] = 1.0/(rtable[i+1] - rtable[i]);
pair.cpp:  // get the delta values for the last table entries
pair.cpp:  // tables are connected periodically between 0 and ntablem1
pair.cpp:  drtable[ntablem1] = 1.0/(rtable[0] - rtable[ntablem1]);
pair.cpp:  // get the correct delta values at itablemax
pair.cpp:  // smallest r is in bin itablemin
pair.cpp:  // largest r is in bin itablemax, which is itablemin-1,
pair.cpp:  //   or ntablem1 if itablemin=0
pair.cpp:  // deltas at itablemax only needed if corresponding rsq < cut*cut
pair.cpp:  // if so, compute deltas between rsq and cut*cut
pair.cpp:      egamma = 1.0 - (r/cut_coul)*force->kspace->gamma(r/cut_coul);
pair.cpp:      fgamma = 1.0 + (rsq_lookup.f/cut_coulsq)*
pair.cpp:        force->kspace->dgamma(r/cut_coul);
pair.cpp:      c_tmp = qqrd2e/r;
pair.cpp:        f_tmp = qqrd2e/r * fgamma;
pair.cpp:        e_tmp = qqrd2e/r * egamma;
pair.cpp:        f_tmp = qqrd2e/r * (derfc + MY_ISPI4*grij*expm2);
pair.cpp:        e_tmp = qqrd2e/r * derfc;
pair.cpp:      p_tmp = qqrd2e/r;
pair.cpp:        f_tmp = qqrd2e/r * (fgamma - 1.0);
pair.cpp:        e_tmp = qqrd2e/r * egamma;
pair.cpp:        v_tmp = qqrd2e/r * fgamma;
pair.cpp:        f_tmp = qqrd2e/r * (derfc + MY_ISPI4*grij*expm2 - 1.0);
pair.cpp:        e_tmp = qqrd2e/r * derfc;
pair.cpp:        v_tmp = qqrd2e/r * (derfc + MY_ISPI4*grij*expm2);
pair.cpp:          rsw = (r - cut_respa[2])/(cut_respa[3] - cut_respa[2]);
pair.cpp:          f_tmp += qqrd2e/r * rsw*rsw*(3.0 - 2.0*rsw);
pair.cpp:          c_tmp = qqrd2e/r * rsw*rsw*(3.0 - 2.0*rsw);
pair.cpp:          if (msmflag) f_tmp = qqrd2e/r * fgamma;
pair.cpp:          else f_tmp = qqrd2e/r * (derfc + MY_ISPI4*grij*expm2);
pair.cpp:          c_tmp = qqrd2e/r;
pair.cpp:    drtable[itablemax] = 1.0/(rsq_lookup.f - rtable[itablemax]);
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp: ------------------------------------------------------------------------- */
pair.cpp:  // linear lookup tables of length N = 2^ndisptablebits
pair.cpp:  // stored value = value at lower edge of bin
pair.cpp:  // d values = delta from lower edge to upper edge of bin
pair.cpp:    register double x2 = g2*rsq, a2 = 1.0/x2;
pair.cpp:    drdisptable[i] = 1.0/(rdisptable[i+1] - rdisptable[i]);
pair.cpp:  // get the delta values for the last table entries
pair.cpp:  // tables are connected periodically between 0 and ntablem1
pair.cpp:  drdisptable[ntablem1] = 1.0/(rdisptable[0] - rdisptable[ntablem1]);
pair.cpp:  // get the correct delta values at itablemax
pair.cpp:  // smallest r is in bin itablemin
pair.cpp:  // largest r is in bin itablemax, which is itablemin-1,
pair.cpp:  //   or ntablem1 if itablemin=0
pair.cpp:  // deltas at itablemax only needed if corresponding rsq < cut*cut
pair.cpp:  // if so, compute deltas between rsq and cut*cut
pair.cpp:    register double x2 = g2*rsq, a2 = 1.0/x2;
pair.cpp:    drdisptable[itablemax] = 1.0/(rsq_lookup.f - rdisptable[itablemax]);
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:  ------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:      pow(sig1,3.0) * pow(sig2,3.0) / (pow(sig1,6.0) + pow(sig2,6.0)));
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:    return pow((0.5 * (pow(sig1,6.0) + pow(sig2,6.0))),1.0/6.0);
pair.cpp:/* ---------------------------------------------------------------------- */
pair.cpp:/* -------------------------------------------------------------------
pair.cpp:---------------------------------------------------------------------- */
pair.cpp:/* -------------------------------------------------------------------
pair.cpp:---------------------------------------------------------------------- */
pair.cpp:  // compact the list of active computes
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:  eflag_atom = eflag / 2;
pair.cpp:  vflag_atom = vflag / 4;
pair.cpp:  // reallocate per-atom arrays if necessary
pair.cpp:  // zero accumulators
pair.cpp:  // use force->newton instead of newton_pair
pair.cpp:  //   b/c some bonds/dihedrals call pair::ev_tally with pairwise info
pair.cpp:  // if vflag_global = 2 and pair::compute() calls virial_fdotr_compute()
pair.cpp:  // compute global virial via (F dot r) instead of via pairwise summation
pair.cpp:  // unset other flags as appropriate
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp: ------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp: ------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp: ------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:   called by REAX/C potential, newton_pair is always on
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:  // sum over force on all particles including ghosts
pair.cpp:  // neighbor includegroup flag is set
pair.cpp:  // sum over force on initial nfirst particles and ghosts
pair.cpp:  // prevent multiple calls to update the virial
pair.cpp:  // when a hybrid pair style uses both a gpu and non-gpu pair style
pair.cpp:  // or when respa is used with gpu pair styles
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:   write a table of pair potential energy/force vs distance to a file
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:  // parse arguments
pair.cpp:  // open file in append mode
pair.cpp:  // print header in format used by pair_style table
pair.cpp:  // initialize potentials before evaluating pair potential
pair.cpp:  // insures all pair coeffs are set and force constants
pair.cpp:  // also initialize neighbor so that neighbor requests are processed
pair.cpp:  // NOTE: might be safest to just do lmp->init()
pair.cpp:  // if pair style = any of EAM, swap in dummy fp vector
pair.cpp:  // if atom style defines charge, swap in dummy q vec
pair.cpp:  // evaluate energy and force at each of N distances
pair.cpp:      r = inner + (outer-inner) * i/(n-1);
pair.cpp:      rsq = inner*inner + (outer*outer - inner*inner) * i/(n-1);
pair.cpp:  // restore original vecs that were swapped in for
pair.cpp:/* ----------------------------------------------------------------------
pair.cpp:------------------------------------------------------------------------- */
pair.cpp:    error->all(FLERR,"Bitmapped lookup tables require int/float be same size");
pair.cpp:  double required_range = outer*outer / pow(double(2),(double)nlowermin);
pair.cpp:/* ---------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_dpd.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ---------------------------------------------------------------------- */
pair_dpd.cpp:/* ---------------------------------------------------------------------- */
pair_dpd.cpp:/* ---------------------------------------------------------------------- */
pair_dpd.cpp:  double dtinvsqrt = 1.0/sqrt(update->dt);
pair_dpd.cpp:  // loop over neighbors of my atoms
pair_dpd.cpp:        if (r < EPSILON) continue;     // r can be 0.0 in DPD systems
pair_dpd.cpp:        rinv = 1.0/r;
pair_dpd.cpp:        wd = 1.0 - r/cut[itype][jtype];
pair_dpd.cpp:        // conservative force = a0 * wd
pair_dpd.cpp:        // drag force = -gamma * wd^2 * (delx dot delv) / r
pair_dpd.cpp:        // random force = sigma * wd * rnd * dtinvsqrt;
pair_dpd.cpp:          // unshifted eng of conservative term:
pair_dpd.cpp:          // evdwl = -a0[itype][jtype]*r * (1.0-0.5*r/cut[itype][jtype]);
pair_dpd.cpp:          // eng shifted to 0.0 at cutoff
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:  // initialize Marsaglia RNG with processor-unique seed
pair_dpd.cpp:  // reset cutoffs that have been explicitly set
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:  // if newton off, forces between atoms ij will be double computed
pair_dpd.cpp:  // using different random numbers
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:  // initialize Marsaglia RNG with processor-unique seed
pair_dpd.cpp:  // same seed that pair_style command initially specified
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ----------------------------------------------------------------------
pair_dpd.cpp:------------------------------------------------------------------------- */
pair_dpd.cpp:/* ---------------------------------------------------------------------- */
pair_dpd.cpp:  rinv = 1.0/r;
pair_dpd.cpp:  wd = 1.0 - r/cut[itype][jtype];
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_dpd_tstat.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_dpd_tstat.cpp:/* ---------------------------------------------------------------------- */
pair_dpd_tstat.cpp:/* ---------------------------------------------------------------------- */
pair_dpd_tstat.cpp:  // adjust sigma if target T is changing
pair_dpd_tstat.cpp:    if (delta != 0.0) delta /= update->endstep - update->beginstep;
pair_dpd_tstat.cpp:  double dtinvsqrt = 1.0/sqrt(update->dt);
pair_dpd_tstat.cpp:  // loop over neighbors of my atoms
pair_dpd_tstat.cpp:        if (r < EPSILON) continue;     // r can be 0.0 in DPD systems
pair_dpd_tstat.cpp:        rinv = 1.0/r;
pair_dpd_tstat.cpp:        wd = 1.0 - r/cut[itype][jtype];
pair_dpd_tstat.cpp:        // drag force = -gamma * wd^2 * (delx dot delv) / r
pair_dpd_tstat.cpp:        // random force = sigma * wd * rnd * dtinvsqrt;
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_dpd_tstat.cpp:  // initialize Marsaglia RNG with processor-unique seed
pair_dpd_tstat.cpp:  // reset cutoffs that have been explicitly set
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_dpd_tstat.cpp:  // initialize Marsaglia RNG with processor-unique seed
pair_dpd_tstat.cpp:  // same seed that pair_style command initially specified
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_dpd_tstat.cpp:/* ----------------------------------------------------------------------
pair_dpd_tstat.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_gauss.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ---------------------------------------------------------------------- */
pair_gauss.cpp:/* ---------------------------------------------------------------------- */
pair_gauss.cpp:/* ---------------------------------------------------------------------- */
pair_gauss.cpp:  // loop over neighbors of my atoms
pair_gauss.cpp:      // define a Gaussian well to be occupied if
pair_gauss.cpp:      // the site it interacts with is within the force maximum
pair_gauss.cpp:      if (eflag_global && rsq < 0.5/b[itype][jtype]) occ++;
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:  // reset cutoffs that have been explicitly set
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:    double si = sqrt(0.5/fabs(b[i][i]));
pair_gauss.cpp:    double sj = sqrt(0.5/fabs(b[j][j]));
pair_gauss.cpp:    b[i][j] = 0.5 / (sij*sij);
pair_gauss.cpp:    // Negative "a" values are useful for simulating repulsive particles.
pair_gauss.cpp:    // If either of the particles is repulsive (a<0), then the
pair_gauss.cpp:    // interaction between both is repulsive.
pair_gauss.cpp:  // cutoff correction to energy
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ----------------------------------------------------------------------
pair_gauss.cpp:------------------------------------------------------------------------- */
pair_gauss.cpp:/* ---------------------------------------------------------------------- */
pair_gauss.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_hybrid.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:  accumulate sub-style global/peratom energy/virial in hybrid
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // if no_virial_fdotr_compute is set and global component of
pair_hybrid.cpp:  //   incoming vflag = 2, then
pair_hybrid.cpp:  // reset vflag as if global component were 1
pair_hybrid.cpp:  // necessary since one or more sub-styles cannot compute virial as F dot r
pair_hybrid.cpp:  if (no_virial_fdotr_compute && vflag % 4 == 2) vflag = 1 + vflag/4 * 4;
pair_hybrid.cpp:  // check if global component of incoming vflag = 2
pair_hybrid.cpp:  // if so, reset vflag passed to substyle as if it were 0
pair_hybrid.cpp:  // necessary so substyle will not invoke virial_fdotr_compute()
pair_hybrid.cpp:  if (vflag % 4 == 2) vflag_substyle = vflag/4 * 4;
pair_hybrid.cpp:  // check if we are running with r-RESPA using the hybrid keyword
pair_hybrid.cpp:      // invoke compute() unless compute flag is turned off or
pair_hybrid.cpp:      // outerflag is set and sub-style has a compute_outer() method
pair_hybrid.cpp:    // jump to next sub-style if r-RESPA does not want global accumulated data
pair_hybrid.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // delete old lists, since cannot just change settings
pair_hybrid.cpp:  // allocate list of sub-styles as big as possibly needed if no extra args
pair_hybrid.cpp:  // allocate each sub-style
pair_hybrid.cpp:  // allocate uses suffix, but don't store suffix version in keywords,
pair_hybrid.cpp:  //   else syntax in coeff() will not match
pair_hybrid.cpp:  // call settings() with set of args that are not pair style names
pair_hybrid.cpp:  // use force->pair_map to determine which args these are
pair_hybrid.cpp:  // multiple[i] = 1 to M if sub-style used multiple times, else 0
pair_hybrid.cpp:  // set pair flags from sub-style flags
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // set comm_forward, comm_reverse, comm_reverse_off to max of any sub-style
pair_hybrid.cpp:  // single_enable = 1 if any sub-style is set
pair_hybrid.cpp:  // respa_enable = 1 if any sub-style is set
pair_hybrid.cpp:  // manybody_flag = 1 if any sub-style is set
pair_hybrid.cpp:  // no_virial_fdotr_compute = 1 if any sub-style is set
pair_hybrid.cpp:  // ghostneigh = 1 if any sub-style is set
pair_hybrid.cpp:  // ewaldflag, pppmflag, msmflag, dipoleflag, dispersionflag, tip4pflag = 1
pair_hybrid.cpp:  //   if any sub-style is set
pair_hybrid.cpp:  // compute_flag = 1 if any sub-style is set
pair_hybrid.cpp:  // single_extra = min of all sub-style single_extra
pair_hybrid.cpp:  // allocate svector
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // 3rd arg = pair sub-style name
pair_hybrid.cpp:  // 4th arg = pair sub-style index if name used multiple times
pair_hybrid.cpp:  // allow for "none" as valid sub-style name
pair_hybrid.cpp:  // move 1st/2nd args to 2nd/3rd args
pair_hybrid.cpp:  // if multflag: move 1st/2nd args to 3rd/4th args
pair_hybrid.cpp:  // just copy ptrs, since arg[] points into original input line
pair_hybrid.cpp:  // invoke sub-style coeff() starting with 1st remaining arg
pair_hybrid.cpp:  // if sub-style only allows one pair coeff call (with * * and type mapping)
pair_hybrid.cpp:  // then unset setflag/map assigned to that style before setting it below
pair_hybrid.cpp:  // in case pair coeff for this sub-style is being called for 2nd time
pair_hybrid.cpp:  // set setflag and which type pairs map to which sub-style
pair_hybrid.cpp:  // if sub-style is none: set hybrid setflag, wipe out map
pair_hybrid.cpp:  // else: set hybrid setflag & map only if substyle setflag is set
pair_hybrid.cpp:  //       previous mappings are wiped out
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // error if a sub-style is not used
pair_hybrid.cpp:  // check if special_lj/special_coul overrides are compatible
pair_hybrid.cpp:  // each sub-style makes its neighbor list request(s)
pair_hybrid.cpp:  // create skip lists inside each pair neigh request
pair_hybrid.cpp:  // any kind of list can have its skip flag set in this loop
pair_hybrid.cpp:    // istyle = associated sub-style for the request
pair_hybrid.cpp:    // allocate iskip and ijskip
pair_hybrid.cpp:    // initialize so as to skip all pair types
pair_hybrid.cpp:    // set ijskip = 0 if type pair matches any entry in sub-style map
pair_hybrid.cpp:    // set ijskip = 0 if mixing will assign type pair to this sub-style
pair_hybrid.cpp:    //   will occur if type pair is currently unassigned
pair_hybrid.cpp:    //   and both I,I and J,J are assigned to single sub-style
pair_hybrid.cpp:    //   and sub-style for both I,I and J,J match istyle
pair_hybrid.cpp:    // set iskip = 1 only if all ijskip for itype are 1
pair_hybrid.cpp:    // if any skipping occurs
pair_hybrid.cpp:    // set request->skip and copy iskip and ijskip into request
pair_hybrid.cpp:    // else delete iskip and ijskip
pair_hybrid.cpp:    // no skipping if pair style assigned to all type pairs
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // if I,J is not set explicitly:
pair_hybrid.cpp:  // perform mixing only if I,I sub-style = J,J sub-style
pair_hybrid.cpp:  // also require I,I and J,J are both assigned to single sub-style
pair_hybrid.cpp:  // call init/mixing for all sub-styles of I,J
pair_hybrid.cpp:  // set cutsq in sub-style just as Pair::init() does via call to init_one()
pair_hybrid.cpp:  // set cutghost for I,J and J,I just as sub-style does
pair_hybrid.cpp:  // sum tail corrections for I,J
pair_hybrid.cpp:  // return max cutoff of all sub-styles assigned to I,J
pair_hybrid.cpp:  // if no sub-styles assigned to I,J (pair_coeff none), cutmax = 0.0 returned
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // each sub-style writes its settings, but no coeff info
pair_hybrid.cpp:    // write out per style special settings, if present
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // allocate list of sub-styles
pair_hybrid.cpp:  // each sub-style is created via new_pair()
pair_hybrid.cpp:  // each reads its settings, but no coeff info
pair_hybrid.cpp:    // read back per style special settings, if present
pair_hybrid.cpp:  // multiple[i] = 1 to M if sub-style used multiple times, else 0
pair_hybrid.cpp:  // set pair flags from sub-style flags
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:      // copy substyle extra values into hybrid's svector
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  // if 1st keyword is pair, apply other keywords to one sub-style
pair_hybrid.cpp:    // if 2nd keyword (after pair) is special:
pair_hybrid.cpp:    // invoke modify_special() for the sub-style
pair_hybrid.cpp:    // if 2nd keyword (after pair) is compute/tally:
pair_hybrid.cpp:    // set flag to register USER-TALLY computes accordingly
pair_hybrid.cpp:    if (iarg < narg && strcmp(arg[iarg],"compute/tally") == 0) {
pair_hybrid.cpp:        error->all(FLERR,"Illegal pair_modify compute/tally command");
pair_hybrid.cpp:      } else error->all(FLERR,"Illegal pair_modify compute/tally command");
pair_hybrid.cpp:    // apply the remaining keywords to the base pair style itself and the
pair_hybrid.cpp:    // sub-style except for "pair" and "special".
pair_hybrid.cpp:    // the former is important for some keywords like "tail" or "compute"
pair_hybrid.cpp:  // apply all keywords to pair hybrid itself and every sub-style
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:  if (strcmp(arg[0],"lj/coul") == 0) {
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid.cpp:/* ----------------------------------------------------------------------
pair_hybrid.cpp:------------------------------------------------------------------------- */
pair_hybrid_overlay.cpp:/* ----------------------------------------------------------------------
pair_hybrid_overlay.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_hybrid_overlay.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_hybrid_overlay.cpp:------------------------------------------------------------------------- */
pair_hybrid_overlay.cpp:/* ---------------------------------------------------------------------- */
pair_hybrid_overlay.cpp:/* ----------------------------------------------------------------------
pair_hybrid_overlay.cpp:------------------------------------------------------------------------- */
pair_hybrid_overlay.cpp:  // 3rd arg = pair sub-style name
pair_hybrid_overlay.cpp:  // 4th arg = pair sub-style index if name used multiple times
pair_hybrid_overlay.cpp:  // allow for "none" as valid sub-style name
pair_hybrid_overlay.cpp:  // move 1st/2nd args to 2nd/3rd args
pair_hybrid_overlay.cpp:  // if multflag: move 1st/2nd args to 3rd/4th args
pair_hybrid_overlay.cpp:  // just copy ptrs, since arg[] points into original input line
pair_hybrid_overlay.cpp:  // invoke sub-style coeff() starting with 1st remaining arg
pair_hybrid_overlay.cpp:  // set setflag and which type pairs map to which sub-style
pair_hybrid_overlay.cpp:  // if sub-style is none: set hybrid subflag, wipe out map
pair_hybrid_overlay.cpp:  // else: set hybrid setflag & map only if substyle setflag is set
pair_hybrid_overlay.cpp:  //       if sub-style is new for type pair, add as multiple mapping
pair_hybrid_overlay.cpp:  //       if sub-style exists for type pair, don't add, just update coeffs
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj96_cut.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj96_cut.cpp:  // loop over neighbors of my atoms
pair_lj96_cut.cpp:        r2inv = 1.0/rsq;
pair_lj96_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj96_cut.cpp:  // loop over neighbors of my atoms
pair_lj96_cut.cpp:        r2inv = 1.0/rsq;
pair_lj96_cut.cpp:          rsw = (sqrt(rsq) - cut_out_on)/cut_out_diff;
pair_lj96_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj96_cut.cpp:  // loop over neighbors of my atoms
pair_lj96_cut.cpp:        r2inv = 1.0/rsq;
pair_lj96_cut.cpp:          rsw = (sqrt(rsq) - cut_in_off)/cut_in_diff;
pair_lj96_cut.cpp:          rsw = (sqrt(rsq) - cut_out_on)/cut_out_diff;
pair_lj96_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj96_cut.cpp:  // loop over neighbors of my atoms
pair_lj96_cut.cpp:          r2inv = 1.0/rsq;
pair_lj96_cut.cpp:            rsw = (sqrt(rsq) - cut_in_off)/cut_in_diff;
pair_lj96_cut.cpp:          r2inv = 1.0/rsq;
pair_lj96_cut.cpp:            r2inv = 1.0/rsq;
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:  // reset cutoffs that have been explicitly set
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:  // request regular or rRESPA neighbor lists
pair_lj96_cut.cpp:  // set rRESPA cutoffs
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:    double ratio = sigma[i][j] / cut[i][j];
pair_lj96_cut.cpp:  // check interior rRESPA cutoff
pair_lj96_cut.cpp:  // compute I,J contribution to long-range tail correction
pair_lj96_cut.cpp:  // count total # of atoms of type I and J via Allreduce
pair_lj96_cut.cpp:      sig6 * (sig3 - 2.0*rc3) / (6.0*rc6);
pair_lj96_cut.cpp:      sig6 * (3.0*sig3 - 4.0*rc3) / (6.0*rc6);
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ----------------------------------------------------------------------
pair_lj96_cut.cpp:------------------------------------------------------------------------- */
pair_lj96_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj96_cut.cpp:  r2inv = 1.0/rsq;
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_cubic.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cubic.cpp:  // loop over neighbors of my atoms
pair_lj_cubic.cpp:        r2inv = 1.0/rsq;
pair_lj_cubic.cpp:          t = (r - cut_inner[itype][jtype])/rmin;
pair_lj_cubic.cpp:          forcelj = epsilon[itype][jtype]*(-DPHIDS + A3*t*t/2.0)*r/rmin;
pair_lj_cubic.cpp:              (PHIS + DPHIDS*t - A3*t*t*t/6.0);
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:  // reset cutoffs that have been explicitly set
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ----------------------------------------------------------------------
pair_lj_cubic.cpp:------------------------------------------------------------------------- */
pair_lj_cubic.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cubic.cpp:  r2inv = 1.0/rsq;
pair_lj_cubic.cpp:    t = (r - cut_inner[itype][jtype])/rmin;
pair_lj_cubic.cpp:    forcelj = epsilon[itype][jtype]*(-DPHIDS + A3*t*t/2.0)*r/rmin;
pair_lj_cubic.cpp:      (PHIS + DPHIDS*t - A3*t*t*t/6.0);
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_cut_coul_cut.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:  // loop over neighbors of my atoms
pair_lj_cut_coul_cut.cpp:        r2inv = 1.0/rsq;
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:  // reset cutoffs that have been explicitly set
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:    error->all(FLERR,"Pair style lj/cut/coul/cut requires atom attribute q");
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:    double ratio = sigma[i][j] / cut_lj[i][j];
pair_lj_cut_coul_cut.cpp:  // compute I,J contribution to long-range tail correction
pair_lj_cut_coul_cut.cpp:  // count total # of atoms of type I and J via Allreduce
pair_lj_cut_coul_cut.cpp:      sig6 * (sig6 - 3.0*rc6) / (9.0*rc9);
pair_lj_cut_coul_cut.cpp:      sig6 * (2.0*sig6 - 3.0*rc6) / (9.0*rc9);
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_cut.cpp:  r2inv = 1.0/rsq;
pair_lj_cut_coul_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_debye.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_debye.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_cut_coul_debye.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_cut_coul_debye.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_debye.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_debye.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_debye.cpp:  // loop over neighbors of my atoms
pair_lj_cut_coul_debye.cpp:        r2inv = 1.0/rsq;
pair_lj_cut_coul_debye.cpp:          rinv = 1.0/r;
pair_lj_cut_coul_debye.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_debye.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_debye.cpp:  // reset cutoffs that were previously set from data file
pair_lj_cut_coul_debye.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_debye.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_debye.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_debye.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_debye.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_debye.cpp:  r2inv = 1.0/rsq;
pair_lj_cut_coul_debye.cpp:    rinv = 1.0/r;
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_cut_coul_dsf.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:  // loop over neighbors of my atoms
pair_lj_cut_coul_dsf.cpp:      double e_self = -(e_shift/2.0 + alpha/MY_PIS) * qtmp*qtmp*qqrd2e;
pair_lj_cut_coul_dsf.cpp:        r2inv = 1.0/rsq;
pair_lj_cut_coul_dsf.cpp:          prefactor = qqrd2e*qtmp*q[j]/r;
pair_lj_cut_coul_dsf.cpp:          t = 1.0 / (1.0 + EWALD_P*alpha*r);
pair_lj_cut_coul_dsf.cpp:          forcecoul = prefactor * (erfcc/r + 2.0*alpha/MY_PIS * erfcd +
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:  // reset cutoffs that have been explicitly set
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:    error->all(FLERR,"Pair style lj/cut/coul/dsf requires atom attribute q");
pair_lj_cut_coul_dsf.cpp:  f_shift = -(erfcc/cut_coulsq + 2.0/MY_PIS*alpha*erfcd/cut_coul);
pair_lj_cut_coul_dsf.cpp:  e_shift = erfcc/cut_coul - f_shift*cut_coul;
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:    double ratio = sigma[i][j] / cut_lj[i][j];
pair_lj_cut_coul_dsf.cpp:  // compute I,J contribution to long-range tail correction
pair_lj_cut_coul_dsf.cpp:  // count total # of atoms of type I and J via Allreduce
pair_lj_cut_coul_dsf.cpp:               sig6 * (sig6 - 3.0*rc6) / (9.0*rc9);
pair_lj_cut_coul_dsf.cpp:               sig6 * (2.0*sig6 - 3.0*rc6) / (9.0*rc9);
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ----------------------------------------------------------------------
pair_lj_cut_coul_dsf.cpp:------------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut_coul_dsf.cpp:  r2inv = 1.0/rsq;
pair_lj_cut_coul_dsf.cpp:    prefactor = factor_coul * force->qqrd2e * atom->q[i]*atom->q[j]/r;
pair_lj_cut_coul_dsf.cpp:    forcecoul = prefactor * (erfcc/r + 2.0*alpha/MY_PIS * erfcd +
pair_lj_cut_coul_dsf.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_cut.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut.cpp:  // loop over neighbors of my atoms
pair_lj_cut.cpp:        r2inv = 1.0/rsq;
pair_lj_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut.cpp:  // loop over neighbors of my atoms
pair_lj_cut.cpp:        r2inv = 1.0/rsq;
pair_lj_cut.cpp:          rsw = (sqrt(rsq) - cut_out_on)/cut_out_diff;
pair_lj_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut.cpp:  // loop over neighbors of my atoms
pair_lj_cut.cpp:        r2inv = 1.0/rsq;
pair_lj_cut.cpp:          rsw = (sqrt(rsq) - cut_in_off)/cut_in_diff;
pair_lj_cut.cpp:          rsw = (sqrt(rsq) - cut_out_on)/cut_out_diff;
pair_lj_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut.cpp:  // loop over neighbors of my atoms
pair_lj_cut.cpp:          r2inv = 1.0/rsq;
pair_lj_cut.cpp:            rsw = (sqrt(rsq) - cut_in_off)/cut_in_diff;
pair_lj_cut.cpp:          r2inv = 1.0/rsq;
pair_lj_cut.cpp:            r2inv = 1.0/rsq;
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:  // reset cutoffs that have been explicitly set
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:  // request regular or rRESPA neighbor lists
pair_lj_cut.cpp:  // set rRESPA cutoffs
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:    double ratio = sigma[i][j] / cut[i][j];
pair_lj_cut.cpp:  // check interior rRESPA cutoff
pair_lj_cut.cpp:  // compute I,J contribution to long-range tail correction
pair_lj_cut.cpp:  // count total # of atoms of type I and J via Allreduce
pair_lj_cut.cpp:      sig6 * (sig6 - 3.0*rc6) / (9.0*rc9);
pair_lj_cut.cpp:      sig6 * (2.0*sig6 - 3.0*rc6) / (9.0*rc9);
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ----------------------------------------------------------------------
pair_lj_cut.cpp:------------------------------------------------------------------------- */
pair_lj_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_cut.cpp:  r2inv = 1.0/rsq;
pair_lj_cut.cpp:/* ---------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_expand.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ---------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ---------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ---------------------------------------------------------------------- */
pair_lj_expand.cpp:  // loop over neighbors of my atoms
pair_lj_expand.cpp:        r2inv = 1.0/rshiftsq;
pair_lj_expand.cpp:        fpair = factor_lj*forcelj/rshift/r;
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:  // reset cutoffs that have been explicitly set
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:  // always mix shift arithmetically
pair_lj_expand.cpp:    double ratio = sigma[i][j] / cut[i][j];
pair_lj_expand.cpp:  // compute I,J contribution to long-range tail correction
pair_lj_expand.cpp:  // count total # of atoms of type I and J via Allreduce
pair_lj_expand.cpp:      ((1.0/9.0 + 2.0*shift1/(10.0*rc1) + shift2/(11.0*rc2))*sig6/rc9 -
pair_lj_expand.cpp:       (1.0/3.0 + 2.0*shift1/(4.0*rc1) + shift2/(5.0*rc2))/rc3);
pair_lj_expand.cpp:      ((1.0/9.0 + 3.0*shift1/(10.0*rc1) +
pair_lj_expand.cpp:	3.0*shift2/(11.0*rc2) + shift3/(12.0*rc3))*2.0*sig6/rc9 -
pair_lj_expand.cpp:       (1.0/3.0 + 3.0*shift1/(4.0*rc1) +
pair_lj_expand.cpp:	3.0*shift2/(5.0*rc2) + shift3/(6.0*rc3))/rc3);
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ----------------------------------------------------------------------
pair_lj_expand.cpp:------------------------------------------------------------------------- */
pair_lj_expand.cpp:/* ---------------------------------------------------------------------- */
pair_lj_expand.cpp:  r2inv = 1.0/rshiftsq;
pair_lj_expand.cpp:  fforce = factor_lj*forcelj/rshift/r;
pair_lj_expand.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_gromacs_coul_gromacs.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:  // loop over neighbors of my atoms
pair_lj_gromacs_coul_gromacs.cpp:        r2inv = 1.0/rsq;
pair_lj_gromacs_coul_gromacs.cpp:        // skip if qi or qj = 0.0 since this potential may be used as
pair_lj_gromacs_coul_gromacs.cpp:        // coarse-grain model with many uncharged atoms
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:               "Pair style lj/gromacs/coul/gromacs requires atom attribute q");
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:  double r6inv = 1.0/pow(cut_lj,6.0);
pair_lj_gromacs_coul_gromacs.cpp:  double r8inv = 1.0/pow(cut_lj,8.0);
pair_lj_gromacs_coul_gromacs.cpp:  double t2inv = 1.0/(t*t);
pair_lj_gromacs_coul_gromacs.cpp:  double t3inv = t2inv/t;
pair_lj_gromacs_coul_gromacs.cpp:  double t3 = 1.0/t3inv;
pair_lj_gromacs_coul_gromacs.cpp:  double c6 = r6inv - t3*(6.0*a6/3.0 + 6.0*b6*t/4.0);
pair_lj_gromacs_coul_gromacs.cpp:  double c12 = r6inv*r6inv - t3*(12.0*a12/3.0 + 12.0*b12*t/4.0);
pair_lj_gromacs_coul_gromacs.cpp:  ljsw3[i][j] = -lj3[i][j]*12.0*a12/3.0 + lj4[i][j]*6.0*a6/3.0;
pair_lj_gromacs_coul_gromacs.cpp:  ljsw4[i][j] = -lj3[i][j]*12.0*b12/4.0 + lj4[i][j]*6.0*b6/4.0;
pair_lj_gromacs_coul_gromacs.cpp:  double r3inv = 1.0/pow(cut_coul,3.0);
pair_lj_gromacs_coul_gromacs.cpp:  t2inv = 1.0/(t*t);
pair_lj_gromacs_coul_gromacs.cpp:  t3inv = t2inv/t;
pair_lj_gromacs_coul_gromacs.cpp:  coulsw3 = -a1/3.0;
pair_lj_gromacs_coul_gromacs.cpp:  coulsw4 = -b1/4.0;
pair_lj_gromacs_coul_gromacs.cpp:  coulsw5 = 1.0/cut_coul - t*t*t*(a1/3.0 + b1*t/4.0);
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs_coul_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs_coul_gromacs.cpp:  r2inv = 1.0/rsq;
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_gromacs.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs.cpp:  // loop over neighbors of my atoms
pair_lj_gromacs.cpp:        r2inv = 1.0/rsq;
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:  // reset cutoffs that have been explicitly set
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:  double r6inv = 1.0/pow(cut[i][j],6.0);
pair_lj_gromacs.cpp:  double r8inv = 1.0/pow(cut[i][j],8.0);
pair_lj_gromacs.cpp:  double t2inv = 1.0/(t*t);
pair_lj_gromacs.cpp:  double t3inv = t2inv/t;
pair_lj_gromacs.cpp:  double t3 = 1.0/t3inv;
pair_lj_gromacs.cpp:  double c6 = r6inv - t3*(6.0*a6/3.0 + 6.0*b6*t/4.0);
pair_lj_gromacs.cpp:  double c12 = r6inv*r6inv - t3*(12.0*a12/3.0 + 12.0*b12*t/4.0);
pair_lj_gromacs.cpp:  ljsw3[i][j] = -lj3[i][j]*12.0*a12/3.0 + lj4[i][j]*6.0*a6/3.0;
pair_lj_gromacs.cpp:  ljsw4[i][j] = -lj3[i][j]*12.0*b12/4.0 + lj4[i][j]*6.0*b6/4.0;
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ----------------------------------------------------------------------
pair_lj_gromacs.cpp:------------------------------------------------------------------------- */
pair_lj_gromacs.cpp:/* ---------------------------------------------------------------------- */
pair_lj_gromacs.cpp:  r2inv = 1.0/rsq;
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_smooth.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ---------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ---------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ---------------------------------------------------------------------- */
pair_lj_smooth.cpp:  // loop over neighbors of my atoms
pair_lj_smooth.cpp:        r2inv = 1.0/rsq;
pair_lj_smooth.cpp:              ljsw2[itype][jtype]*tsq/2.0 - ljsw3[itype][jtype]*tsq*t/3.0 -
pair_lj_smooth.cpp:              ljsw4[itype][jtype]*tsq*tsq/4.0 - offset[itype][jtype];
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:  // reset cutoffs that have been explicitly set
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:    double r6inv = 1.0/pow(cut_inner[i][j],6.0);
pair_lj_smooth.cpp:    double ratio = sigma[i][j] / cut_inner[i][j];
pair_lj_smooth.cpp:    ljsw1[i][j] = r6inv*(lj1[i][j]*r6inv-lj2[i][j]) / cut_inner[i][j];
pair_lj_smooth.cpp:    ljsw2[i][j] = -r6inv * (13.0*lj1[i][j]*r6inv - 7.0*lj2[i][j]) /
pair_lj_smooth.cpp:    ljsw3[i][j] = -(3.0/tsq) * (ljsw1[i][j] + 2.0/3.0*ljsw2[i][j]*t);
pair_lj_smooth.cpp:    ljsw4[i][j] = -1.0/(3.0*tsq) * (ljsw2[i][j] + 2.0*ljsw3[i][j]*t);
pair_lj_smooth.cpp:      offset[i][j] = ljsw0[i][j] - ljsw1[i][j]*t - ljsw2[i][j]*tsq/2.0 -
pair_lj_smooth.cpp:        ljsw3[i][j]*tsq*t/3.0 - ljsw4[i][j]*tsq*tsq/4.0;
pair_lj_smooth.cpp:    double ratio = sigma[i][j] / cut_inner[i][j];
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth.cpp:------------------------------------------------------------------------- */
pair_lj_smooth.cpp:/* ---------------------------------------------------------------------- */
pair_lj_smooth.cpp:  r2inv = 1.0/rsq;
pair_lj_smooth.cpp:      ljsw2[itype][jtype]*tsq/2.0 - ljsw3[itype][jtype]*tsq*t/3.0 -
pair_lj_smooth.cpp:      ljsw4[itype][jtype]*tsq*tsq/4.0 - offset[itype][jtype];
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_lj_smooth_linear.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ---------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ---------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ---------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:  // loop over neighbors of my atoms
pair_lj_smooth_linear.cpp:        r2inv = 1.0/rsq;
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:  // reset cutoffs that have been explicitly set
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:  double cutinv  = 1.0/cut[i][j];
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ----------------------------------------------------------------------
pair_lj_smooth_linear.cpp:------------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:/* ---------------------------------------------------------------------- */
pair_lj_smooth_linear.cpp:  r2inv = 1.0/rsq;
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_mie_cut.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ---------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ---------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ---------------------------------------------------------------------- */
pair_mie_cut.cpp:  // loop over neighbors of my atoms
pair_mie_cut.cpp:        r2inv = 1.0/rsq;
pair_mie_cut.cpp:        rgamA = pow(r2inv,(gamA[itype][jtype]/2.0));
pair_mie_cut.cpp:        rgamR = pow(r2inv,(gamR[itype][jtype]/2.0));
pair_mie_cut.cpp:/* ---------------------------------------------------------------------- */
pair_mie_cut.cpp:  // loop over neighbors of my atoms
pair_mie_cut.cpp:        r2inv = 1.0/rsq;
pair_mie_cut.cpp:        rgamA = pow(r2inv,(gamA[itype][jtype]/2.0));
pair_mie_cut.cpp:        rgamR = pow(r2inv,(gamR[itype][jtype]/2.0));
pair_mie_cut.cpp:          rsw = (sqrt(rsq) - cut_out_on)/cut_out_diff;
pair_mie_cut.cpp:/* ---------------------------------------------------------------------- */
pair_mie_cut.cpp:  // loop over neighbors of my atoms
pair_mie_cut.cpp:        r2inv = 1.0/rsq;
pair_mie_cut.cpp:        rgamA = pow(r2inv,(gamA[itype][jtype]/2.0));
pair_mie_cut.cpp:        rgamR = pow(r2inv,(gamR[itype][jtype]/2.0));
pair_mie_cut.cpp:          rsw = (sqrt(rsq) - cut_in_off)/cut_in_diff;
pair_mie_cut.cpp:          rsw = (sqrt(rsq) - cut_out_on)/cut_out_diff;
pair_mie_cut.cpp:/* ---------------------------------------------------------------------- */
pair_mie_cut.cpp:  // loop over neighbors of my atoms
pair_mie_cut.cpp:        r2inv = 1.0/rsq;
pair_mie_cut.cpp:        rgamA = pow(r2inv,(gamA[itype][jtype]/2.0));
pair_mie_cut.cpp:        rgamR = pow(r2inv,(gamR[itype][jtype]/2.0));
pair_mie_cut.cpp:            rsw = (sqrt(rsq) - cut_in_off)/cut_in_diff;
pair_mie_cut.cpp:          r2inv = 1.0/rsq;
pair_mie_cut.cpp:        rgamA = pow(r2inv,(gamA[itype][jtype]/2.0));
pair_mie_cut.cpp:        rgamR = pow(r2inv,(gamR[itype][jtype]/2.0));
pair_mie_cut.cpp:        r2inv = 1.0/rsq;
pair_mie_cut.cpp:        rgamA = pow(r2inv,(gamA[itype][jtype]/2.0));
pair_mie_cut.cpp:        rgamR = pow(r2inv,(gamR[itype][jtype]/2.0));
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:  // reset cutoffs that have been explicitly set
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:  // request regular or rRESPA neighbor lists
pair_mie_cut.cpp:  // set rRESPA cutoffs
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:  Cmie[i][j] = (gamR[i][j]/(gamR[i][j]-gamA[i][j]) *
pair_mie_cut.cpp:                pow((gamR[i][j]/gamA[i][j]),
pair_mie_cut.cpp:                    (gamA[i][j]/(gamR[i][j]-gamA[i][j]))));
pair_mie_cut.cpp:    double ratio = sigma[i][j] / cut[i][j];
pair_mie_cut.cpp:  // check interior rRESPA cutoff
pair_mie_cut.cpp:  // compute I,J contribution to long-range tail correction
pair_mie_cut.cpp:  // count total # of atoms of type I and J via Allreduce
pair_mie_cut.cpp:      (siggamR/((gamR[i][j]-3.0)*rcgamR)-siggamA/((gamA[i][j]-3.0)*rcgamA));
pair_mie_cut.cpp:    ptail_ij = Cmie[i][j]*2.0*MY_PI*all[0]*all[1]*epsilon[i][j]/3.0*
pair_mie_cut.cpp:      ((gamR[i][j]/(gamR[i][j]-3.0))*siggamR/rcgamR-
pair_mie_cut.cpp:       (gamA[i][j]/(gamA[i][j]-3.0))*siggamA/rcgamA);
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ----------------------------------------------------------------------
pair_mie_cut.cpp:------------------------------------------------------------------------- */
pair_mie_cut.cpp:/* ---------------------------------------------------------------------- */
pair_mie_cut.cpp:  r2inv = 1.0/rsq;
pair_mie_cut.cpp:  rgamA = pow(r2inv,(gamA[itype][jtype]/2.0));
pair_mie_cut.cpp:  rgamR = pow(r2inv,(gamR[itype][jtype]/2.0));
pair_mie_cut.cpp:/* ---------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_morse.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ---------------------------------------------------------------------- */
pair_morse.cpp:/* ---------------------------------------------------------------------- */
pair_morse.cpp:/* ---------------------------------------------------------------------- */
pair_morse.cpp:  // loop over neighbors of my atoms
pair_morse.cpp:        fpair = factor_lj * morse1[itype][jtype] * (dexp*dexp - dexp) / r;
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:  // reset cutoffs that have been explicitly set
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ----------------------------------------------------------------------
pair_morse.cpp:------------------------------------------------------------------------- */
pair_morse.cpp:/* ---------------------------------------------------------------------- */
pair_morse.cpp:  fforce = factor_lj * morse1[itype][jtype] * (dexp*dexp - dexp) / r;
pair_morse.cpp:/* ---------------------------------------------------------------------- */
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_soft.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ---------------------------------------------------------------------- */
pair_soft.cpp:/* ---------------------------------------------------------------------- */
pair_soft.cpp:/* ---------------------------------------------------------------------- */
pair_soft.cpp:  // loop over neighbors of my atoms
pair_soft.cpp:        arg = MY_PI*r/cut[itype][jtype];
pair_soft.cpp:                       sin(arg) * MY_PI/cut[itype][jtype]/r;
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:  // reset cutoffs that have been explicitly set
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:  // always mix prefactors geometrically
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ----------------------------------------------------------------------
pair_soft.cpp:------------------------------------------------------------------------- */
pair_soft.cpp:/* ---------------------------------------------------------------------- */
pair_soft.cpp:  arg = MY_PI*r/cut[itype][jtype];
pair_soft.cpp:    sin(arg) * MY_PI/cut[itype][jtype]/r;
pair_soft.cpp:/* ---------------------------------------------------------------------- */
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_spin.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:/* ---------------------------------------------------------------------- */
pair_spin.cpp:/* ---------------------------------------------------------------------- */
pair_spin.cpp:/* ---------------------------------------------------------------------- */
pair_spin.cpp:  // Pair spin computations
pair_spin.cpp:  // Loop over neighbors of my itoms
pair_spin.cpp:    //Loop on Neighbors
pair_spin.cpp:      rsq = delx*delx + dely*dely + delz*delz;  //square or inter-atomic distance
pair_spin.cpp:      rd = sqrt(rsq); //Inter-atomic distance
pair_spin.cpp:      //Exchange interaction
pair_spin.cpp:      //DM interaction
pair_spin.cpp:      //ME interaction
pair_spin.cpp:/* ---------------------------------------------------------------------- */
pair_spin.cpp:  ra = rsq/J_3[itype][jtype]/J_3[itype][jtype]; 
pair_spin.cpp:/* ---------------------------------------------------------------------- */
pair_spin.cpp:/* ---------------------------------------------------------------------- */
pair_spin.cpp:  inorm = 1.0/sqrt(rx*rx+ry*ry+rz*rz);
pair_spin.cpp: // printf("test val fmi=%g, fmj=%g \n",fmi[2],fmj[2]);
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:    error->all(FLERR,"Incorrect number of args in pair_style pair/spin command");
pair_spin.cpp:  // reset cutoffs that have been explicitly set
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:    double hbar = force->hplanck/MY_2PI;
pair_spin.cpp:    J1 /= hbar;
pair_spin.cpp:    double inorm = 1.0/(dmx*dmx+dmy*dmy+dmz*dmz);
pair_spin.cpp:    double hbar = force->hplanck/MY_2PI;
pair_spin.cpp:    dm /= hbar;
pair_spin.cpp:    double inorm = 1.0/(mex*mex+mey*mey+mez*mez);
pair_spin.cpp:    double hbar = force->hplanck/MY_2PI;
pair_spin.cpp:    me /= hbar;
pair_spin.cpp:  //Check if Jex [][] still works for Ferrimagnetic exchange  
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_spin.cpp:/* ----------------------------------------------------------------------
pair_spin.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_table.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ---------------------------------------------------------------------- */
pair_table.cpp:/* ---------------------------------------------------------------------- */
pair_table.cpp:/* ---------------------------------------------------------------------- */
pair_table.cpp:  // loop over neighbors of my atoms
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:  // new settings
pair_table.cpp:  // optional keywords
pair_table.cpp:  // assert the tabulation is compatible with a specific long-range solver
pair_table.cpp:  // delete old tables, since cannot just change settings
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:  // set table cutoff
pair_table.cpp:  // error check on table parameters
pair_table.cpp:  // insure cutoff is within table
pair_table.cpp:  // for BITMAP tables, file values can be in non-ascending order
pair_table.cpp:  // match = 1 if don't need to spline read-in tables
pair_table.cpp:  // this is only the case if r values needed by final tables
pair_table.cpp:  //   exactly match r values read from file
pair_table.cpp:  // for tabstyle SPLINE, always need to build spline tables
pair_table.cpp:  // spline read-in values and compute r,e,f vectors within table
pair_table.cpp:  // store ptr to table in tabindex
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:  // open file
pair_table.cpp:  // loop until section found with matching keyword
pair_table.cpp:    if (strspn(line," \t\n\r") == strlen(line)) continue;  // blank line
pair_table.cpp:    if (line[0] == '#') continue;                          // comment
pair_table.cpp:    if (strcmp(word,keyword) == 0) break;           // matching keyword
pair_table.cpp:    fgets(line,MAXLINE,fp);                         // no match, skip section
pair_table.cpp:  // read args on 2nd line of section
pair_table.cpp:  // allocate table arrays for file values
pair_table.cpp:  // setup bitmap parameters for table to read in
pair_table.cpp:  // read r,e,f table values from file
pair_table.cpp:  // if rflag set, compute r
pair_table.cpp:  // if rflag not set, use r from file
pair_table.cpp:      rnew = tb->rlo + (tb->rhi - tb->rlo)*i/(tb->ninput-1);
pair_table.cpp:        (tb->rhi*tb->rhi - tb->rlo*tb->rlo)*i/(tb->ninput-1);
pair_table.cpp:    if (tb->rflag && fabs(rnew-rfile)/rfile > EPSILONR) rerror++;
pair_table.cpp:  // close file
pair_table.cpp:  // warn if force != dE/dr at any point that is not an inflection point
pair_table.cpp:  // check via secant approximation to dE/dr
pair_table.cpp:  // skip two end points since do not have surrounding secants
pair_table.cpp:  // inflection point is where curvature changes sign
pair_table.cpp:    fleft = - (e-eprev) / (r-rprev);
pair_table.cpp:    fright = - (enext-e) / (rnext-r);
pair_table.cpp:    //printf("Values %d: %g %g %g\n",i,r,e,f);
pair_table.cpp:    //printf("  secant %d %d %g: %g %g %g\n",i,ferror,r,fleft,fright,f);
pair_table.cpp:    sprintf(str,"%d of %d force values in table are inconsistent with -dE/dr.\n"
pair_table.cpp:  // warn if re-computed distance values differ from file values
pair_table.cpp:  // warn if data was read incompletely, e.g. columns were missing
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:    tb->fplo = (tb->ffile[1] - tb->ffile[0]) / (tb->rfile[1] - tb->rfile[0]);
pair_table.cpp:    tb->fphi = (tb->ffile[tb->ninput-1] - tb->ffile[tb->ninput-2]) /
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:   format of line: N value R/RSQ/BITMAP lo hi FPRIME fplo fphi
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:  // inner = inner table bound
pair_table.cpp:  // cut = outer table bound
pair_table.cpp:  // delta = table spacing in rsq for N-1 bins
pair_table.cpp:  tb->delta = (tb->cut*tb->cut - tb->innersq) / tlm1;
pair_table.cpp:  tb->invdelta = 1.0/tb->delta;
pair_table.cpp:  // direct lookup tables
pair_table.cpp:  // N-1 evenly spaced bins in rsq from inner to cut
pair_table.cpp:  // e,f = value at midpt of bin
pair_table.cpp:  // e,f are N-1 in length since store 1 value at bin midpt
pair_table.cpp:  // f is converted to f/r when stored in f[i]
pair_table.cpp:  // e,f are never a match to read-in values, always computed via spline interp
pair_table.cpp:      tb->f[i] = splint(tb->rfile,tb->ffile,tb->f2file,tb->ninput,r)/r;
pair_table.cpp:  // linear tables
pair_table.cpp:  // N-1 evenly spaced bins in rsq from inner to cut
pair_table.cpp:  // rsq,e,f = value at lower edge of bin
pair_table.cpp:  // de,df values = delta from lower edge to upper edge of bin
pair_table.cpp:  // rsq,e,f are N in length so de,df arrays can compute difference
pair_table.cpp:  // f is converted to f/r when stored in f[i]
pair_table.cpp:  // e,f can match read-in values, else compute via spline interp
pair_table.cpp:        tb->f[i] = tb->ffile[i]/r;
pair_table.cpp:        tb->f[i] = splint(tb->rfile,tb->ffile,tb->f2file,tb->ninput,r)/r;
pair_table.cpp:  // cubic spline tables
pair_table.cpp:  // N-1 evenly spaced bins in rsq from inner to cut
pair_table.cpp:  // rsq,e,f = value at lower edge of bin
pair_table.cpp:  // e2,f2 = spline coefficient for each bin
pair_table.cpp:  // rsq,e,f,e2,f2 are N in length so have N-1 spline bins
pair_table.cpp:  // f is converted to f/r after e is splined
pair_table.cpp:  // e,f can match read-in values, else compute via spline interp
pair_table.cpp:    tb->deltasq6 = tb->delta*tb->delta / 6.0;
pair_table.cpp:        tb->f[i] = tb->ffile[i]/r;
pair_table.cpp:    // ep0,epn = dh/dg at inner and at cut
pair_table.cpp:    // h(r) = e(r) and g(r) = r^2
pair_table.cpp:    // dh/dg = (de/dr) / 2r = -f/2r
pair_table.cpp:    double ep0 = - tb->f[0] / (2.0 * sqrt(tb->innersq));
pair_table.cpp:    double epn = - tb->f[tlm1] / (2.0 * tb->cut);
pair_table.cpp:    // fp0,fpn = dh/dg at inner and at cut
pair_table.cpp:    // h(r) = f(r)/r and g(r) = r^2
pair_table.cpp:    // dh/dg = (1/r df/dr - f/r^2) / 2r
pair_table.cpp:    // dh/dg in secant approx = (f(r2)/r2 - f(r1)/r1) / (g(r2) - g(r1))
pair_table.cpp:    if (tb->fpflag) fp0 = (tb->fplo/sqrt(tb->innersq) - tb->f[0]/tb->innersq) /
pair_table.cpp:      fp0 = (splint(tb->rfile,tb->ffile,tb->f2file,tb->ninput,sqrt(rsq2)) /
pair_table.cpp:             sqrt(rsq2) - tb->f[0] / sqrt(rsq1)) / (secant_factor*tb->delta);
pair_table.cpp:      (tb->fphi/tb->cut - tb->f[tlm1]/(tb->cut*tb->cut)) / (2.0 * tb->cut);
pair_table.cpp:      fpn = (tb->f[tlm1] / sqrt(rsq2) -
pair_table.cpp:             splint(tb->rfile,tb->ffile,tb->f2file,tb->ninput,sqrt(rsq1)) /
pair_table.cpp:             sqrt(rsq1)) / (secant_factor*tb->delta);
pair_table.cpp:    for (int i = 0; i < tablength; i++) tb->f[i] /= sqrt(tb->rsq[i]);
pair_table.cpp:  // bitmapped linear tables
pair_table.cpp:  // 2^N bins from inner to cut, spaced in bitmapped manner
pair_table.cpp:  // f is converted to f/r when stored in f[i]
pair_table.cpp:  // e,f can match read-in values, else compute via spline interp
pair_table.cpp:    // linear lookup tables of length ntable = 2^n
pair_table.cpp:    // stored value = value at lower edge of bin
pair_table.cpp:        tb->f[i] = tb->ffile[i]/r;
pair_table.cpp:        tb->f[i] = splint(tb->rfile,tb->ffile,tb->f2file,tb->ninput,r)/r;
pair_table.cpp:      tb->drsq[i] = 1.0/(tb->rsq[i+1] - tb->rsq[i]);
pair_table.cpp:    // get the delta values for the last table entries
pair_table.cpp:    // tables are connected periodically between 0 and ntablem1
pair_table.cpp:    tb->drsq[ntablem1] = 1.0/(tb->rsq[0] - tb->rsq[ntablem1]);
pair_table.cpp:    // get the correct delta values at itablemax
pair_table.cpp:    // smallest r is in bin itablemin
pair_table.cpp:    // largest r is in bin itablemax, which is itablemin-1,
pair_table.cpp:    //   or ntablem1 if itablemin=0
pair_table.cpp:    // deltas at itablemax only needed if corresponding rsq < cut*cut
pair_table.cpp:    // if so, compute deltas between rsq and cut*cut
pair_table.cpp:    //   if tb->match, data at cut*cut is unavailable, so we'll take
pair_table.cpp:    //   deltas at itablemax-1 as a good approximation
pair_table.cpp:        f_tmp = splint(tb->rfile,tb->ffile,tb->f2file,tb->ninput,r)/r;
pair_table.cpp:        tb->drsq[itablemax] = 1.0/(rsq_lookup.f - tb->rsq[itablemax]);
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:    u[0] = (3.0/(x[1]-x[0])) * ((y[1]-y[0]) / (x[1]-x[0]) - yp1);
pair_table.cpp:    sig = (x[i]-x[i-1]) / (x[i+1]-x[i-1]);
pair_table.cpp:    y2[i] = (sig-1.0) / p;
pair_table.cpp:    u[i] = (y[i+1]-y[i]) / (x[i+1]-x[i]) - (y[i]-y[i-1]) / (x[i]-x[i-1]);
pair_table.cpp:    u[i] = (6.0*u[i] / (x[i+1]-x[i-1]) - sig*u[i-1]) / p;
pair_table.cpp:    un = (3.0/(x[n-1]-x[n-2])) * (ypn - (y[n-1]-y[n-2]) / (x[n-1]-x[n-2]));
pair_table.cpp:  y2[n-1] = (un-qn*u[n-2]) / (qn*y2[n-2] + 1.0);
pair_table.cpp:/* ---------------------------------------------------------------------- */
pair_table.cpp:  a = (xa[khi]-x) / h;
pair_table.cpp:  b = (x-xa[klo]) / h;
pair_table.cpp:    ((a*a*a-a)*y2a[klo] + (b*b*b-b)*y2a[khi]) * (h*h)/6.0;
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_table.cpp:/* ---------------------------------------------------------------------- */
pair_table.cpp:/* ----------------------------------------------------------------------
pair_table.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_yukawa.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ---------------------------------------------------------------------- */
pair_yukawa.cpp:/* ---------------------------------------------------------------------- */
pair_yukawa.cpp:/* ---------------------------------------------------------------------- */
pair_yukawa.cpp:  // loop over neighbors of my atoms
pair_yukawa.cpp:        r2inv = 1.0/rsq;
pair_yukawa.cpp:        rinv = 1.0/r;
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:  // reset cutoffs that have been explicitly set
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:    offset[i][j] = a[i][j] * screening / cut[i][j];
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ----------------------------------------------------------------------
pair_yukawa.cpp:------------------------------------------------------------------------- */
pair_yukawa.cpp:/* ---------------------------------------------------------------------- */
pair_yukawa.cpp:  r2inv = 1.0/rsq;
pair_yukawa.cpp:  rinv = 1.0/r;
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_zbl.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:// From J.F. Zeigler, J. P. Biersack and U. Littmark,
pair_zbl.cpp:// "The Stopping and Range of Ions in Matter" volume 1, Pergamon, 1985.
pair_zbl.cpp:/* ---------------------------------------------------------------------- */
pair_zbl.cpp:/* ---------------------------------------------------------------------- */
pair_zbl.cpp:/* ---------------------------------------------------------------------- */
pair_zbl.cpp:  // loop over neighbors of my atoms
pair_zbl.cpp:        fpair *= -1.0/r;
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:  // set flag for each i-j pair
pair_zbl.cpp:  // set z-parameter only for i-i pairs
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:/* ---------------------------------------------------------------------- */
pair_zbl.cpp:  fforce *= -1.0/r;
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:  double rinv = 1.0/r;
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:  double rinv = 1.0/r;
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:  double rinv = 1.0/r;
pair_zbl.cpp:/* ----------------------------------------------------------------------
pair_zbl.cpp:------------------------------------------------------------------------- */
pair_zbl.cpp:  double ainv = (pow(zi,pzbl) + pow(zj,pzbl))/(a0*force->angstrom);
pair_zbl.cpp:  // e =  t^3 (sw3 + sw4*t) + sw5
pair_zbl.cpp:  //   = A/3*t^3 + B/4*t^4 + C
pair_zbl.cpp:  // sw3 = A/3
pair_zbl.cpp:  // sw4 = B/4
pair_zbl.cpp:  // sw5 = C
pair_zbl.cpp:  // dedr = t^2 (sw1 + sw2*t)
pair_zbl.cpp:  //      = A*t^2 + B*t^3
pair_zbl.cpp:  // sw1 = A
pair_zbl.cpp:  // sw2 = B
pair_zbl.cpp:  // de2dr2 = 2*A*t + 3*B*t^2
pair_zbl.cpp:  // Require that at t = tc:
pair_zbl.cpp:  // e = -Fc
pair_zbl.cpp:  // dedr = -Fc'
pair_zbl.cpp:  // d2edr2 = -Fc''
pair_zbl.cpp:  // Hence:
pair_zbl.cpp:  // A = (-3Fc' + tc*Fc'')/tc^2
pair_zbl.cpp:  // B = ( 2Fc' - tc*Fc'')/tc^3
pair_zbl.cpp:  // C = -Fc + tc/2*Fc' - tc^2/12*Fc''
pair_zbl.cpp:  double swa = (-3.0*fcp + tc*fcpp)/(tc*tc);
pair_zbl.cpp:  double swb = ( 2.0*fcp - tc*fcpp)/(tc*tc*tc);
pair_zbl.cpp:  double swc = -fc + (tc/2.0)*fcp - (tc*tc/12.0)*fcpp;
pair_zbl.cpp:  sw3[i][j] = swa/3.0;
pair_zbl.cpp:  sw4[i][j] = swb/4.0;
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
pair_zero.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ---------------------------------------------------------------------- */
pair_zero.cpp:/* ---------------------------------------------------------------------- */
pair_zero.cpp:/* ---------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:  // reset cutoffs that have been explicitly set
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
pair_zero.cpp:/* ----------------------------------------------------------------------
pair_zero.cpp:------------------------------------------------------------------------- */
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
procmap.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:enum{MULTIPLE};                   // same as in Comm
procmap.cpp:/* ---------------------------------------------------------------------- */
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // factors = list of all possible 3 factors of processor count
procmap.cpp:  // constrain by 2d, user request, other partition
procmap.cpp:  // user/other constraints make failure possible
procmap.cpp:  // select best set of 3 factors based on surface area of proc sub-domains
procmap.cpp:  // clean-up
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // nfactors = list of all possible 3 factors of node count
procmap.cpp:  // constrain by 2d
procmap.cpp:  int nnpossible = factor(nprocs/ncores,NULL);
procmap.cpp:  nnpossible = factor(nprocs/ncores,nfactors);
procmap.cpp:  // cfactors = list of all possible 3 factors of core count
procmap.cpp:  // constrain by 2d
procmap.cpp:  // factors = all combinations of nfactors and cfactors
procmap.cpp:  // factors stores additional index pointing to corresponding cfactors
procmap.cpp:  // constrain by user request, other partition
procmap.cpp:  // user/other constraints make failure possible
procmap.cpp:  // select best set of 3 factors based on surface area of proc sub-domains
procmap.cpp:  // index points to corresponding core factorization
procmap.cpp:  // clean-up
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // hardwire this for now
procmap.cpp:  // get names of all nodes
procmap.cpp:  // get number of procs per node
procmap.cpp:  // NOTE: could do this without STL map
procmap.cpp:  procs_per_numa = procs_per_node / numa_nodes;
procmap.cpp:  // error if any of these conditions met
procmap.cpp:  if (nprocs % procs_per_numa ||       // total procs not a multiple of node
procmap.cpp:      user_procgrid[0] > 1 ||          // user specified grid > 1 in any dim
procmap.cpp:  // user settings for the factorization per numa node
procmap.cpp:  // currently not user settable
procmap.cpp:  // if user specifies 1 for a proc grid dimension,
procmap.cpp:  // also use 1 for the numa grid dimension
procmap.cpp:  // initial factorization within NUMA node
procmap.cpp:  // user_nodegrid = implied user constraints on nodes
procmap.cpp:  user_nodegrid[0] = user_procgrid[0] / numagrid[0];
procmap.cpp:  user_nodegrid[1] = user_procgrid[1] / numagrid[1];
procmap.cpp:  user_nodegrid[2] = user_procgrid[2] / numagrid[2];
procmap.cpp:  // factorization for the grid of NUMA nodes
procmap.cpp:  int node_count = nprocs / procs_per_numa;
procmap.cpp:  // repeat NUMA node factorization using subdomain sizes
procmap.cpp:  // refines the factorization if the user specified the node layout
procmap.cpp:  // NOTE: this will not re-enforce user-procgrid constraint will it?
procmap.cpp:  // assign a unique id to each node
procmap.cpp:  // return the proc-level factorization
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:    // skip header = blank and comment lines
procmap.cpp:  // cmap = map of procs to grid
procmap.cpp:  // store for use in custom_map()
procmap.cpp:  // error check on cmap values
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // setup NUMA params that numa_grid() sets up
procmap.cpp:  node_id = me/ncores;
procmap.cpp:  nodegrid[0] = procgrid[0] / coregrid[0];
procmap.cpp:  nodegrid[1] = procgrid[1] / coregrid[1];
procmap.cpp:  nodegrid[2] = procgrid[2] / coregrid[2];
procmap.cpp:  // now can use numa_map() to perform mapping
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // proc IDs of neighbors
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  nodegrid[0] = procgrid[0] / coregrid[0];
procmap.cpp:  nodegrid[1] = procgrid[1] / coregrid[1];
procmap.cpp:  nodegrid[2] = procgrid[2] / coregrid[2];
procmap.cpp:        inode = i/coregrid[0];
procmap.cpp:        jnode = j/coregrid[1];
procmap.cpp:        knode = k/coregrid[2];
procmap.cpp:  // proc IDs of neighbors
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // setup a per node communicator and find rank within
procmap.cpp:  // setup a per numa communicator and find rank within
procmap.cpp:  int local_numa = node_rank / procs_per_numa;
procmap.cpp:  // setup a communicator with the rank 0 procs from each numa node
procmap.cpp:  // use the MPI Cartesian routines to map the nodes to the grid
procmap.cpp:  // broadcast numa node location in grid to other procs in numa node
procmap.cpp:  // compute my location within the node grid
procmap.cpp:  int z_offset = numa_rank / (numagrid[0] * numagrid[1]);
procmap.cpp:  int y_offset = (numa_rank % (numagrid[0] * numagrid[1]))/numagrid[0];
procmap.cpp:  // allgather of myloc into gridi to fill grid2proc
procmap.cpp:  // proc IDs of neighbors
procmap.cpp:  // clean-up
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // proc IDs of neighbors
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // find me in the grid
procmap.cpp:  // polled comm of grid mapping info from each proc to proc 0
procmap.cpp:  // close output file
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:    nyz = n/i;
procmap.cpp:        factors[m][2] = nyz/j;
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:              where Nx,Ny,Nz = node grid = procgrid/coregrid
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:      if ((other_procgrid[0]/other_coregrid[0]) % factors[i][0]) flag = 1;
procmap.cpp:      if ((other_procgrid[1]/other_coregrid[1]) % factors[i][1]) flag = 1;
procmap.cpp:      if ((other_procgrid[2]/other_coregrid[2]) % factors[i][2]) flag = 1;
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
procmap.cpp:  // determine cross-sectional areas for orthogonal and triclinic boxes
procmap.cpp:  // for triclinic, area = cross product of 2 edge vectors stored in h matrix
procmap.cpp:  // area[3] = surface area 3 box faces divided by sx,sy,sz
procmap.cpp:  // area[0] = xy, area[1] = xz, area[2] = yz
procmap.cpp:    area[0] = domain->xprd * domain->yprd / (sx*sy);
procmap.cpp:    area[1] = domain->xprd * domain->zprd / (sx*sz);
procmap.cpp:    area[2] = domain->yprd * domain->zprd / (sy*sz);
procmap.cpp:    area[0] = sqrt(c[0]*c[0] + c[1]*c[1] + c[2]*c[2]) / (sx*sy);
procmap.cpp:    area[1] = sqrt(c[0]*c[0] + c[1]*c[1] + c[2]*c[2]) / (sx*sz);
procmap.cpp:    area[2] = sqrt(c[0]*c[0] + c[1]*c[1] + c[2]*c[2]) / (sy*sz);
procmap.cpp:    surf = area[0]/factors[m][0]/factors[m][1] +
procmap.cpp:      area[1]/factors[m][0]/factors[m][2] +
procmap.cpp:      area[2]/factors[m][1]/factors[m][2];
procmap.cpp:/* ----------------------------------------------------------------------
procmap.cpp:------------------------------------------------------------------------- */
python.cpp:/* ----------------------------------------------------------------------
python.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
python.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
python.cpp:------------------------------------------------------------------------- */
python.cpp:/* ---------------------------------------------------------------------- */
python.cpp:  // implementation of Python interface is only loaded on demand
python.cpp:  // and only if PYTHON package has been installed and compiled into binary
python.cpp:/* ---------------------------------------------------------------------- */
python.cpp:/* ---------------------------------------------------------------------- */
python.cpp:/* ---------------------------------------------------------------------- */
python.cpp:/* ---------------------------------------------------------------------- */
python.cpp:/* ---------------------------------------------------------------------- */
python.cpp:/* ------------------------------------------------------------------ */
python.cpp:/* ------------------------------------------------------------------ */
python.cpp:/* ------------------------------------------------------------------ */
python.cpp:/* ------------------------------------------------------------------ */
random_mars.cpp:/* ----------------------------------------------------------------------
random_mars.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
random_mars.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
random_mars.cpp:------------------------------------------------------------------------- */
random_mars.cpp:// Marsaglia random number generator
random_mars.cpp:// see RANMAR in F James, Comp Phys Comm, 60, 329 (1990)
random_mars.cpp:/* ---------------------------------------------------------------------- */
random_mars.cpp:  ij = (seed-1)/30082;
random_mars.cpp:  i = (ij/177) % 177 + 2;
random_mars.cpp:  k = (kl/169) % 178 + 1;
random_mars.cpp:  c = 362436.0 / 16777216.0;
random_mars.cpp:  cd = 7654321.0 / 16777216.0;
random_mars.cpp:  cm = 16777213.0 / 16777216.0;
random_mars.cpp:/* ---------------------------------------------------------------------- */
random_mars.cpp:/* ----------------------------------------------------------------------
random_mars.cpp:------------------------------------------------------------------------- */
random_mars.cpp:/* ----------------------------------------------------------------------
random_mars.cpp:------------------------------------------------------------------------- */
random_mars.cpp:    fac = sqrt(-2.0*log(rsq)/rsq);
random_park.cpp:/* ----------------------------------------------------------------------
random_park.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
random_park.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
random_park.cpp:------------------------------------------------------------------------- */
random_park.cpp:// Park/Miller RNG
random_park.cpp:#define AM (1.0/IM)
random_park.cpp:/* ---------------------------------------------------------------------- */
random_park.cpp:/* ----------------------------------------------------------------------
random_park.cpp:------------------------------------------------------------------------- */
random_park.cpp:  int k = seed/IQ;
random_park.cpp:/* ----------------------------------------------------------------------
random_park.cpp:------------------------------------------------------------------------- */
random_park.cpp:    fac = sqrt(-2.0*log(rsq)/rsq);
random_park.cpp:/* ---------------------------------------------------------------------- */
random_park.cpp:/* ----------------------------------------------------------------------
random_park.cpp:------------------------------------------------------------------------- */
random_park.cpp:  // keep 31 bits of unsigned int as new seed
random_park.cpp:  // do not allow seed = 0, since will cause hang in gaussian()
random_park.cpp:  // warm up the RNG
random_park.cpp:/* ---------------------------------------------------------------------- */
rcb.cpp:/* ----------------------------------------------------------------------
rcb.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
rcb.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
rcb.cpp:------------------------------------------------------------------------- */
rcb.cpp:// prototypes for non-class functions
rcb.cpp:// NOTE: if want to have reuse flag, need to sum Tree across procs
rcb.cpp:/* ---------------------------------------------------------------------- */
rcb.cpp:  // create MPI data and function types for box and median AllReduce ops
rcb.cpp:/* ---------------------------------------------------------------------- */
rcb.cpp:/* ----------------------------------------------------------------------
rcb.cpp:   perform RCB balancing of N particles at coords X in bounding box LO/HI
rcb.cpp:     defined by final lo/hi
rcb.cpp:   // NOTE: worry about re-use of data structs for fix balance?
rcb.cpp:------------------------------------------------------------------------- */
rcb.cpp:  // create list of my Dots
rcb.cpp:  // initial bounding box = simulation box
rcb.cpp:  // includes periodic or shrink-wrapped boundaries
rcb.cpp:  // initialize counters
rcb.cpp:  // create communicator for use in recursion
rcb.cpp:  // recurse until partition is a single proc = me
rcb.cpp:  // proclower,procupper = lower,upper procs in partition
rcb.cpp:  // procmid = 1st proc in upper half of partition
rcb.cpp:    // if odd # of procs, lower partition gets extra one
rcb.cpp:    procmid = proclower + (procupper - proclower) / 2 + 1;
rcb.cpp:    // determine communication partner(s)
rcb.cpp:    // readnumber = # of proc partners to read from
rcb.cpp:    // wttot = summed weight of entire partition
rcb.cpp:    // search tolerance = largest single weight (plus epsilon)
rcb.cpp:    // targetlo = desired weight in lower half of partition
rcb.cpp:    // targethi = desired weight in upper half of partition
rcb.cpp:    targetlo = wttot * (procmid - proclower) / (procupper + 1 - proclower);
rcb.cpp:    // attempt a cut in each dimension
rcb.cpp:    // each cut produces 2 boxes, each with a reduced box length in that dim
rcb.cpp:    // smaller = the smaller of the 2 reduced box lengths in that dimension
rcb.cpp:    // choose to cut in dimension which produces largest smaller value
rcb.cpp:    // this should induce final proc sub-boxes to be as cube-ish as possible
rcb.cpp:    // dim_select = selected cut dimension
rcb.cpp:    // valuehalf_select = valuehalf in that dimension
rcb.cpp:    // dotmark_select = dot markings in that dimension
rcb.cpp:      // create active list and mark array for dots
rcb.cpp:      // initialize active list to all dots
rcb.cpp:      // median iteration
rcb.cpp:      // zoom in on bisector until correct # of dots in each half of partition
rcb.cpp:      // as each iteration of median-loop begins, require:
rcb.cpp:      //   all non-active dots are marked with 0/1 in dotmark
rcb.cpp:      //   valuemin <= every active dot <= valuemax
rcb.cpp:      //   wtlo, wthi = total wt of non-active dots
rcb.cpp:      // when leave median-loop, require only:
rcb.cpp:      //   valuehalf = correct cut position
rcb.cpp:      //   all dots <= valuehalf are marked with 0 in dotmark
rcb.cpp:      //   all dots >= valuehalf are marked with 1 in dotmark
rcb.cpp:      // markactive = which side of cut is active = 0/1
rcb.cpp:      // indexlo,indexhi = indices of dot closest to median
rcb.cpp:        // choose bisector value
rcb.cpp:        // use old value on 1st iteration if old cut dimension is the same
rcb.cpp:        // on 2nd option: could push valuehalf towards geometric center
rcb.cpp:        //   with "1.0-factor" to force overshoot
rcb.cpp:          valuehalf = valuemin + (targetlo - wtlo) /
rcb.cpp:        // initialize local median data structure
rcb.cpp:        // mark all active dots on one side or other of bisector
rcb.cpp:        // also set all fields in median data struct
rcb.cpp:        // save indices of closest dots on either side
rcb.cpp:          if (dots[i].x[dim] <= valuehalf) {            // in lower part
rcb.cpp:            if (dots[i].x[dim] > medme.valuelo) {       // my closest dot
rcb.cpp:            } else if (dots[i].x[dim] == medme.valuelo) {   // tied for closest
rcb.cpp:          else {                                        // in upper part
rcb.cpp:            if (dots[i].x[dim] < medme.valuehi) {       // my closest dot
rcb.cpp:            } else if (dots[i].x[dim] == medme.valuehi) {   // tied for closest
rcb.cpp:        // combine median data struct across current subset of procs
rcb.cpp:        // test median guess for convergence
rcb.cpp:        // move additional dots that are next to cut across it
rcb.cpp:        if (wtlo + med.totallo < targetlo) {    // lower half TOO SMALL
rcb.cpp:          if (med.counthi == 1) {                  // only one dot to move
rcb.cpp:            if (wtlo + med.wthi < targetlo) {  // move it, keep iterating
rcb.cpp:            else {                                 // only move if beneficial
rcb.cpp:              break;                               // all done
rcb.cpp:          else {                                   // multiple dots to move
rcb.cpp:            if (wtlo + med.wthi >= targetlo) {                // all done
rcb.cpp:            }                                      // wtok = most I can move
rcb.cpp:              if (dots[i].x[dim] == med.valuehi) { // only move if better
rcb.cpp:            if (breakflag) break;                   // done if moved enough
rcb.cpp:          if (targetlo-wtlo <= tolerance) break;  // close enough
rcb.cpp:          valuemin = med.valuehi;                   // iterate again
rcb.cpp:        else if (wthi + med.totalhi < targethi) {  // upper half TOO SMALL
rcb.cpp:          if (med.countlo == 1) {                  // only one dot to move
rcb.cpp:            if (wthi + med.wtlo < targethi) {  // move it, keep iterating
rcb.cpp:            else {                                 // only move if beneficial
rcb.cpp:              break;                               // all done
rcb.cpp:          else {                                   // multiple dots to move
rcb.cpp:            if (wthi + med.wtlo >= targethi) {                // all done
rcb.cpp:            }                                      // wtok = most I can move
rcb.cpp:              if (dots[i].x[dim] == med.valuelo) { // only move if better
rcb.cpp:            if (breakflag) break;                   // done if moved enough
rcb.cpp:          if (targethi-wthi <= tolerance) break;  // close enough
rcb.cpp:          valuemax = med.valuelo;                   // iterate again
rcb.cpp:        else                  // Goldilocks result: both partitions just right
rcb.cpp:        // shrink the active list
rcb.cpp:      // cut produces 2 sub-boxes with reduced size in dim
rcb.cpp:      // compare smaller of the 2 sizes to previous dims
rcb.cpp:      // keep dim that has the largest smaller
rcb.cpp:    // copy results for best dim cut into dim,valuehalf,dotmark
rcb.cpp:    // found median
rcb.cpp:    // store cut info only if I am procmid
rcb.cpp:    // use cut to shrink my RCB bounding box
rcb.cpp:    // outgoing = number of dots to ship to partner
rcb.cpp:    // nkeep = number of dots that have never migrated
rcb.cpp:    // alert partner how many dots I'll send, read how many I'll recv
rcb.cpp:    // check if need to alloc more space
rcb.cpp:    // malloc comm send buffer
rcb.cpp:    // fill buffer with dots that are marked for sending
rcb.cpp:    // pack down the unmarked ones
rcb.cpp:    // post receives for dots
rcb.cpp:    // handshake before sending dots to insure recvs have been posted
rcb.cpp:    // send dots to partner
rcb.cpp:    // wait until all dots are received
rcb.cpp:    // cut partition in half, create new communicators of 1/2 size
rcb.cpp:  // clean up
rcb.cpp:  // set public variables with results of rebalance
rcb.cpp:/* ----------------------------------------------------------------------
rcb.cpp:   perform RCB balancing of N particles at coords X in bounding box LO/HI
rcb.cpp:     defined by final lo/hi
rcb.cpp:   // NOTE: worry about re-use of data structs for fix balance?
rcb.cpp:------------------------------------------------------------------------- */
rcb.cpp:  // create list of my Dots
rcb.cpp:  // initial bounding box = simulation box
rcb.cpp:  // includes periodic or shrink-wrapped boundaries
rcb.cpp:  // initialize counters
rcb.cpp:  // create communicator for use in recursion
rcb.cpp:  // recurse until partition is a single proc = me
rcb.cpp:  // proclower,procupper = lower,upper procs in partition
rcb.cpp:  // procmid = 1st proc in upper half of partition
rcb.cpp:    // if odd # of procs, lower partition gets extra one
rcb.cpp:    procmid = proclower + (procupper - proclower) / 2 + 1;
rcb.cpp:    // determine communication partner(s)
rcb.cpp:    // readnumber = # of proc partners to read from
rcb.cpp:    // wttot = summed weight of entire partition
rcb.cpp:    // search tolerance = largest single weight (plus epsilon)
rcb.cpp:    // targetlo = desired weight in lower half of partition
rcb.cpp:    // targethi = desired weight in upper half of partition
rcb.cpp:    targetlo = wttot * (procmid - proclower) / (procupper + 1 - proclower);
rcb.cpp:    // dim = dimension to bisect on
rcb.cpp:    // do not allow choice of z dimension for 2d system
rcb.cpp:    // create active list and mark array for dots
rcb.cpp:    // initialize active list to all dots
rcb.cpp:    // median iteration
rcb.cpp:    // zoom in on bisector until correct # of dots in each half of partition
rcb.cpp:    // as each iteration of median-loop begins, require:
rcb.cpp:    //   all non-active dots are marked with 0/1 in dotmark
rcb.cpp:    //   valuemin <= every active dot <= valuemax
rcb.cpp:    //   wtlo, wthi = total wt of non-active dots
rcb.cpp:    // when leave median-loop, require only:
rcb.cpp:    //   valuehalf = correct cut position
rcb.cpp:    //   all dots <= valuehalf are marked with 0 in dotmark
rcb.cpp:    //   all dots >= valuehalf are marked with 1 in dotmark
rcb.cpp:    // markactive = which side of cut is active = 0/1
rcb.cpp:    // indexlo,indexhi = indices of dot closest to median
rcb.cpp:      // choose bisector value
rcb.cpp:      // use old value on 1st iteration if old cut dimension is the same
rcb.cpp:      // on 2nd option: could push valuehalf towards geometric center
rcb.cpp:      //   with "1.0-factor" to force overshoot
rcb.cpp:	valuehalf = valuemin + (targetlo - wtlo) /
rcb.cpp:      // initialize local median data structure
rcb.cpp:      // mark all active dots on one side or other of bisector
rcb.cpp:      // also set all fields in median data struct
rcb.cpp:      // save indices of closest dots on either side
rcb.cpp:	if (dots[i].x[dim] <= valuehalf) {            // in lower part
rcb.cpp:	  if (dots[i].x[dim] > medme.valuelo) {       // my closest dot
rcb.cpp:	  } else if (dots[i].x[dim] == medme.valuelo) {   // tied for closest
rcb.cpp:	else {                                        // in upper part
rcb.cpp:	  if (dots[i].x[dim] < medme.valuehi) {       // my closest dot
rcb.cpp:	  } else if (dots[i].x[dim] == medme.valuehi) {   // tied for closest
rcb.cpp:      // combine median data struct across current subset of procs
rcb.cpp:      // test median guess for convergence
rcb.cpp:      // move additional dots that are next to cut across it
rcb.cpp:      if (wtlo + med.totallo < targetlo) {    // lower half TOO SMALL
rcb.cpp:	if (med.counthi == 1) {                  // only one dot to move
rcb.cpp:	  if (wtlo + med.wthi < targetlo) {  // move it, keep iterating
rcb.cpp:	  else {                                 // only move if beneficial
rcb.cpp:	    break;                               // all done
rcb.cpp:	else {                                   // multiple dots to move
rcb.cpp:	  if (wtlo + med.wthi >= targetlo) {                // all done
rcb.cpp:	  }                                      // wtok = most I can move
rcb.cpp:	    if (dots[i].x[dim] == med.valuehi) { // only move if better
rcb.cpp:	  if (breakflag) break;                   // done if moved enough
rcb.cpp:	if (targetlo-wtlo <= tolerance) break;  // close enough
rcb.cpp:	valuemin = med.valuehi;                   // iterate again
rcb.cpp:      else if (wthi + med.totalhi < targethi) {  // upper half TOO SMALL
rcb.cpp:	if (med.countlo == 1) {                  // only one dot to move
rcb.cpp:	  if (wthi + med.wtlo < targethi) {  // move it, keep iterating
rcb.cpp:	  else {                                 // only move if beneficial
rcb.cpp:	    break;                               // all done
rcb.cpp:	else {                                   // multiple dots to move
rcb.cpp:	  if (wthi + med.wtlo >= targethi) {                // all done
rcb.cpp:	  }                                      // wtok = most I can move
rcb.cpp:	    if (dots[i].x[dim] == med.valuelo) { // only move if better
rcb.cpp:	  if (breakflag) break;                   // done if moved enough
rcb.cpp:	if (targethi-wthi <= tolerance) break;  // close enough
rcb.cpp:	valuemax = med.valuelo;                   // iterate again
rcb.cpp:      else                  // Goldilocks result: both partitions just right
rcb.cpp:      // shrink the active list
rcb.cpp:    // found median
rcb.cpp:    // store cut info only if I am procmid
rcb.cpp:    // use cut to shrink my RCB bounding box
rcb.cpp:    // outgoing = number of dots to ship to partner
rcb.cpp:    // nkeep = number of dots that have never migrated
rcb.cpp:    // alert partner how many dots I'll send, read how many I'll recv
rcb.cpp:    // check if need to alloc more space
rcb.cpp:    // malloc comm send buffer
rcb.cpp:    // fill buffer with dots that are marked for sending
rcb.cpp:    // pack down the unmarked ones
rcb.cpp:    // post receives for dots
rcb.cpp:    // handshake before sending dots to insure recvs have been posted
rcb.cpp:    // send dots to partner
rcb.cpp:    // wait until all dots are received
rcb.cpp:    // cut partition in half, create new communicators of 1/2 size
rcb.cpp:  // clean up
rcb.cpp:  // set public variables with results of rebalance
rcb.cpp:/* ----------------------------------------------------------------------
rcb.cpp:------------------------------------------------------------------------- */
rcb.cpp:/* ----------------------------------------------------------------------
rcb.cpp:------------------------------------------------------------------------- */
rcb.cpp:/* ----------------------------------------------------------------------
rcb.cpp:------------------------------------------------------------------------- */
rcb.cpp:  // only create Irregular if not previously created
rcb.cpp:  // allows Irregular to persist for multiple RCB calls by fix balance
rcb.cpp:  // nsend = # of dots to request from other procs
rcb.cpp:  // perform inversion via irregular comm
rcb.cpp:  // nrecv = # of my dots to send to other procs
rcb.cpp:  // set public variables from requests to send my dots
rcb.cpp:  // clean-up
rcb.cpp:/* ----------------------------------------------------------------------
rcb.cpp:------------------------------------------------------------------------- */
rcb.cpp:// -----------------------------------------------------------------------
rcb.cpp:// DEBUG methods
rcb.cpp:// -----------------------------------------------------------------------
rcb.cpp:/*
rcb.cpp:// consistency checks on RCB results
rcb.cpp:  // check that total # of dots remained the same
rcb.cpp:  // check that result is load-balanced within log2(P)*max-wt
rcb.cpp:  // i = smallest power-of-2 >= nprocs
rcb.cpp:  // tolerance = largest-single-weight*log2(nprocs)
rcb.cpp:  // check that final set of points is inside RCB box of each proc
rcb.cpp:// stats for RCB decomposition
rcb.cpp:  // distribution info
rcb.cpp:	   wttot/nprocs,wtmax,wtmin);
rcb.cpp:  // counter info
rcb.cpp:  ave = ((double) sum)/nprocs;
rcb.cpp:  ave = ((double) sum)/nprocs;
rcb.cpp:  ave = ((double) sum)/nprocs;
rcb.cpp:  ave = ((double) sum)/nprocs;
rcb.cpp:  ave = ((double) sum)/nprocs;
rcb.cpp:    ave = ((double) sum)/nprocs;
rcb.cpp:  ave = ((double) sum)/nprocs;
rcb.cpp:  // RCB boxes for each proc
rcb.cpp:*/
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
read_data.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:// lmptype.h must be first b/c this file uses MAXBIGINT and includes mpi.h
read_data.cpp:// due to OpenMPI bug which sets INT64_MAX via its mpi.h
read_data.cpp://   before lmptype.h can set flags to insure it is done correctly
read_data.cpp:#define DELTA 4            // must be 2 or larger
read_data.cpp:#define MAXBODY 32         // max # of lines in one body
read_data.cpp:                           // customize for new sections
read_data.cpp:#define NSECTIONS 25       // change when add to header::section_keywords
read_data.cpp:// pair style suffixes to ignore
read_data.cpp:// when matching Pair Coeffs comment to currently-defined pair style
read_data.cpp:const char *suffixes[] = {"/cuda","/gpu","/opt","/omp","/kk",
read_data.cpp:                          "/coul/cut","/coul/long","/coul/msm",
read_data.cpp:                          "/coul/dsf","/coul/debye","/coul/charmm",
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:  // customize for new sections
read_data.cpp:  // pointers to atom styles that store extra info
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:  // optional args
read_data.cpp:    } else if (strcmp(arg[iarg],"extra/atom/types") == 0) {
read_data.cpp:    } else if (strcmp(arg[iarg],"extra/bond/types") == 0) {
read_data.cpp:    } else if (strcmp(arg[iarg],"extra/angle/types") == 0) {
read_data.cpp:    } else if (strcmp(arg[iarg],"extra/dihedral/types") == 0) {
read_data.cpp:    } else if (strcmp(arg[iarg],"extra/improper/types") == 0) {
read_data.cpp:  // error checks
read_data.cpp:  // first time system initialization
read_data.cpp:  // compute atomID offset for addflag = MERGE
read_data.cpp:  // set up pointer to hold original styles while we replace them with "zero"
read_data.cpp:  // -----------------------------------------------------------------
read_data.cpp:  // perform 1-pass read if no molecular topology in file
read_data.cpp:  // perform 2-pass read if molecular topology,
read_data.cpp:  //   first pass calculates max topology/atom
read_data.cpp:  // flags for this data file
read_data.cpp:  // values in this data file
read_data.cpp:    // open file on proc 0
read_data.cpp:    // read header info
read_data.cpp:    // problem setup using info from header
read_data.cpp:    // only done once, if firstpass and first data file
read_data.cpp:    // apply extra settings before grow(), even if no topology in file
read_data.cpp:    // deallocate() insures new settings are used for topology arrays
read_data.cpp:    // if per-atom topology is in file, another grow() is done below
read_data.cpp:      else n = static_cast<int> (LB_FACTOR * atom->natoms / comm->nprocs);
read_data.cpp:    // change simulation box to be union of existing box and new box + shift
read_data.cpp:    // only done if firstpass and not first data file
read_data.cpp:      // NOTE: not sure what to do about tilt value in subsequent data files
read_data.cpp:      //if (triclinic) {
read_data.cpp:      //  domain->xy = xy; domain->xz = xz; domain->yz = yz;
read_data.cpp:      // }
read_data.cpp:    // customize for new sections
read_data.cpp:    // read rest of file in free format
read_data.cpp:      // if special fix matches, it processes section
read_data.cpp:        } else skip_lines(ntypes*(ntypes+1)/2);
read_data.cpp:    // error if natoms > 0 yet no atoms were read
read_data.cpp:    // close file
read_data.cpp:    // done if this was 2nd pass
read_data.cpp:    // at end of 1st pass, error check for required sections
read_data.cpp:    // customize for new sections
read_data.cpp:    // break out of loop if no molecular topology in file
read_data.cpp:    // else make 2nd pass
read_data.cpp:    // reallocate bond,angle,diehdral,improper arrays via grow()
read_data.cpp:    // will use new bond,angle,dihedral,improper per-atom values from 1st pass
read_data.cpp:    // will also observe extra settings even if bond/etc topology not in file
read_data.cpp:    // leaves other atom arrays unchanged, since already nmax in length
read_data.cpp:  // init per-atom fix/compute/variable values for created atoms
read_data.cpp:  // assign atoms added by this data file to specified group
read_data.cpp:  // create special bond lists for molecular systems
read_data.cpp:  // for atom style template systems, count total bonds,angles,etc
read_data.cpp:      atom->nbonds /= 2;
read_data.cpp:      atom->nangles /= 3;
read_data.cpp:      atom->ndihedrals /= 4;
read_data.cpp:      atom->nimpropers /= 4;
read_data.cpp:  // for atom style template systems
read_data.cpp:  // insure nbondtypes,etc are still consistent with template molecules,
read_data.cpp:  //   in case data file re-defined them
read_data.cpp:  // if adding atoms, migrate atoms to new processors
read_data.cpp:  // use irregular() b/c box size could have changed dramaticaly
read_data.cpp:  // resulting in procs now owning very different subboxes
read_data.cpp:  // with their previously owned atoms now far outside the subbox
read_data.cpp:  // shrink-wrap the box if necessary and move atoms to new procs
read_data.cpp:  // if atoms are lost is b/c data file box was far from shrink-wrapped
read_data.cpp:  // do not use irregular() comm, which would not lose atoms,
read_data.cpp:  //   b/c then user could specify data file box as far too big and empty
read_data.cpp:  // do comm->init() but not comm->setup() b/c pair/neigh cutoffs not yet set
read_data.cpp:  // need call to map_set() b/c comm->exchange clears atom map
read_data.cpp:  // restore old styles, when reading with nocoeff flag given
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:  // customize for new sections
read_data.cpp:  // skip 1st line of file
read_data.cpp:    // read a line and bcast length
read_data.cpp:    // if n = 0 then end-of-file so return with blank line
read_data.cpp:    // trim anything from '#' onward
read_data.cpp:    // if line is blank, continue
read_data.cpp:    // allow special fixes first chance to match and process the line
read_data.cpp:    // if fix matches, continue to next header line
read_data.cpp:    // search line for header keyword and set corresponding variable
read_data.cpp:    // customize for new header lines
read_data.cpp:    // check for triangles before angles so "triangles" not matched as "angles"
read_data.cpp:    // Atom class type settings are only set by first data file
read_data.cpp:    // these settings only used by first data file
read_data.cpp:    // local copy of box info
read_data.cpp:    // so can treat differently for first vs subsequent data files
read_data.cpp:  // error check on total system size
read_data.cpp:  // check that exiting string is a valid section keyword
read_data.cpp:  // error checks on header values
read_data.cpp:  // must be consistent with atom style and other header values
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:  // check that all atoms were assigned correctly
read_data.cpp:  // check that atom IDs are valid
read_data.cpp:  // create global mapping of atoms
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:  // allocate count if firstpass
read_data.cpp:  // read and process bonds
read_data.cpp:  // if firstpass: tally max bond/atom and return
read_data.cpp:  // if addflag = NONE, store max bond/atom with extra
read_data.cpp:  // else just check actual max does not exceed existing max
read_data.cpp:      if (screen) fprintf(screen,"  %d = max bonds/atom\n",maxall);
read_data.cpp:      if (logfile) fprintf(logfile,"  %d = max bonds/atom\n",maxall);
read_data.cpp:  // if 2nd pass: check that bonds were assigned correctly
read_data.cpp:    if (screen) fprintf(screen,"  " BIGINT_FORMAT " bonds\n",sum/factor);
read_data.cpp:    if (logfile) fprintf(logfile,"  " BIGINT_FORMAT " bonds\n",sum/factor);
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:  // allocate count if firstpass
read_data.cpp:  // read and process angles
read_data.cpp:  // if firstpass: tally max angle/atom and return
read_data.cpp:  // if addflag = NONE, store max angle/atom with extra
read_data.cpp:  // else just check actual max does not exceed existing max
read_data.cpp:      if (screen) fprintf(screen,"  %d = max angles/atom\n",maxall);
read_data.cpp:      if (logfile) fprintf(logfile,"  %d = max angles/atom\n",maxall);
read_data.cpp:  // if 2nd pass: check that angles were assigned correctly
read_data.cpp:    if (screen) fprintf(screen,"  " BIGINT_FORMAT " angles\n",sum/factor);
read_data.cpp:    if (logfile) fprintf(logfile,"  " BIGINT_FORMAT " angles\n",sum/factor);
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:  // allocate count if firstpass
read_data.cpp:  // read and process dihedrals
read_data.cpp:  // if firstpass: tally max dihedral/atom and return
read_data.cpp:  // if addflag = NONE, store max dihedral/atom with extra
read_data.cpp:  // else just check actual max does not exceed existing max
read_data.cpp:      if (screen) fprintf(screen,"  %d = max dihedrals/atom\n",maxall);
read_data.cpp:      if (logfile) fprintf(logfile,"  %d = max dihedrals/atom\n",maxall);
read_data.cpp:  // if 2nd pass: check that dihedrals were assigned correctly
read_data.cpp:    if (screen) fprintf(screen,"  " BIGINT_FORMAT " dihedrals\n",sum/factor);
read_data.cpp:    if (logfile) fprintf(logfile,"  " BIGINT_FORMAT " dihedrals\n",sum/factor);
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:  // allocate count if firstpass
read_data.cpp:  // read and process impropers
read_data.cpp:  // if firstpass: tally max improper/atom and return
read_data.cpp:  // if addflag = NONE, store max improper/atom
read_data.cpp:  // else just check it does not exceed existing max
read_data.cpp:      if (screen) fprintf(screen,"  %d = max impropers/atom\n",maxall);
read_data.cpp:      if (logfile) fprintf(logfile,"  %d = max impropers/atom\n",maxall);
read_data.cpp:  // if 2nd pass: check that impropers were assigned correctly
read_data.cpp:    if (screen) fprintf(screen,"  " BIGINT_FORMAT " impropers\n",sum/factor);
read_data.cpp:    if (logfile) fprintf(logfile,"  " BIGINT_FORMAT " impropers\n",sum/factor);
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:  // nmax = max # of bodies to read in this chunk
read_data.cpp:  // nchunk = actual # read
read_data.cpp:        // read lines one at a time into buffer and count words
read_data.cpp:        // count to ninteger and ndouble until have enough lines
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:  int nsq = ntypes * (ntypes+1) / 2;
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:/* ---------------------------------------------------------------------- */
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:   keyword is all text on line w/out leading & trailing white space
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:  // proc 0 reads upto non-blank line plus 1 following line
read_data.cpp:  // eof is set to 1 if any read hits end-of-file
read_data.cpp:  // if eof, set keyword empty and return
read_data.cpp:  // bcast keyword line to all procs
read_data.cpp:  // store optional "style" following comment char '#' after keyword
read_data.cpp:  // copy non-whitespace portion of line into keyword
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:   if addstr != NULL, add addstr as extra arg for class2 angle/dihedral/improper
read_data.cpp:   if noffset, add offset to first noffset args, which are atom/bond/etc types
read_data.cpp:------------------------------------------------------------------------- */
read_data.cpp:/* ----------------------------------------------------------------------
read_data.cpp:------------------------------------------------------------------------- */
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
read_dump.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:// lmptype.h must be first b/c this file uses MAXBIGINT and includes mpi.h
read_dump.cpp:// due to OpenMPI bug which sets INT64_MAX via its mpi.h
read_dump.cpp://   before lmptype.h can set flags to insure it is done correctly
read_dump.cpp:// also in reader_native.cpp
read_dump.cpp:/* ---------------------------------------------------------------------- */
read_dump.cpp:/* ---------------------------------------------------------------------- */
read_dump.cpp:/* ---------------------------------------------------------------------- */
read_dump.cpp:  // find the snapshot and read/bcast/process header info
read_dump.cpp:  // reset timestep to nstep
read_dump.cpp:  // counters
read_dump.cpp:  // read in the snapshot and reset system
read_dump.cpp:  // print out stats
read_dump.cpp:/* ---------------------------------------------------------------------- */
read_dump.cpp:/* ---------------------------------------------------------------------- */
read_dump.cpp:  // allocate snapshot field buffer
read_dump.cpp:  // create reader class
read_dump.cpp:  // match readerstyle to options in style_reader.h
read_dump.cpp:  if (0) return;        // dummy line to enable else-if macro expansion
read_dump.cpp:  // unrecognized style
read_dump.cpp:  // pass any arguments to reader
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:    // exit file loop when dump timestep >= nrequest
read_dump.cpp:    // or files exhausted
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:    // exit file loop when dump timestep matches all criteria
read_dump.cpp:    // or files exhausted
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:  // local copy of snapshot box parameters
read_dump.cpp:  // used in xfield,yfield,zfield when converting dump atom to absolute coords
read_dump.cpp:  // done if not checking fields
read_dump.cpp:  // error check on current vs new box and fields
read_dump.cpp:  // triclinic_snap < 0 means no box info in file
read_dump.cpp:  // error check on requested fields exisiting in dump file
read_dump.cpp:  // all explicitly requested x,y,z must have consistent scaling & wrapping
read_dump.cpp:               "Read_dump xyz fields do not have consistent scaling/wrapping");
read_dump.cpp:  // set scaled/wrapped based on xyz flags
read_dump.cpp:  // scaled, triclinic coords require all 3 x,y,z fields, to perform unscaling
read_dump.cpp:  // set yindex,zindex = column index of Y and Z fields in fields array
read_dump.cpp:  // needed for unscaling to absolute coords in xfield(), yfield(), zfield()
read_dump.cpp:/* ---------------------------------------------------------------------- */
read_dump.cpp:  // initialize counters
read_dump.cpp:  // if purgeflag set, delete all current atoms
read_dump.cpp:  // to match existing atoms to dump atoms:
read_dump.cpp:  // must build map if not a molecular system
read_dump.cpp:  // uflag[i] = 1 for each owned atom appearing in dump
read_dump.cpp:  // ucflag = similar flag for each chunk atom, used in process_atoms()
read_dump.cpp:  // read, broadcast, and process atoms from snapshot in chunks
read_dump.cpp:  // if addflag set, add tags to new atoms if possible
read_dump.cpp:  // if trimflag set, delete atoms not replaced by snapshot atoms
read_dump.cpp:  // can now delete uflag arrays
read_dump.cpp:  // delete atom map if created it above
read_dump.cpp:  // else reinitialize map for current atoms
read_dump.cpp:  // do this before migrating atoms to new procs via Irregular
read_dump.cpp:  // overwrite simulation box with dump snapshot box if requested
read_dump.cpp:  // reallocate processors to box
read_dump.cpp:  // move atoms back inside simulation box and to new processors
read_dump.cpp:  // use remap() instead of pbc() in case atoms moved a long distance
read_dump.cpp:  // adjust image flags of all atoms (old and new) based on current box
read_dump.cpp:  // use irregular() in case atoms moved a long distance
read_dump.cpp:  // check that atom IDs are valid
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:  // per-field vectors, leave space for ID and TYPE
read_dump.cpp:  // add id and type fields as needed
read_dump.cpp:  // scan ahead to see if "add yes" keyword/value is used
read_dump.cpp:  // requires extra "type" field from from dump file
read_dump.cpp:  // parse fields
read_dump.cpp:  // check for no fields
read_dump.cpp:  // parse optional args
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:   use round-robin method, b/c atom coords may not be inside simulation box
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:    // check if new atom matches one I own
read_dump.cpp:    // setting m = -1 forces new atom not to match
read_dump.cpp:    // NOTE: atom ID in fields is stored as double, not as ubuf
read_dump.cpp:    //       so can only cast it to tagint, thus cannot be full 64-bit ID
read_dump.cpp:      // current image flags
read_dump.cpp:      // overwrite atom attributes with field info
read_dump.cpp:      // start from field 1 since 0 = id, 1 will be skipped if type
read_dump.cpp:      // replace image flag in case changed by ix,iy,iz fields or unwrapping
read_dump.cpp:  // create any atoms in chunk that no processor owned
read_dump.cpp:  // add atoms in round-robin sequence on processors
read_dump.cpp:  // cannot do it geometrically b/c dump coords may not be in simulation box
read_dump.cpp:    // each processor adds every Pth atom
read_dump.cpp:    // create type and coord fields from dump file
read_dump.cpp:    // coord = 0.0 unless corresponding dump file field was specified
read_dump.cpp:    // create the atom on proc that owns it
read_dump.cpp:    // reset v,image ptrs in case they are reallocated
read_dump.cpp:    // set atom attributes from other dump file fields
read_dump.cpp:      // replace image flag in case changed by ix,iy,iz fields
read_dump.cpp:  // init per-atom fix/compute/variable values for created atoms
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:------------------------------------------------------------------------- */
read_dump.cpp:/* ----------------------------------------------------------------------
read_dump.cpp:------------------------------------------------------------------------- */
reader.cpp:/* ----------------------------------------------------------------------
reader.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
reader.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
reader.cpp:------------------------------------------------------------------------- */
reader.cpp:/* ---------------------------------------------------------------------- */
reader.cpp:/* ----------------------------------------------------------------------
reader.cpp:------------------------------------------------------------------------- */
reader.cpp:/* ----------------------------------------------------------------------
reader.cpp:------------------------------------------------------------------------- */
reader_native.cpp:/* ----------------------------------------------------------------------
reader_native.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
reader_native.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
reader_native.cpp:------------------------------------------------------------------------- */
reader_native.cpp:#define MAXLINE 1024        // max line length in dump file
reader_native.cpp:// also in read_dump.cpp
reader_native.cpp:/* ---------------------------------------------------------------------- */
reader_native.cpp:/* ---------------------------------------------------------------------- */
reader_native.cpp:/* ----------------------------------------------------------------------
reader_native.cpp:------------------------------------------------------------------------- */
reader_native.cpp:/* ----------------------------------------------------------------------
reader_native.cpp:------------------------------------------------------------------------- */
reader_native.cpp:  // invoke read_lines() in chunks no larger than MAXSMALLINT
reader_native.cpp:/* ----------------------------------------------------------------------
reader_native.cpp:     xyz flags = UNSET (not a requested field), SCALE/WRAP as in enum
reader_native.cpp:------------------------------------------------------------------------- */
reader_native.cpp:  // if no field info requested, just return
reader_native.cpp:  // exatract column labels and match to requested fields
reader_native.cpp:  // match each field with a column of per-atom data
reader_native.cpp:  // if fieldlabel set, match with explicit column
reader_native.cpp:  // else infer one or more column matches from fieldtype
reader_native.cpp:  // xyz flag set by scaleflag + wrapflag (if fieldlabel set) or column label
reader_native.cpp:  // set fieldflag = -1 if any unfound fields
reader_native.cpp:  // create internal vector of word ptrs for future parsing of per-atom lines
reader_native.cpp:/* ----------------------------------------------------------------------
reader_native.cpp:------------------------------------------------------------------------- */
reader_native.cpp:    // tokenize the line
reader_native.cpp:    // convert selected fields to floats
reader_native.cpp:/* ----------------------------------------------------------------------
reader_native.cpp:------------------------------------------------------------------------- */
reader_native.cpp:/* ----------------------------------------------------------------------
reader_native.cpp:------------------------------------------------------------------------- */
reader_xyz.cpp:/* ----------------------------------------------------------------------
reader_xyz.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
reader_xyz.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
reader_xyz.cpp:------------------------------------------------------------------------- */
reader_xyz.cpp:/* ----------------------------------------------------------------------
reader_xyz.cpp:------------------------------------------------------------------------- */
reader_xyz.cpp:#define MAXLINE 1024        // max line length in dump file
reader_xyz.cpp:/* ---------------------------------------------------------------------- */
reader_xyz.cpp:/* ---------------------------------------------------------------------- */
reader_xyz.cpp:/* ----------------------------------------------------------------------
reader_xyz.cpp:------------------------------------------------------------------------- */
reader_xyz.cpp:  // first line has to have the number of atoms
reader_xyz.cpp:  // truncate the string to the first whitespace,
reader_xyz.cpp:  //   so force->bnumeric() does not hiccup
reader_xyz.cpp:  // skip over comment/title line
reader_xyz.cpp:  // fake time step numbers
reader_xyz.cpp:  // count this frame
reader_xyz.cpp:/* ----------------------------------------------------------------------
reader_xyz.cpp:------------------------------------------------------------------------- */
reader_xyz.cpp:  // invoke read_lines() in chunks no larger than MAXSMALLINT
reader_xyz.cpp:/* ----------------------------------------------------------------------
reader_xyz.cpp:------------------------------------------------------------------------- */
reader_xyz.cpp:  // signal that we have no box info at all
reader_xyz.cpp:  // if no field info requested, just return
reader_xyz.cpp:  // for xyz we know nothing about the style of coordinates,
reader_xyz.cpp:  // so caller has to set the proper flags
reader_xyz.cpp:  // copy fieldtype list for supported fields
reader_xyz.cpp:/* ----------------------------------------------------------------------
reader_xyz.cpp:------------------------------------------------------------------------- */
reader_xyz.cpp:    // XXX: we could insert an element2type translation here
reader_xyz.cpp:    // XXX: for now we flag unrecognized types as type 0,
reader_xyz.cpp:    // XXX: which should trigger an error, if LAMMPS uses it.
reader_xyz.cpp:/* ----------------------------------------------------------------------
reader_xyz.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
read_restart.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:// same as write_restart.cpp
read_restart.cpp:/* ---------------------------------------------------------------------- */
read_restart.cpp:/* ---------------------------------------------------------------------- */
read_restart.cpp:  // check for remap option
read_restart.cpp:  // if filename contains "*", search dir for latest restart file
read_restart.cpp:  // check for multiproc files and an MPI-IO filename
read_restart.cpp:  // open single restart file or base file for multiproc case
read_restart.cpp:  // read magic string, endian flag, numeric version
read_restart.cpp:  // read header info which creates simulation box
read_restart.cpp:  // problem setup using info from header
read_restart.cpp:  else n = static_cast<int> (LB_FACTOR * atom->natoms / nprocs);
read_restart.cpp:  // read groups, ntype-length arrays, force field, fix info from file
read_restart.cpp:  // nextra = max # of extra quantities stored with each atom
read_restart.cpp:  // read file layout info
read_restart.cpp:  // close header file if in multiproc mode
read_restart.cpp:  // read per-proc info
read_restart.cpp:  // MPI-IO input from single file
read_restart.cpp:  // input of single native file
read_restart.cpp:  // nprocs_file = # of chunks in file
read_restart.cpp:  // proc 0 reads a chunk and bcasts it to other procs
read_restart.cpp:  // each proc unpacks the atoms, saving ones in it's sub-domain
read_restart.cpp:  // if remapflag set, remap the atom to box before checking sub-domain
read_restart.cpp:  // check for atom in sub-domain differs for orthogonal vs triclinic box
read_restart.cpp:  // input of multiple native files with procs <= files
read_restart.cpp:  // # of files = multiproc_file
read_restart.cpp:  // each proc reads a subset of files, striding by nprocs
read_restart.cpp:  // each proc keeps all atoms in all perproc chunks in its files
read_restart.cpp:  // input of multiple native files with procs > files
read_restart.cpp:  // # of files = multiproc_file
read_restart.cpp:  // cluster procs based on # of files
read_restart.cpp:  // 1st proc in each cluster reads per-proc chunks from file
read_restart.cpp:  // sends chunks round-robin to other procs in its cluster
read_restart.cpp:  // each proc keeps all atoms in its perproc chunks in file
read_restart.cpp:    // nclusterprocs = # of procs in my cluster that read from one file
read_restart.cpp:    // filewriter = 1 if this proc reads file, else 0
read_restart.cpp:    // fileproc = ID of proc in my cluster who reads from file
read_restart.cpp:    // clustercomm = MPI communicator within my cluster of procs
read_restart.cpp:    int icluster = static_cast<int> ((bigint) me * nfile/nprocs);
read_restart.cpp:    int fileproc = static_cast<int> ((bigint) icluster * nprocs/nfile);
read_restart.cpp:    int fcluster = static_cast<int> ((bigint) fileproc * nfile/nprocs);
read_restart.cpp:      static_cast<int> ((bigint) (icluster+1) * nprocs/nfile);
read_restart.cpp:    fcluster = static_cast<int> ((bigint) fileprocnext * nfile/nprocs);
read_restart.cpp:  // clean-up memory
read_restart.cpp:  // for multiproc or MPI-IO files:
read_restart.cpp:  // perform irregular comm to migrate atoms to correct procs
read_restart.cpp:    // if remapflag set, remap all atoms I read back to box before migrating
read_restart.cpp:    // create a temporary fix to hold and migrate extra atom info
read_restart.cpp:    // necessary b/c irregular will migrate atoms
read_restart.cpp:    // move atoms to new processors via irregular()
read_restart.cpp:    // turn sorting on in migrate_atoms() to avoid non-reproducible restarts
read_restart.cpp:    // in case read by different proc than wrote restart file
read_restart.cpp:    // first do map_init() since irregular->migrate_atoms() will do map_clear()
read_restart.cpp:    // put extra atom info held by fix back into atom->extra
read_restart.cpp:    // destroy temporary fix
read_restart.cpp:  // check that all atoms were assigned to procs
read_restart.cpp:  // check that atom IDs are valid
read_restart.cpp:  // create global mapping of atoms
read_restart.cpp:  // create special bond lists for molecular systems
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:  // separate infile into dir + filename
read_restart.cpp:  if (strchr(infile,'/')) {
read_restart.cpp:    ptr = strrchr(infile,'/');
read_restart.cpp:    *ptr = '/';
read_restart.cpp:    strcpy(dirname,"./");
read_restart.cpp:  // if filename contains "%" replace "%" with "base"
read_restart.cpp:  // scan all files in directory, searching for files that match pattern
read_restart.cpp:  // maxnum = largest int that matches "*"
read_restart.cpp:  // create outfile with maxint substituted for "*"
read_restart.cpp:  // use original infile, not pattern, since need to retain "%" in filename
read_restart.cpp:  // clean up
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:  // read flags and fields until flag = -1
read_restart.cpp:    // check restart file version, warn if different
read_restart.cpp:    // check lmptype.h sizes, error if different
read_restart.cpp:    // reset unit_style only if different
read_restart.cpp:    // so that timestep,neighbor-skin are not changed
read_restart.cpp:    // set dimension from restart file
read_restart.cpp:    // read nprocs from restart file, warn if different
read_restart.cpp:    // don't set procgrid, warn if different
read_restart.cpp:    // don't set newton_pair, leave input script value unchanged
read_restart.cpp:    // set newton_bond from restart file
read_restart.cpp:    // warn if different and input script settings are not default
read_restart.cpp:    // set boundary settings from restart file
read_restart.cpp:    // warn if different and input script settings are not default
read_restart.cpp:    // create new AtomVec class using any stored args
read_restart.cpp:/* ---------------------------------------------------------------------- */
read_restart.cpp:/* ---------------------------------------------------------------------- */
read_restart.cpp:/* ---------------------------------------------------------------------- */
read_restart.cpp:        // on rank 0 read in the chunk sizes that were written out
read_restart.cpp:        // then consolidate them and compute offsets relative to the
read_restart.cpp:        // end of the header info to fit the current partition size
read_restart.cpp:        // if the number of ranks that did the writing is different
read_restart.cpp:          int init_chunk_number = nprocs_file/nprocs;
read_restart.cpp:        // scatter chunk sizes and offsets to all procs
read_restart.cpp:  // if MPI-IO file, broadcast the end of the header offste
read_restart.cpp:  // this allows all ranks to compute offset to their data
read_restart.cpp:// ----------------------------------------------------------------------
read_restart.cpp:// ----------------------------------------------------------------------
read_restart.cpp:// low-level fread methods
read_restart.cpp:// ----------------------------------------------------------------------
read_restart.cpp:// ----------------------------------------------------------------------
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
read_restart.cpp:/* ----------------------------------------------------------------------
read_restart.cpp:------------------------------------------------------------------------- */
region_block.cpp:/* ----------------------------------------------------------------------
region_block.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region_block.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region_block.cpp:------------------------------------------------------------------------- */
region_block.cpp:/* ---------------------------------------------------------------------- */
region_block.cpp:  // error check
region_block.cpp:  // extent of block
region_block.cpp:  // particle could be close to all 6 planes
region_block.cpp:  // particle can only touch 3 planes
region_block.cpp:  // open face data structs
region_block.cpp:  // face[0]
region_block.cpp:  // face[1]
region_block.cpp:  // face[2]
region_block.cpp:  // face[3]
region_block.cpp:  // face[4]
region_block.cpp:  // face[5]
region_block.cpp:/* ---------------------------------------------------------------------- */
region_block.cpp:/* ----------------------------------------------------------------------
region_block.cpp:------------------------------------------------------------------------- */
region_block.cpp:/* ----------------------------------------------------------------------
region_block.cpp:   no contact if outside (possible if called from union/intersect)
region_block.cpp:------------------------------------------------------------------------- */
region_block.cpp:  // x is exterior to block
region_block.cpp:  // x is interior to block or on its surface
region_block.cpp:/* ----------------------------------------------------------------------
region_block.cpp:   no contact if inside (possible if called from union/intersect)
region_block.cpp:------------------------------------------------------------------------- */
region_block.cpp:  // x is far enough from block that there is no contact
region_block.cpp:  // x is interior to block
region_block.cpp:  // x is exterior to block or on its surface
region_block.cpp:  // xp,yp,zp = point on surface of block that x is closest to
region_block.cpp:  //            could be edge or corner pt of block
region_block.cpp:  // do not add contact point if r >= cutoff
region_block.cpp:/*------------------------------------------------------------------------
region_block.cpp:--------------------------------------------------------------------------*/
region_block.cpp:  // check if point projects inside of face
region_block.cpp: // check each edge
region_block.cpp:/*------------------------------------------------------------------------
region_block.cpp:--------------------------------------------------------------------------*/
region_cone.cpp:/* ----------------------------------------------------------------------
region_cone.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region_cone.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region_cone.cpp:------------------------------------------------------------------------- */
region_cone.cpp:/* ----------------------------------------------------------------------
region_cone.cpp:------------------------------------------------------------------------- */
region_cone.cpp:/* ---------------------------------------------------------------------- */
region_cone.cpp:  // check open face settings
region_cone.cpp:  // error check
region_cone.cpp:  // extent of cone
region_cone.cpp:  // particle could be close to cone surface and 2 ends
region_cone.cpp:  // particle can only touch surface and 1 end
region_cone.cpp:/* ---------------------------------------------------------------------- */
region_cone.cpp:/* ----------------------------------------------------------------------
region_cone.cpp:------------------------------------------------------------------------- */
region_cone.cpp:    currentradius = radiuslo + (x-lo)*(radiushi-radiuslo)/(hi-lo);
region_cone.cpp:    currentradius = radiuslo + (y-lo)*(radiushi-radiuslo)/(hi-lo);
region_cone.cpp:    currentradius = radiuslo + (z-lo)*(radiushi-radiuslo)/(hi-lo);
region_cone.cpp:/* ----------------------------------------------------------------------
region_cone.cpp:   no contact if outside (possible if called from union/intersect)
region_cone.cpp:------------------------------------------------------------------------- */
region_cone.cpp:    currentradius = radiuslo + (x[0]-lo)*(radiushi-radiuslo)/(hi-lo);
region_cone.cpp:    // x is exterior to cone
region_cone.cpp:    // x is interior to cone or on its surface
region_cone.cpp:    // surflo = pt on outer circle of bottom end plane, same dir as x vs axis
region_cone.cpp:    // surfhi = pt on outer circle of top end plane, same dir as x vs axis
region_cone.cpp:      surflo[1] = c1 + del1*radiuslo/r;
region_cone.cpp:      surflo[2] = c2 + del2*radiuslo/r;
region_cone.cpp:      surfhi[1] = c1 + del1*radiushi/r;
region_cone.cpp:      surfhi[2] = c2 + del2*radiushi/r;
region_cone.cpp:                                  (radiushi-radiuslo)/(hi-lo));
region_cone.cpp:      (radiushi-radiuslo)/(hi-lo);
region_cone.cpp:    // y is exterior to cone
region_cone.cpp:    // y is interior to cone or on its surface
region_cone.cpp:    // surflo = pt on outer circle of bottom end plane, same dir as y vs axis
region_cone.cpp:    // surfhi = pt on outer circle of top end plane, same dir as y vs axis
region_cone.cpp:      surflo[0] = c1 + del1*radiuslo/r;
region_cone.cpp:      surflo[2] = c2 + del2*radiuslo/r;
region_cone.cpp:      surfhi[0] = c1 + del1*radiushi/r;
region_cone.cpp:      surfhi[2] = c2 + del2*radiushi/r;
region_cone.cpp:                                  (radiushi-radiuslo)/(hi-lo));
region_cone.cpp:    currentradius = radiuslo + (x[2]-lo)*(radiushi-radiuslo)/(hi-lo);
region_cone.cpp:    // z is exterior to cone
region_cone.cpp:    // z is interior to cone or on its surface
region_cone.cpp:    // surflo = pt on outer circle of bottom end plane, same dir as z vs axis
region_cone.cpp:    // surfhi = pt on outer circle of top end plane, same dir as z vs axis
region_cone.cpp:      surflo[0] = c1 + del1*radiuslo/r;
region_cone.cpp:      surflo[1] = c2 + del2*radiuslo/r;
region_cone.cpp:      surfhi[0] = c1 + del1*radiushi/r;
region_cone.cpp:      surfhi[1] = c2 + del2*radiushi/r;
region_cone.cpp:                                  (radiushi-radiuslo)/(hi-lo));
region_cone.cpp:/* ----------------------------------------------------------------------
region_cone.cpp:   no contact if inside (possible if called from union/intersect)
region_cone.cpp:------------------------------------------------------------------------- */
region_cone.cpp:    currentradius = radiuslo + (x[0]-lo)*(radiushi-radiuslo)/(hi-lo);
region_cone.cpp:    // radius of curvature, only used for granular walls
region_cone.cpp:    // x is far enough from cone that there is no contact
region_cone.cpp:    // x is interior to cone
region_cone.cpp:    // x is exterior to cone or on its surface
region_cone.cpp:    // corner1234 = 4 corner pts of half trapezoid = cone surf in plane of x
region_cone.cpp:    // project x to 3 line segments in half trapezoid (4th is axis of cone)
region_cone.cpp:    // nearest = point on surface of cone that x is closest to
region_cone.cpp:    //           could be edge of cone
region_cone.cpp:    // do not add contact point if r >= cutoff
region_cone.cpp:    corner1[1] = c1 + del1*radiuslo/r;
region_cone.cpp:    corner1[2] = c2 + del2*radiuslo/r;
region_cone.cpp:    corner2[1] = c1 + del1*radiushi/r;
region_cone.cpp:    corner2[2] = c2 + del2*radiushi/r;
region_cone.cpp:      crad = -2.0*(radiuslo + (nearest[0]-lo)*(radiushi-radiuslo)/(hi-lo));
region_cone.cpp:    currentradius = radiuslo + (x[1]-lo)*(radiushi-radiuslo)/(hi-lo);
region_cone.cpp:    // radius of curvature, only used for granular walls
region_cone.cpp:    // y is far enough from cone that there is no contact
region_cone.cpp:    // y is interior to cone
region_cone.cpp:    // y is exterior to cone or on its surface
region_cone.cpp:    // corner1234 = 4 corner pts of half trapezoid = cone surf in plane of y
region_cone.cpp:    // project x to 3 line segments in half trapezoid (4th is axis of cone)
region_cone.cpp:    // nearest = point on surface of cone that y is closest to
region_cone.cpp:    //           could be edge of cone
region_cone.cpp:    // do not add contact point if r >= cutoff
region_cone.cpp:    corner1[0] = c1 + del1*radiuslo/r;
region_cone.cpp:    corner1[2] = c2 + del2*radiuslo/r;
region_cone.cpp:    corner2[0] = c1 + del1*radiushi/r;
region_cone.cpp:    corner2[2] = c2 + del2*radiushi/r;
region_cone.cpp:      crad = -2.0*(radiuslo + (nearest[1]-lo)*(radiushi-radiuslo)/(hi-lo));
region_cone.cpp:    currentradius = radiuslo + (x[2]-lo)*(radiushi-radiuslo)/(hi-lo);
region_cone.cpp:    // radius of curvature, only used for granular walls
region_cone.cpp:    // z is far enough from cone that there is no contact
region_cone.cpp:    // z is interior to cone
region_cone.cpp:    // z is exterior to cone or on its surface
region_cone.cpp:    // corner1234 = 4 corner pts of half trapezoid = cone surf in plane of z
region_cone.cpp:    // project x to 3 line segments in half trapezoid (4th is axis of cone)
region_cone.cpp:    // nearest = point on surface of cone that z is closest to
region_cone.cpp:    //           could be edge of cone
region_cone.cpp:    // do not add contact point if r >= cutoff
region_cone.cpp:    corner1[0] = c1 + del1*radiuslo/r;
region_cone.cpp:    corner1[1] = c2 + del2*radiuslo/r;
region_cone.cpp:    corner2[0] = c1 + del1*radiushi/r;
region_cone.cpp:    corner2[1] = c2 + del2*radiushi/r;
region_cone.cpp:      crad = -2.0*(radiuslo + (nearest[2]-lo)*(radiushi-radiuslo)/(hi-lo));
region_cone.cpp:/* ---------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ---------------------------------------------------------------------- */
region.cpp:/* ---------------------------------------------------------------------- */
region.cpp:/* ---------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   return 1 if region is dynamic (moves/rotates) or has variable shape
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:     also insures variables are invoked by all procs even those w/out atoms
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region.cpp:    // one of surface_int/ext() will return 0
region.cpp:    // so no need to worry about offset of contact indices
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   pre-compute dx,dy,dz and theta for a moving/rotating region
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   sign of angle determines whether rotating forward/backward in time
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region.cpp:  // option defaults
region.cpp:      // additional checks on valid face index are done by region classes
region.cpp:  // error check
region.cpp:  // setup scaling
region.cpp:  // runit = unit vector along rotation axis
region.cpp:    runit[0] = axis[0]/len;
region.cpp:    runit[1] = axis[1]/len;
region.cpp:    runit[2] = axis[2]/len;
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region.cpp:  double t = MathExtra::dot3(ca,ba) / MathExtra::dot3(ba,ba);
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   necessary b/c motion variables are for displacement & theta
region.cpp:   called by fix wall/gran/region every timestep
region.cpp:------------------------------------------------------------------------- */
region.cpp:      v[0] = (dx - prev[0])/update->dt;
region.cpp:      v[1] = (dy - prev[1])/update->dt;
region.cpp:      v[2] = (dz - prev[2])/update->dt;
region.cpp:      double angvel = (theta-prev[3]) / update->dt;
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   since contacts only store delx/y/z, need to pass particle coords
region.cpp:   called by fix/wall/gran/region every contact every timestep
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   used by restart of fix/wall/gran/region
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   region writes its current style, id, number of sub-regions, position/angle
region.cpp:   needed by fix/wall/gran/region to compute velocity by differencing scheme
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:   if they match current region, also read previous position/angle
region.cpp:   needed by fix/wall/gran/region to compute velocity by differencing scheme
region.cpp:------------------------------------------------------------------------- */
region.cpp:/* ----------------------------------------------------------------------
region.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp:/* ----------------------------------------------------------------------
region_cylinder.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region_cylinder.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region_cylinder.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp:/* ---------------------------------------------------------------------- */
region_cylinder.cpp:  // check open face settings
region_cylinder.cpp:  // error check
region_cylinder.cpp:  // extent of cylinder
region_cylinder.cpp:  // for variable radius, uses initial radius
region_cylinder.cpp:  // particle could be close to cylinder surface and 2 ends
region_cylinder.cpp:  // particle can only touch surface and 1 end
region_cylinder.cpp:/* ---------------------------------------------------------------------- */
region_cylinder.cpp:/* ---------------------------------------------------------------------- */
region_cylinder.cpp:/* ----------------------------------------------------------------------
region_cylinder.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp:/* ----------------------------------------------------------------------
region_cylinder.cpp:   no contact if outside (possible if called from union/intersect)
region_cylinder.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp:    // x is exterior to cylinder
region_cylinder.cpp:    // x is interior to cylinder or on its surface
region_cylinder.cpp:      contact[n].dely = del1*(1.0-radius/r);
region_cylinder.cpp:      contact[n].delz = del2*(1.0-radius/r);
region_cylinder.cpp:    // y is exterior to cylinder
region_cylinder.cpp:    // y is interior to cylinder or on its surface
region_cylinder.cpp:      contact[n].delx = del1*(1.0-radius/r);
region_cylinder.cpp:      contact[n].delz = del2*(1.0-radius/r);
region_cylinder.cpp:    // z is exterior to cylinder
region_cylinder.cpp:    // z is interior to cylinder or on its surface
region_cylinder.cpp:      contact[n].delx = del1*(1.0-radius/r);
region_cylinder.cpp:      contact[n].dely = del2*(1.0-radius/r);
region_cylinder.cpp:/* ----------------------------------------------------------------------
region_cylinder.cpp:   no contact if inside (possible if called from union/intersect)
region_cylinder.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp: // radius of curvature for granular
region_cylinder.cpp: // 0 for flat surfaces (infinite case), 2*radius for curved portion
region_cylinder.cpp:    // x is far enough from cylinder that there is no contact
region_cylinder.cpp:    // x is interior to cylinder
region_cylinder.cpp:    // x is exterior to cylinder or on its surface
region_cylinder.cpp:    // xp,yp,zp = point on surface of cylinder that x is closest to
region_cylinder.cpp:    //            could be edge of cylinder
region_cylinder.cpp:    // do not add contact point if r >= cutoff
region_cylinder.cpp:        yp = c1 + del1*radius/r;
region_cylinder.cpp:        zp = c2 + del2*radius/r;
region_cylinder.cpp:    // closest point on curved surface
region_cylinder.cpp:        yp = c1 + del1*radius/r;
region_cylinder.cpp:        zp = c2 + del2*radius/r;
region_cylinder.cpp:      // closest point on bottom cap
region_cylinder.cpp:      // closest point on top cap
region_cylinder.cpp:    // y is far enough from cylinder that there is no contact
region_cylinder.cpp:    // y is interior to cylinder
region_cylinder.cpp:    // y is exterior to cylinder or on its surface
region_cylinder.cpp:    // xp,yp,zp = point on surface of cylinder that x is closest to
region_cylinder.cpp:    //            could be edge of cylinder
region_cylinder.cpp:    // do not add contact point if r >= cutoff
region_cylinder.cpp:        xp = c1 + del1*radius/r;
region_cylinder.cpp:        zp = c2 + del2*radius/r;
region_cylinder.cpp:    // closest point on curved surface
region_cylinder.cpp:        xp = c1 + del1*radius/r;
region_cylinder.cpp:        zp = c2 + del2*radius/r;
region_cylinder.cpp:      // closest point on bottom cap
region_cylinder.cpp:      // closest point on top cap
region_cylinder.cpp:    // z is far enough from cylinder that there is no contact
region_cylinder.cpp:    // z is interior to cylinder
region_cylinder.cpp:    // z is exterior to cylinder or on its surface
region_cylinder.cpp:    // xp,yp,zp = point on surface of cylinder that x is closest to
region_cylinder.cpp:    //            could be edge of cylinder
region_cylinder.cpp:    // do not add contact point if r >= cutoff
region_cylinder.cpp:        xp = c1 + del1*radius/r;
region_cylinder.cpp:        yp = c2 + del2*radius/r;
region_cylinder.cpp:    // closest point on curved surface
region_cylinder.cpp:        xp = c1 + del1*radius/r;
region_cylinder.cpp:        yp = c2 + del2*radius/r;
region_cylinder.cpp:      // closest point on bottom cap
region_cylinder.cpp:      // closest point on top cap
region_cylinder.cpp:/* ----------------------------------------------------------------------
region_cylinder.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp:/* ----------------------------------------------------------------------
region_cylinder.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp:/* ----------------------------------------------------------------------
region_cylinder.cpp:   called once per timestep by fix/wall/gran/region.
region_cylinder.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp:/* ----------------------------------------------------------------------
region_cylinder.cpp:------------------------------------------------------------------------- */
region_cylinder.cpp:  double delx, dely, delz; // Displacement of contact point in x,y,z
region_cylinder.cpp:    dely = (xc[1] - xcenter[1])*(1 - rprev/radius);
region_cylinder.cpp:    delz = (xc[2] - xcenter[2])*(1 - rprev/radius);
region_cylinder.cpp:    delx = (xc[0] - xcenter[0])*(1 - rprev/radius);
region_cylinder.cpp:    delz = (xc[2] - xcenter[2])*(1 - rprev/radius);
region_cylinder.cpp:    delx = (xc[0] - xcenter[0])*(1 - rprev/radius);
region_cylinder.cpp:    dely = (xc[1] - xcenter[1])*(1 - rprev/radius);
region_cylinder.cpp:  vwall[0] += delx/update->dt;
region_cylinder.cpp:  vwall[1] += dely/update->dt;
region_cylinder.cpp:  vwall[2] += delz/update->dt;
region_cylinder.cpp:  //printf ("R is %g, prev %g, velocity of wall at %g %g %g is %g %g %g\n",radius,rprev,xc[0],xc[1],xc[2],vwall[0],vwall[1],vwall[2]);
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region_intersect.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ---------------------------------------------------------------------- */
region_intersect.cpp:  // build list of regions to intersect
region_intersect.cpp:  // store sub-region IDs in idsub
region_intersect.cpp:  // this region is variable shape or dynamic if any of sub-regions are
region_intersect.cpp:  // extent of intersection of regions
region_intersect.cpp:  // has bounding box if interior and any sub-region has bounding box
region_intersect.cpp:  // possible contacts = sum of possible contacts in all sub-regions
region_intersect.cpp:  // for near contacts and touching contacts
region_intersect.cpp:/* ---------------------------------------------------------------------- */
region_intersect.cpp:/* ---------------------------------------------------------------------- */
region_intersect.cpp:  // re-build list of sub-regions in case other regions were deleted
region_intersect.cpp:  // error if a sub-region was deleted
region_intersect.cpp:  // init the sub-regions
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:    // increment by cmax instead of tmax to insure
region_intersect.cpp:    // possible wall IDs for sub-regions are non overlapping
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:   (1) flip interior/exterior flag of each sub-region
region_intersect.cpp:   (4) flip interior/exterior flags back to original settings
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:   move/rotate all sub-regions
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:   get translational/angular velocities of all subregions
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:   used by restart of fix/wall/gran/region
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:   region writes its current position/angle
region_intersect.cpp:   needed by fix/wall/gran/region to compute velocity by differencing scheme
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:   region reads its previous position/angle
region_intersect.cpp:   needed by fix/wall/gran/region to compute velocity by differencing scheme
region_intersect.cpp:------------------------------------------------------------------------- */
region_intersect.cpp:/* ----------------------------------------------------------------------
region_intersect.cpp:------------------------------------------------------------------------- */
region_plane.cpp:/* ----------------------------------------------------------------------
region_plane.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region_plane.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region_plane.cpp:------------------------------------------------------------------------- */
region_plane.cpp:/* ---------------------------------------------------------------------- */
region_plane.cpp:  // enforce unit normal
region_plane.cpp:  normal[0] /= sqrt(rsq);
region_plane.cpp:  normal[1] /= sqrt(rsq);
region_plane.cpp:  normal[2] /= sqrt(rsq);
region_plane.cpp:  // plane has no bounding box
region_plane.cpp:/* ---------------------------------------------------------------------- */
region_plane.cpp:/* ----------------------------------------------------------------------
region_plane.cpp:------------------------------------------------------------------------- */
region_plane.cpp:/* ----------------------------------------------------------------------
region_plane.cpp:   no contact if on other side (possible if called from union/intersect)
region_plane.cpp:------------------------------------------------------------------------- */
region_plane.cpp:/* ----------------------------------------------------------------------
region_plane.cpp:   no contact if on other side (possible if called from union/intersect)
region_plane.cpp:------------------------------------------------------------------------- */
region_prism.cpp:/* ----------------------------------------------------------------------
region_prism.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region_prism.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region_prism.cpp:------------------------------------------------------------------------- */
region_prism.cpp:/* ----------------------------------------------------------------------
region_prism.cpp:------------------------------------------------------------------------- */
region_prism.cpp:/* ---------------------------------------------------------------------- */
region_prism.cpp:  // error check
region_prism.cpp:  // prism cannot be 0 thickness in any dim, else inverse blows up
region_prism.cpp:  // non-zero tilt values cannot be used if either dim is INF on both ends
region_prism.cpp:  // extent of prism
region_prism.cpp:  // particle could be close to all 6 planes
region_prism.cpp:  // particle can only touch 3 planes
region_prism.cpp:  // h = transformation matrix from tilt coords (0-1) to box coords (xyz)
region_prism.cpp:  // columns of h are edge vectors of tilted box
region_prism.cpp:  // hinv = transformation matrix from box coords to tilt coords
region_prism.cpp:  // both h and hinv are upper triangular
region_prism.cpp:  //   since 1st edge of prism is along x-axis
region_prism.cpp:  //   and bottom face of prism is in xy plane
region_prism.cpp:  hinv[0][0] = 1.0/h[0][0];
region_prism.cpp:  hinv[0][1] = -h[0][1] / (h[0][0]*h[1][1]);
region_prism.cpp:  hinv[0][2] = (h[0][1]*h[1][2] - h[0][2]*h[1][1]) / (h[0][0]*h[1][1]*h[2][2]);
region_prism.cpp:  hinv[1][1] = 1.0/h[1][1];
region_prism.cpp:  hinv[1][2] = -h[1][2] / (h[1][1]*h[2][2]);
region_prism.cpp:  hinv[2][2] = 1.0/h[2][2];
region_prism.cpp:  // corners = 8 corner points of prism
region_prism.cpp:  // order = x varies fastest, then y, finally z
region_prism.cpp:  // clo/chi = lo and hi corner pts of prism
region_prism.cpp:  // face = 6 inward-facing unit normals to prism faces
region_prism.cpp:  // order = xy plane, xz plane, yz plane
region_prism.cpp:  // remap open face indices to be consistent
region_prism.cpp:  // tri = 3 vertices (0-7) in each of 12 triangles on 6 faces
region_prism.cpp:  // verts in each tri are ordered so that right-hand rule gives inward norm
region_prism.cpp:  // order = xy plane, xz plane, yz plane
region_prism.cpp:/* ---------------------------------------------------------------------- */
region_prism.cpp:/* ----------------------------------------------------------------------
region_prism.cpp:   abc = Hinv * (xyz - xyz/lo)
region_prism.cpp:   xyz/lo = lower-left corner of prism
region_prism.cpp:------------------------------------------------------------------------- */
region_prism.cpp:/* ----------------------------------------------------------------------
region_prism.cpp:   no contact if outside (possible if called from union/intersect)
region_prism.cpp:------------------------------------------------------------------------- */
region_prism.cpp:  // x is exterior to prism
region_prism.cpp:  // x is interior to prism or on its surface
region_prism.cpp:/* ----------------------------------------------------------------------
region_prism.cpp:   no contact if inside (possible if called from union/intersect)
region_prism.cpp:------------------------------------------------------------------------- */
region_prism.cpp:  // x is far enough from prism that there is no contact
region_prism.cpp:  // x is interior to prism
region_prism.cpp:  // x is exterior to prism or on its surface
region_prism.cpp:  // xp,yp,zp = point on surface of prism that x is closest to
region_prism.cpp:  //            could be edge or corner pt of prism
region_prism.cpp:  // do not add contact point if r >= cutoff
region_prism.cpp:/* ----------------------------------------------------------------------
region_prism.cpp:------------------------------------------------------------------------- */
region_prism.cpp:  // generate successive xnear points, one nearest to x is (xp,yp,zp)
region_prism.cpp:  // loop over 6 faces and 2 triangles in each face
region_prism.cpp:  // xproj = x projected to plane of triangle
region_prism.cpp:  // if xproj is inside or on triangle boundary, that is xnear
region_prism.cpp:  // else: loop over 3 edges of triangle
region_prism.cpp:  //       compute distance to edge line
region_prism.cpp:  //       xnear = nearest point on line to xproj, bounded by segment end pts
region_prism.cpp:    iface = itri/2;
region_prism.cpp:/* ----------------------------------------------------------------------
region_prism.cpp:------------------------------------------------------------------------- */
region_prism.cpp:/* ---------------------------------------------------------------------- */
region_sphere.cpp:/* ----------------------------------------------------------------------
region_sphere.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region_sphere.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region_sphere.cpp:------------------------------------------------------------------------- */
region_sphere.cpp:/* ---------------------------------------------------------------------- */
region_sphere.cpp:  // error check
region_sphere.cpp:  // extent of sphere
region_sphere.cpp:  // for variable radius, uses initial radius
region_sphere.cpp:/* ---------------------------------------------------------------------- */
region_sphere.cpp:/* ---------------------------------------------------------------------- */
region_sphere.cpp:/* ----------------------------------------------------------------------
region_sphere.cpp:------------------------------------------------------------------------- */
region_sphere.cpp:/* ----------------------------------------------------------------------
region_sphere.cpp:   no contact if outside (possible if called from union/intersect)
region_sphere.cpp:------------------------------------------------------------------------- */
region_sphere.cpp:    contact[0].delx = delx*(1.0-radius/r);
region_sphere.cpp:    contact[0].dely = dely*(1.0-radius/r);
region_sphere.cpp:    contact[0].delz = delz*(1.0-radius/r);
region_sphere.cpp:/* ----------------------------------------------------------------------
region_sphere.cpp:   no contact if inside (possible if called from union/intersect)
region_sphere.cpp:------------------------------------------------------------------------- */
region_sphere.cpp:    contact[0].delx = delx*(1.0-radius/r);
region_sphere.cpp:    contact[0].dely = dely*(1.0-radius/r);
region_sphere.cpp:    contact[0].delz = delz*(1.0-radius/r);
region_sphere.cpp:/* ----------------------------------------------------------------------
region_sphere.cpp:------------------------------------------------------------------------- */
region_sphere.cpp:/* ----------------------------------------------------------------------
region_sphere.cpp:------------------------------------------------------------------------- */
region_sphere.cpp:/* ----------------------------------------------------------------------
region_sphere.cpp:   called once per timestep by fix/wall/gran/region.
region_sphere.cpp:------------------------------------------------------------------------- */
region_sphere.cpp:/* ----------------------------------------------------------------------
region_sphere.cpp:------------------------------------------------------------------------- */
region_sphere.cpp:  double delx, dely, delz; // Displacement of contact point in x,y,z
region_sphere.cpp:  delx = (xc[0] - xcenter[0])*(1 - rprev/radius);
region_sphere.cpp:  dely = (xc[1] - xcenter[1])*(1 - rprev/radius);
region_sphere.cpp:  delz = (xc[2] - xcenter[2])*(1 - rprev/radius);
region_sphere.cpp:  vwall[0] += delx/update->dt;
region_sphere.cpp:  vwall[1] += dely/update->dt;
region_sphere.cpp:  vwall[2] += delz/update->dt;
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
region_union.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ---------------------------------------------------------------------- */
region_union.cpp:  // build list of region indices to union
region_union.cpp:  // store sub-region IDs in idsub
region_union.cpp:  // this region is variable shape or dynamic if any of sub-regions are
region_union.cpp:  // extent of union of regions
region_union.cpp:  // has bounding box if interior and all sub-regions have bounding box
region_union.cpp:  // possible contacts = sum of possible contacts in all sub-regions
region_union.cpp:  // for near contacts and touching contacts
region_union.cpp:/* ---------------------------------------------------------------------- */
region_union.cpp:/* ---------------------------------------------------------------------- */
region_union.cpp:  // re-build list of sub-regions in case other regions were deleted
region_union.cpp:  // error if a sub-region was deleted
region_union.cpp:  // init the sub-regions
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:    // increment by cmax instead of tmax to insure
region_union.cpp:    // possible wall IDs for sub-regions are non overlapping
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:   (1) flip interior/exterior flag of each sub-region
region_union.cpp:   (4) flip interior/exterior flags back to original settings
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:   move/rotate all sub-regions
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:   get translational/angular velocities of all subregions
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:   used by restart of fix/wall/gran/region
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:   region writes its current position/angle
region_union.cpp:   needed by fix/wall/gran/region to compute velocity by differencing scheme
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:   region reads its previous position/angle
region_union.cpp:   needed by fix/wall/gran/region to compute velocity by differencing scheme
region_union.cpp:------------------------------------------------------------------------- */
region_union.cpp:/* ----------------------------------------------------------------------
region_union.cpp:------------------------------------------------------------------------- */
replicate.cpp:/* ----------------------------------------------------------------------
replicate.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
replicate.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
replicate.cpp:------------------------------------------------------------------------- */
replicate.cpp:enum{LAYOUT_UNIFORM,LAYOUT_NONUNIFORM,LAYOUT_TILED};    // several files
replicate.cpp:/* ---------------------------------------------------------------------- */
replicate.cpp:/* ---------------------------------------------------------------------- */
replicate.cpp:  // nrep = total # of replications
replicate.cpp:  // error and warning checks
replicate.cpp:  // maxtag = largest atom tag across all existing atoms
replicate.cpp:  // maxmol = largest molecule tag across all existing atoms
replicate.cpp:  // unmap existing atoms via image flags
replicate.cpp:  // communication buffer for all my atom's info
replicate.cpp:  // max_size = largest buffer needed by any proc
replicate.cpp:  // must do before new Atom class created,
replicate.cpp:  //   since size_restart() uses atom->nlocal
replicate.cpp:  // old = original atom class
replicate.cpp:  // atom = new replicated atom class
replicate.cpp:  // also set atomKK for Kokkos version of Atom class
replicate.cpp:  // check that new system will not be too large
replicate.cpp:  // new tags cannot exceed MAXTAGINT
replicate.cpp:  // new system sizes cannot exceed MAXBIGINT
replicate.cpp:  // assign atom and topology counts in new class from old one
replicate.cpp:  // store old simulation box
replicate.cpp:  // setup new simulation box
replicate.cpp:  // new problem setup using new box boundaries
replicate.cpp:  else n = static_cast<int> (LB_FACTOR * atom->natoms / nprocs);
replicate.cpp:  // copy type arrays to new atom class
replicate.cpp:  // set bounds for my proc
replicate.cpp:  // if periodic and I am lo/hi proc, adjust bounds by EPSILON
replicate.cpp:  // insures all replicated atoms will be owned even with round-off
replicate.cpp:  // loop over all procs
replicate.cpp:  // if this iteration of loop is me:
replicate.cpp:  //   pack my unmapped atom data into buf
replicate.cpp:  //   bcast it to all other procs
replicate.cpp:  // performs 3d replicate loop with while loop over atoms in buf
replicate.cpp:  //   x = new replicated position, remapped into simulation box
replicate.cpp:  //   unpack atom into new atom class from buf if I own it
replicate.cpp:  //   adjust tag, mol #, coord, topology info as needed
replicate.cpp:          // while loop over one proc's atom list
replicate.cpp:  // free communication buffer and old atom class
replicate.cpp:  // check that all atoms were assigned to procs
replicate.cpp:  // check that atom IDs are valid
replicate.cpp:  // create global mapping of atoms
replicate.cpp:  // create special bond lists for molecular systems
rerun.cpp:/* ----------------------------------------------------------------------
rerun.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
rerun.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
rerun.cpp:------------------------------------------------------------------------- */
rerun.cpp:/* ---------------------------------------------------------------------- */
rerun.cpp:/* ---------------------------------------------------------------------- */
rerun.cpp:  // list of dump files = args until a keyword
rerun.cpp:  // parse optional args up until "dump"
rerun.cpp:  // user MAXBIGINT -1 so Output can add 1 to it and still be a big int
rerun.cpp:  // pass list of filenames to ReadDump
rerun.cpp:  // along with post-"dump" args and post-"format" args
rerun.cpp:  // perform the pseudo run
rerun.cpp:  // invoke lmp->init() only once
rerun.cpp:  // read all relevant snapshots
rerun.cpp:  // use setup_minimal() since atoms are already owned by correct procs
rerun.cpp:  // addstep_compute_all() insures energy/virial computed on every snapshot
rerun.cpp:  // insure thermo output on last dump timestep
rerun.cpp:  // set update->nsteps to ndump for Finish stats to print
rerun.cpp:  // clean-up
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
respa.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:/* ---------------------------------------------------------------------- */
respa.cpp:  // set level at which each force is computed
respa.cpp:  // argument settings override defaults
respa.cpp:  // defaults for hybrid pair styles
respa.cpp:      // the hybrid keyword requires a hybrid pair style
respa.cpp:      // each hybrid sub-style needs to be assigned to a respa level
respa.cpp:  // cannot specify both pair and inner/middle/outer
respa.cpp:    error->all(FLERR,"Cannot set both respa pair and inner/middle/outer");
respa.cpp:  // if either inner and outer is specified, then both must be
respa.cpp:  // middle cannot be set without inner/outer
respa.cpp:    error->all(FLERR,"Cannot set respa middle without inner/outer");
respa.cpp:  // cannot combine hybrid with any of pair/inner/middle/outer
respa.cpp:               "any of pair/inner/middle/outer");
respa.cpp:  // set defaults if user did not specify level
respa.cpp:  // bond to innermost level
respa.cpp:  // angle same as bond, dihedral same as angle, improper same as dihedral
respa.cpp:  // pair to outermost level if no inner/middle/outer
respa.cpp:  // inner/middle/outer have no defaults
respa.cpp:  // kspace same as pair or outer
respa.cpp:  // print respa levels
respa.cpp:  // check that levels are in correct order
respa.cpp:  // warn if any levels are devoid of forces
respa.cpp:  // check cutoff consistency if inner/middle/outer are enabled
respa.cpp:  // set outer pair of cutoffs to inner pair if middle is not enabled
respa.cpp:  // ensure that pair->compute() is run properly
respa.cpp:  // when the hybrid keyword is not used
respa.cpp:  // allocate other needed arrays
respa.cpp:/* ---------------------------------------------------------------------- */
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:  // warn if no fixes
respa.cpp:  // create fix needed for storing atom-based respa level forces
respa.cpp:  // will delete it at end of run
respa.cpp:  // if supported, we also store torques on a per-level basis
respa.cpp:  // insure respa inner/middle/outer is using Pair class that supports it
respa.cpp:      error->all(FLERR,"Pair style does not support rRESPA inner/middle/outer");
respa.cpp:  // virial_style = 1 (explicit) since never computed implicitly like Verlet
respa.cpp:  // setup lists of computes for global and per-atom PE and pressure
respa.cpp:  // detect if fix omp is present and will clear force arrays
respa.cpp:  // set flags for arrays to clear in force_clear()
respa.cpp:  // step[] = timestep for each level
respa.cpp:    step[ilevel] = step[ilevel+1]/loop[ilevel];
respa.cpp:  // set newton flag for each level
respa.cpp:  // orthogonal vs triclinic simulation box
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:  // setup domain, communication and neighboring
respa.cpp:  // acquire ghosts
respa.cpp:  // build neighbor lists
respa.cpp:  // compute all forces
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:  // setup domain, communication and neighboring
respa.cpp:  // acquire ghosts
respa.cpp:  // build neighbor lists
respa.cpp:  // compute all forces
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:    // needed in case end_of_step() or output() use total force
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:/* ---------------------------------------------------------------------- */
respa.cpp:    step[ilevel] = step[ilevel+1]/loop[ilevel];
respa.cpp:/* ---------------------------------------------------------------------- */
respa.cpp:    // at outermost level, check on rebuilding neighbor list
respa.cpp:    // at innermost level, communicate
respa.cpp:    // at middle levels, do nothing
respa.cpp:    // rRESPA recursion thru all levels
respa.cpp:    // this used to be before neigh list build,
respa.cpp:    // which prevented per-atom energy/stress being tallied correctly
respa.cpp:    // b/c atoms migrated to new procs between short/long force calls
respa.cpp:    // now they migrate at very start of rRESPA timestep, before all forces
respa.cpp:    // force computations
respa.cpp:    // important that ordering is same as Verlet
respa.cpp:    // so that any order dependencies are the same
respa.cpp:    // when potentials are invoked at same level
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:  // clear global force array
respa.cpp:  // if either newton flag is set, also include ghosts
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:/* ----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
respa.cpp:/*-----------------------------------------------------------------------
respa.cpp:------------------------------------------------------------------------- */
run.cpp:/* ----------------------------------------------------------------------
run.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
run.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
run.cpp:------------------------------------------------------------------------- */
run.cpp:/* ---------------------------------------------------------------------- */
run.cpp:/* ---------------------------------------------------------------------- */
run.cpp:  // ignore run command, if walltime limit was already reached
run.cpp:  // parse optional args
run.cpp:      // all remaining args are commands
run.cpp:      // first,last = arg index of first/last commands
run.cpp:      // set ncommands = 0 if single command and it is NULL
run.cpp:  // set nsteps as integer, using upto value if specified
run.cpp:  // error check
run.cpp:      error->all(FLERR,"Invalid run command start/stop value");
run.cpp:      error->all(FLERR,"Invalid run command start/stop value");
run.cpp:  // if nevery, make copies of arg strings that are commands
run.cpp:  // required because re-parsing commands via input->one() will wipe out args
run.cpp:  // perform a single run
run.cpp:  // use start/stop to set begin/end step
run.cpp:  // if pre or 1st run, do System init/setup,
run.cpp:  //   else just init timer and setup output
run.cpp:  // if post, do full Finish, else just print time
run.cpp:  // perform multiple runs optionally interleaved with invocation command(s)
run.cpp:  // use start/stop to set begin/end step
run.cpp:  // if pre or 1st iteration of multiple runs, do System init/setup,
run.cpp:  //   else just init timer and setup output
run.cpp:  // if post or last iteration, do full Finish, else just print time
run.cpp:      // wrap command invocation with clearstep/addstep
run.cpp:      // since a command may invoke computes via variables
set.cpp:/* ----------------------------------------------------------------------
set.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
set.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
set.cpp:------------------------------------------------------------------------- */
set.cpp:/* ---------------------------------------------------------------------- */
set.cpp:  // style and ID info
set.cpp:  // loop over keyword/value pairs
set.cpp:  // call appropriate routine to reset attributes
set.cpp:    } else if (strcmp(arg[iarg],"type/fraction") == 0) {
set.cpp:    } else if (strcmp(arg[iarg],"dipole/random") == 0) {
set.cpp:    } else if (strcmp(arg[iarg],"spin/random") == 0) {
set.cpp:    } else if (strcmp(arg[iarg],"quat/random") == 0) {
set.cpp:        dvalue *= MY_PI/180.0;
set.cpp:    } else if (strcmp(arg[iarg],"theta/random") == 0) {
set.cpp:               (strcmp(arg[iarg],"density/disc") == 0)) {
set.cpp:      if (strcmp(arg[iarg],"density/disc") == 0) {
set.cpp:          error->all(FLERR,"Density/disc option requires 2d simulation");
set.cpp:    } else if (strcmp(arg[iarg],"meso/e") == 0) {
set.cpp:        error->all(FLERR,"Cannot set meso/e for this atom style");
set.cpp:    } else if (strcmp(arg[iarg],"meso/cv") == 0) {
set.cpp:            error->all(FLERR,"Cannot set meso/cv for this atom style");
set.cpp:    } else if (strcmp(arg[iarg],"meso/rho") == 0) {
set.cpp:        error->all(FLERR,"Cannot set meso/rho for this atom style");
set.cpp:    } else if (strcmp(arg[iarg],"smd/mass/density") == 0) {
set.cpp:            error->all(FLERR,"Cannot set smd/mass/density for this atom style");
set.cpp:    } else if (strcmp(arg[iarg],"smd/contact/radius") == 0) {
set.cpp:            error->all(FLERR,"Cannot set smd/contact/radius "
set.cpp:    } else if (strcmp(arg[iarg],"dpd/theta") == 0) {
set.cpp:        error->all(FLERR,"Cannot set dpd/theta for this atom style");
set.cpp:    // statistics
set.cpp:  // free local memory
set.cpp:/* ----------------------------------------------------------------------
set.cpp:------------------------------------------------------------------------- */
set.cpp:/* ----------------------------------------------------------------------
set.cpp:------------------------------------------------------------------------- */
set.cpp:  // evaluate atom-style variable(s) if necessary
set.cpp:  // loop over selected atoms
set.cpp:    // overwrite dvalue, ivalue, xyzw value if variables defined
set.cpp:    // else the input script scalar value remains in place
set.cpp:    // set values in per-atom arrays
set.cpp:    // error check here in case atom-style variables generated bogus value
set.cpp:      // set mass from volume and supplied mass density
set.cpp:        double tfactor = force->mvv2e / (domain->dimension * force->boltz);
set.cpp:    // set shape of ellipsoidal particle
set.cpp:    // set length of line particle
set.cpp:    // set corners of tri particle
set.cpp:    // set rmass via density
set.cpp:    // if radius > 0.0, treat as sphere or disc
set.cpp:    // if shape > 0.0, treat as ellipsoid (or ellipse, when uncomment below)
set.cpp:    // if length > 0.0, treat as line
set.cpp:    // if area > 0.0, treat as tri
set.cpp:    // else set rmass to density directly
set.cpp:          atom->rmass[i] = 4.0*MY_PI/3.0 * 
set.cpp:        // enable 2d ellipse (versus 3d ellipsoid) when time integration
set.cpp:        //   options (fix nve/asphere, fix nh/asphere) are also implemented
set.cpp:        // if (discflag) 
set.cpp:        // atom->rmass[i] = MY_PI*shape[0]*shape[1] * dvalue;
set.cpp:	// else 
set.cpp:        atom->rmass[i] = 4.0*MY_PI/3.0 * shape[0]*shape[1]*shape[2] * dvalue;
set.cpp:    // set dipole moment
set.cpp:    // set magnetic moments
set.cpp:      sp[i][0] = xvalue/sp_norm;
set.cpp:      sp[i][1] = yvalue/sp_norm;
set.cpp:      sp[i][2] = zvalue/sp_norm;
set.cpp:                      sp[i][2]*sp[i][2]); //Should be 1 for atomic spins
set.cpp:    // set quaternion orientation of ellipsoid or tri or body particle
set.cpp:    // set quaternion orientation of ellipsoid or tri or body particle
set.cpp:    // enforce quat rotation vector in z dir for 2d systems
set.cpp:      double theta2 = MY_PI2 * wvalue/180.0;
set.cpp:    // set theta of line particle
set.cpp:    // set angmom or omega of particle
set.cpp:    // reset any or all of 3 image flags
set.cpp:    // set value for custom integer or double vector
set.cpp:  // clear up per-atom memory if allocated
set.cpp:/* ----------------------------------------------------------------------
set.cpp:------------------------------------------------------------------------- */
set.cpp:  // set fraction of atom types to newtype
set.cpp:  // set dipole moments to random orientations in 3d or 2d
set.cpp:  // dipole length is determined by dipole type array
set.cpp:          scale = dvalue/sqrt(msq);
set.cpp:          scale = dvalue/sqrt(msq);
set.cpp:  // set spin moments to random orientations in 3d or 2d
set.cpp:  // spin length is fixed to unity
set.cpp:          scale = 1.0/sqrt(sp_sq);
set.cpp:          scale = 1.0/sqrt(sp_sq);
set.cpp:  // set quaternions to random orientations in 3d and 2d
set.cpp:  // set theta to random orientation in 2d
set.cpp:/* ---------------------------------------------------------------------- */
set.cpp:  // error check
set.cpp:  // border swap to acquire ghost atom info
set.cpp:  // enforce PBC before in case atoms are outside box
set.cpp:  // init entire system since comm->exchange is done
set.cpp:  // comm::init needs neighbor::init needs pair::init needs kspace::init, etc
set.cpp:  // select both owned and ghost atoms
set.cpp:  // for BOND, each of 2 atoms must be in group
set.cpp:  // for ANGLE, each of 3 atoms must be in group
set.cpp:  // for DIHEDRAL, each of 4 atoms must be in group
set.cpp:  // for IMPROPER, each of 4 atoms must be in group
set.cpp:/* ---------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
special.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
special.cpp:------------------------------------------------------------------------- */
special.cpp:// allocate space for static class variable
special.cpp:/* ---------------------------------------------------------------------- */
special.cpp:/* ---------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:  // initialize nspecial counters to 0
special.cpp:  // -----------------------------------------------------
special.cpp:  // compute nspecial[i][0] = # of 1-2 neighbors of atom i
special.cpp:  // -----------------------------------------------------
special.cpp:  // bond partners stored by atom itself
special.cpp:  // if newton_bond off, then done
special.cpp:  // else only counted 1/2 of all bonds, so count other half
special.cpp:    // nbufmax = largest buffer needed to hold info from any proc
special.cpp:    // info for each atom = global tag of 2nd atom in each bond
special.cpp:    // fill buffer with global tags of bond partners of my atoms
special.cpp:    // cycle buffer around ring of procs back to self
special.cpp:    // when receive buffer, scan tags for atoms I own
special.cpp:    // when find one, increment nspecial count for that atom
special.cpp:  // ----------------------------------------------------
special.cpp:  // create onetwo[i] = list of 1-2 neighbors for atom i
special.cpp:  // ----------------------------------------------------
special.cpp:  // count = accumulating counter
special.cpp:  // add bond partners stored by atom to onetwo list
special.cpp:  // if newton_bond off, then done
special.cpp:  // else only stored 1/2 of all bonds, so store other half
special.cpp:    // nbufmax = largest buffer needed to hold info from any proc
special.cpp:    // info for each atom = 2 global tags in each bond
special.cpp:    // fill buffer with global tags of both atoms in bond
special.cpp:    // cycle buffer around ring of procs back to self
special.cpp:    // when receive buffer, scan 2nd-atom tags for atoms I own
special.cpp:    // when find one, add 1st-atom tag to onetwo list for 2nd atom
special.cpp:  // -----------------------------------------------------
special.cpp:  // done if special_bond weights for 1-3, 1-4 are set to 1.0
special.cpp:  // -----------------------------------------------------
special.cpp:  // -----------------------------------------------------
special.cpp:  // compute nspecial[i][1] = # of 1-3 neighbors of atom i
special.cpp:  // -----------------------------------------------------
special.cpp:  // nbufmax = largest buffer needed to hold info from any proc
special.cpp:  // info for each atom = 2 scalars + list of 1-2 neighbors
special.cpp:  // fill buffer with:
special.cpp:  // (1) = counter for 1-3 neighbors, initialized to 0
special.cpp:  // (2) = # of 1-2 neighbors
special.cpp:  // (3:N) = list of 1-2 neighbors
special.cpp:  // cycle buffer around ring of procs back to self
special.cpp:  // when receive buffer, scan list of 1-2 neighbors for atoms I own
special.cpp:  // when find one, increment 1-3 count by # of 1-2 neighbors of my atom,
special.cpp:  //   subtracting one since my list will contain original atom
special.cpp:  // extract count from buffer that has cycled back to me
special.cpp:  // nspecial[i][1] = # of 1-3 neighbors of atom i
special.cpp:  // ----------------------------------------------------
special.cpp:  // create onethree[i] = list of 1-3 neighbors for atom i
special.cpp:  // ----------------------------------------------------
special.cpp:  // nbufmax = largest buffer needed to hold info from any proc
special.cpp:  // info for each atom = 4 scalars + list of 1-2 neighs + list of 1-3 neighs
special.cpp:  // fill buffer with:
special.cpp:  // (1) = global tag of original atom
special.cpp:  // (2) = # of 1-2 neighbors
special.cpp:  // (3) = # of 1-3 neighbors
special.cpp:  // (4) = counter for 1-3 neighbors, initialized to 0
special.cpp:  // (5:N) = list of 1-2 neighbors
special.cpp:  // (N+1:2N) space for list of 1-3 neighbors
special.cpp:  // cycle buffer around ring of procs back to self
special.cpp:  // when receive buffer, scan list of 1-2 neighbors for atoms I own
special.cpp:  // when find one, add its neighbors to 1-3 list
special.cpp:  //   increment the count in buf(i+4)
special.cpp:  //   exclude the atom whose tag = original
special.cpp:  //   this process may include duplicates but they will be culled later
special.cpp:  // fill onethree with buffer values that have been returned to me
special.cpp:  // sanity check: accumulated buf[i+3] count should equal
special.cpp:  //   nspecial[i][1] for each atom
special.cpp:  // done if special_bond weights for 1-4 are set to 1.0
special.cpp:  // -----------------------------------------------------
special.cpp:  // compute nspecial[i][2] = # of 1-4 neighbors of atom i
special.cpp:  // -----------------------------------------------------
special.cpp:  // nbufmax = largest buffer needed to hold info from any proc
special.cpp:  // info for each atom = 2 scalars + list of 1-3 neighbors
special.cpp:  // fill buffer with:
special.cpp:  // (1) = counter for 1-4 neighbors, initialized to 0
special.cpp:  // (2) = # of 1-3 neighbors
special.cpp:  // (3:N) = list of 1-3 neighbors
special.cpp:  // cycle buffer around ring of procs back to self
special.cpp:  // when receive buffer, scan list of 1-3 neighbors for atoms I own
special.cpp:  // when find one, increment 1-4 count by # of 1-2 neighbors of my atom
special.cpp:  //   may include duplicates and original atom but they will be culled later
special.cpp:  // extract count from buffer that has cycled back to me
special.cpp:  // nspecial[i][2] = # of 1-4 neighbors of atom i
special.cpp:  // ----------------------------------------------------
special.cpp:  // create onefour[i] = list of 1-4 neighbors for atom i
special.cpp:  // ----------------------------------------------------
special.cpp:  // nbufmax = largest buffer needed to hold info from any proc
special.cpp:  // info for each atom = 3 scalars + list of 1-3 neighs + list of 1-4 neighs
special.cpp:  // fill buffer with:
special.cpp:  // (1) = # of 1-3 neighbors
special.cpp:  // (2) = # of 1-4 neighbors
special.cpp:  // (3) = counter for 1-4 neighbors, initialized to 0
special.cpp:  // (4:N) = list of 1-3 neighbors
special.cpp:  // (N+1:2N) space for list of 1-4 neighbors
special.cpp:  // cycle buffer around ring of procs back to self
special.cpp:  // when receive buffer, scan list of 1-3 neighbors for atoms I own
special.cpp:  // when find one, add its neighbors to 1-4 list
special.cpp:  //   incrementing the count in buf(i+4)
special.cpp:  //   this process may include duplicates but they will be culled later
special.cpp:  // fill onefour with buffer values that have been returned to me
special.cpp:  // sanity check: accumulated buf[i+2] count should equal
special.cpp:  //  nspecial[i][2] for each atom
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:  // clear map so it can be used as scratch space
special.cpp:  // use map to cull duplicates
special.cpp:  // exclude original atom explicitly
special.cpp:  // adjust onetwo, onethree, onefour values to reflect removed duplicates
special.cpp:  // must unset map for each atom
special.cpp:  // re-create map
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:  // ----------------------------------------------------
special.cpp:  // compute culled maxspecial = max # of special neighs of any atom
special.cpp:  // ----------------------------------------------------
special.cpp:  // clear map so it can be used as scratch space
special.cpp:  // unique = # of unique nspecial neighbors of one atom
special.cpp:  // cull duplicates using map to check for them
special.cpp:  // exclude original atom explicitly
special.cpp:  // must unset map for each atom
special.cpp:  // compute global maxspecial, must be at least 1
special.cpp:  // add in extra factor from special_bonds command
special.cpp:  // allocate correct special array with same nmax, new maxspecial
special.cpp:  // previously allocated one must be destroyed
special.cpp:  // must make AtomVec class update its ptr to special
special.cpp:  // ----------------------------------------------------
special.cpp:  // fill special array with 1-2, 1-3, 1-4 neighs for each atom
special.cpp:  // ----------------------------------------------------
special.cpp:  // again use map to cull duplicates
special.cpp:  // exclude original atom explicitly
special.cpp:  // adjust nspecial[i] values to reflect removed duplicates
special.cpp:  // nspecial[i][1] and nspecial[i][2] now become cumulative counters
special.cpp:  // re-create map
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:  // stats on old 1-3 neighbor counts
special.cpp:  // if angles or dihedrals are defined,
special.cpp:  // flag each 1-3 neigh if it appears in an angle or dihedral
special.cpp:    // dflag = flag for 1-3 neighs of all owned atoms
special.cpp:    // nbufmax = largest buffer needed to hold info from any proc
special.cpp:    // info for each atom = list of 1,3 atoms in each angle stored by atom
special.cpp:    //   and list of 1,3 and 2,4 atoms in each dihedral stored by atom
special.cpp:    // fill buffer with list of 1,3 atoms in each angle
special.cpp:    // and with list of 1,3 and 2,4 atoms in each dihedral
special.cpp:    // cycle buffer around ring of procs back to self
special.cpp:    // when receive buffer, scan list of 1,3 atoms looking for atoms I own
special.cpp:    // when find one, scan its 1-3 neigh list and mark I,J as in an angle
special.cpp:    // delete 1-3 neighbors if they are not flagged in dflag
special.cpp:    // clean up
special.cpp:  // if no angles or dihedrals are defined, delete all 1-3 neighs
special.cpp:  // stats on new 1-3 neighbor counts
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:  // stats on old 1-4 neighbor counts
special.cpp:  // if dihedrals are defined, flag each 1-4 neigh if it appears in a dihedral
special.cpp:    // dflag = flag for 1-4 neighs of all owned atoms
special.cpp:    // nbufmax = largest buffer needed to hold info from any proc
special.cpp:    // info for each atom = list of 1,4 atoms in each dihedral stored by atom
special.cpp:    // fill buffer with list of 1,4 atoms in each dihedral
special.cpp:    // cycle buffer around ring of procs back to self
special.cpp:    // when receive buffer, scan list of 1,4 atoms looking for atoms I own
special.cpp:    // when find one, scan its 1-4 neigh list and mark I,J as in a dihedral
special.cpp:    // delete 1-4 neighbors if they are not flagged in dflag
special.cpp:    // clean up
special.cpp:  // if no dihedrals are defined, delete all 1-4 neighs
special.cpp:  // stats on new 1-4 neighbor counts
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
special.cpp:/* ----------------------------------------------------------------------
special.cpp:------------------------------------------------------------------------- */
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
thermo.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:// lmptype.h must be first b/c this file uses MAXBIGINT and includes mpi.h
thermo.cpp:// due to OpenMPI bug which sets INT64_MAX via its mpi.h
thermo.cpp://   before lmptype.h can set flags to insure it is done correctly
thermo.cpp:// customize a new keyword by adding to this list:
thermo.cpp:// step, elapsed, elaplong, dt, time, cpu, tpcpu, spcpu, cpuremain, 
thermo.cpp:// part, timeremain
thermo.cpp:// atoms, temp, press, pe, ke, etotal, enthalpy
thermo.cpp:// evdwl, ecoul, epair, ebond, eangle, edihed, eimp, emol, elong, etail
thermo.cpp:// vol, density, lx, ly, lz, xlo, xhi, ylo, yhi, zlo, zhi, xy, xz, yz,
thermo.cpp:// xlat, ylat, zlat
thermo.cpp:// bonds, angles, dihedrals, impropers,
thermo.cpp:// pxx, pyy, pzz, pxy, pxz, pyz
thermo.cpp:// fmax, fnorm, nbuild, ndanger,
thermo.cpp:// cella, cellb, cellc, cellalpha, cellbeta, cellgamma
thermo.cpp:// customize a new thermo style by adding a DEFINE to this list
thermo.cpp:// also insure allocation of line string is correct in constructor
thermo.cpp:enum{IGNORE,WARN,ERROR};           // same as several files
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  // set thermo_modify defaults
thermo.cpp:  // set style and corresponding lineflag
thermo.cpp:  // custom style builds its own line of keywords, including wildcard expansion
thermo.cpp:  // customize a new thermo style by adding to if statement
thermo.cpp:  // allocate line string used for 3 tasks
thermo.cpp:  //   concat of custom style args
thermo.cpp:  //   one-time thermo output of header line
thermo.cpp:  //   each line of numeric thermo output
thermo.cpp:  //   256 = extra for ONE or MULTI string or multi formatting
thermo.cpp:  //   64 = max per-arg chars in header or numeric output
thermo.cpp:    // expand args if any have wildcard character "*"
thermo.cpp:    // if wildcard expansion occurred, free earg memory from exapnd_args()
thermo.cpp:  // ptrs, flags, IDs for compute objects thermo may use or create
thermo.cpp:  // count fields in line
thermo.cpp:  // allocate per-field memory
thermo.cpp:  // process line of keywords
thermo.cpp:  // format strings
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  // format strings
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  // set normvalue to default setting unless user has specified it
thermo.cpp:  // add Volume field if volume changes and not style = custom
thermo.cpp:  // this check must come after domain init, so box_change is set
thermo.cpp:  // set format string for each field
thermo.cpp:  // include keyword if lineflag = MULTILINE
thermo.cpp:  // add '/n' every 3 values if lineflag = MULTILINE
thermo.cpp:  // add trailing '/n' to last value
thermo.cpp:  // find current ptr for each Compute ID
thermo.cpp:  // find current ptr for each Fix ID
thermo.cpp:  // check that fix frequency is acceptable with thermo output frequency
thermo.cpp:  // find current ptr for each Variable ID
thermo.cpp:  // set ptrs to keyword-specific Compute objects
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  // check for lost atoms
thermo.cpp:  // turn off normflag if natoms = 0 to avoid divide by 0
thermo.cpp:  // invoke Compute methods needed for thermo keywords
thermo.cpp:  // if lineflag = MULTILINE, prepend step/cpu header line
thermo.cpp:  // add each thermo value to line with its specific format
thermo.cpp:  // print line to screen and logfile
thermo.cpp:  // set to 1, so that subsequent invocations of CPU time will be non-zero
thermo.cpp:  // e.g. via variables in print command
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:  // ntotal = current # of atoms
thermo.cpp:  // if not checking or already warned, just return
thermo.cpp:  // error message
thermo.cpp:  // warning message
thermo.cpp:  // reset total atom count
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:      // reset id_temp of pressure to new temperature ID
thermo.cpp:      // either pressure currently being used by thermo or "thermo_press"
thermo.cpp:    } else if (strcmp(arg[iarg],"lost/bond") == 0) {
thermo.cpp:        // replace "d" in format_int_user with bigint format specifier
thermo.cpp:        // use of &str[1] removes leading '%' from BIGINT_FORMAT string
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:  // n = specified fields + Volume field (added at run time)
thermo.cpp:  // factor of 3 is max number of computes a single field can add
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:  // customize a new keyword by adding to if statement
thermo.cpp:      addfield("T/CPU",&Thermo::compute_tpcpu,FLOAT);
thermo.cpp:      addfield("S/CPU",&Thermo::compute_spcpu,FLOAT);
thermo.cpp:    // compute value = c_ID, fix value = f_ID, variable value = v_ID
thermo.cpp:    // count trailing [] and store int arguments
thermo.cpp:      // parse zero or one or two trailing brackets from ID
thermo.cpp:      // argindex1,argindex2 = int inside each bracket pair, 0 if no bracket
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:  // turn off normflag if natoms = 0 to avoid divide by 0
thermo.cpp:  // normflag must be set for lo-level thermo routines that may be invoked
thermo.cpp:  // invoke a lo-level thermo routine to compute the variable value
thermo.cpp:  // if keyword requires a compute, error if thermo doesn't use the compute
thermo.cpp:  // if inbetween runs and needed compute is not current, error
thermo.cpp:  // if in middle of run and needed compute is not current, invoke it
thermo.cpp:  // for keywords that use energy (evdwl, ebond, etc):
thermo.cpp:  //   check if energy was tallied on this timestep and set pe->invoked_flag
thermo.cpp:  //   this will trigger next timestep for energy tallying via addstep()
thermo.cpp:  //   this means keywords that use pe (pe, etotal, enthalpy)
thermo.cpp:  //     need to always invoke it even if invoked_flag is set,
thermo.cpp:  //     because evdwl/etc may have set invoked_flag w/out 
thermo.cpp:  //       actually invoking pe->compute_scalar()
thermo.cpp:                 "thermo to use/init temp");
thermo.cpp:                 "thermo to use/init press");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "thermo to use/init temp");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "thermo to use/init temp");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "thermo to use/init temp");
thermo.cpp:                 "thermo to use/init press");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "Thermo keyword in variable requires thermo to use/init pe");
thermo.cpp:                 "thermo to use/init press");
thermo.cpp:                 "thermo to use/init press");
thermo.cpp:                 "thermo to use/init press");
thermo.cpp:                 "thermo to use/init press");
thermo.cpp:                 "thermo to use/init press");
thermo.cpp:                 "thermo to use/init press");
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:   compute/fix are normalized by atoms if returning extensive value
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  // check for out-of-range access if vector/array is variable length
thermo.cpp:    if (normflag && compute->extscalar) dvalue /= natoms;
thermo.cpp:      else if (compute->extvector == 1) dvalue /= natoms;
thermo.cpp:      else if (compute->extlist[argindex1[ifield]-1]) dvalue /= natoms;
thermo.cpp:    if (normflag && compute->extarray) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (normflag && fix->extscalar) dvalue /= natoms;
thermo.cpp:      else if (fix->extvector == 1) dvalue /= natoms;
thermo.cpp:      else if (fix->extlist[argindex1[ifield]-1]) dvalue /= natoms;
thermo.cpp:    if (normflag && fix->extarray) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ----------------------------------------------------------------------
thermo.cpp:   set ivalue/dvalue/bivalue if value is int/double/bigint
thermo.cpp:------------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (time_diff > 0.0 && cpu_diff > 0.0) dvalue = time_diff/cpu_diff;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (cpu_diff > 0.0) dvalue = step_diff/cpu_diff;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:         (update->laststep - update->ntimestep) /
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  if (normflag) ke /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  if (normflag) vtmp /= natoms;
thermo.cpp:  dvalue = etmp + ptmp*vtmp/(force->nktv2p);
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    dvalue += force->pair->etail / volume;
thermo.cpp:  if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    dvalue += force->pair->etail / volume;
thermo.cpp:  if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    dvalue = force->pair->etail / volume;
thermo.cpp:    if (normflag) dvalue /= natoms;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:  dvalue = force->mv2d * mass/dvalue;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    // Cos(alpha) = (xy.xz + ly.yz)/(b.c)
thermo.cpp:    double cosalpha = (h[5]*h[4]+h[1]*h[3])/
thermo.cpp:    dvalue = acos(cosalpha)*180.0/MY_PI;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    // Cos(beta) = xz/c
thermo.cpp:    double cosbeta = h[4]/sqrt(h[2]*h[2]+h[3]*h[3]+h[4]*h[4]);
thermo.cpp:    dvalue = acos(cosbeta)*180.0/MY_PI;
thermo.cpp:/* ---------------------------------------------------------------------- */
thermo.cpp:    // Cos(gamma) = xy/b
thermo.cpp:    double cosgamma = h[5]/sqrt(h[1]*h[1]+h[5]*h[5]);
thermo.cpp:    dvalue = acos(cosgamma)*180.0/MY_PI;
timer.cpp:/* ----------------------------------------------------------------------
timer.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
timer.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
timer.cpp:------------------------------------------------------------------------- */
timer.cpp:#include <sys/time.h>
timer.cpp:#include <sys/resource.h>
timer.cpp:// convert a timespec ([[HH:]MM:]SS) to seconds
timer.cpp:// the strings "off" and "unlimited" result in -1;
timer.cpp:  // first handle allowed textual inputs
timer.cpp:// Return the CPU time for the current process in seconds very
timer.cpp:// much in the same way as MPI_Wtime() returns the wall time.
timer.cpp:  // from MSD docs.
timer.cpp:#else /* ! _WIN32 */
timer.cpp:#endif /* ! _WIN32 */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:  // format timeout setting
timer.cpp:    // time since init_timeout()
timer.cpp:    // remaining timeout in seconds
timer.cpp:    // remaining 1/100ths of seconds
timer.cpp:    // breaking s down into second/minutes/hours
timer.cpp:    s  = (s - seconds) / 60;
timer.cpp:    const int hours = (s - minutes) / 60;
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:  // broadcast time to insure all ranks act the same.
timer.cpp:/* ---------------------------------------------------------------------- */
timer.cpp:/* ----------------------------------------------------------------------
timer.cpp:------------------------------------------------------------------------- */
timer.cpp:    // format timeout setting
universe.cpp:/* ----------------------------------------------------------------------
universe.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
universe.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
universe.cpp:------------------------------------------------------------------------- */
universe.cpp:/* ----------------------------------------------------------------------
universe.cpp:------------------------------------------------------------------------- */
universe.cpp:/* ---------------------------------------------------------------------- */
universe.cpp:/* ----------------------------------------------------------------------
universe.cpp:------------------------------------------------------------------------- */
universe.cpp:      if (i < (n-1)*nprocs/n) uni2orig[i] = i/(n-1) * n + (i % (n-1));
universe.cpp:      else uni2orig[i] = (i - (n-1)*nprocs/n) * n + n-1;
universe.cpp:      // skip header = blank and comment lines
universe.cpp:      // read nprocs lines
universe.cpp:      // uni2orig = inverse mapping
universe.cpp:    // bcast uni2org from proc 0 to all other universe procs
universe.cpp:  // create new uworld communicator
universe.cpp:/* ----------------------------------------------------------------------
universe.cpp:------------------------------------------------------------------------- */
universe.cpp:    // check for valid partition argument
universe.cpp:    // str may not be empty and may only consist of digits or 'x'
universe.cpp:        // 'x' may not be the first or last character
universe.cpp:    // require minimum of 1 partition with 1 processor
universe.cpp:/* ----------------------------------------------------------------------
universe.cpp:------------------------------------------------------------------------- */
universe.cpp:// helper function to convert the LAMMPS date string to a version id
universe.cpp:// that can be used for both string and numerical comparisons
universe.cpp:// where newer versions are larger than older ones.
update.cpp:/* ----------------------------------------------------------------------
update.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
update.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
update.cpp:------------------------------------------------------------------------- */
update.cpp:/* ---------------------------------------------------------------------- */
update.cpp:/* ---------------------------------------------------------------------- */
update.cpp:/* ---------------------------------------------------------------------- */
update.cpp:  // init the appropriate integrate and/or minimize class
update.cpp:  // if neither (e.g. from write_restart) then just return
update.cpp:  // only set first_update if a run or minimize is being performed
update.cpp:/* ---------------------------------------------------------------------- */
update.cpp:  // physical constants from:
update.cpp:  // http://physics.nist.gov/cuu/Constants/Table/allascii.txt
update.cpp:  // using thermochemical calorie = 4.184 J
update.cpp:    force->e_mass = 0.0;    // not yet set
update.cpp:    force->ftm2v = 1.0 / 48.88821291 / 48.88821291;
update.cpp:    force->mv2d = 1.0 / 0.602214129;
update.cpp:    force->e_mass = 1.0/1836.1527556560675;
update.cpp:    force->ftm2v = 1.0 / 1.0364269e-4;
update.cpp:    force->mv2d = 1.0 / 0.602214129;
update.cpp:    force->e_mass = 0.0;    // not yet set
update.cpp:    force->e_mass = 0.0;    // not yet set
update.cpp:    force->e_mass = 0.0;    // not yet set
update.cpp:    force->e_mass = 0.0;    // not yet set
update.cpp:    force->e_mass = 0.0;    // not yet set
update.cpp:    force->e_mass = 0.0;    // not yet set
update.cpp:/* ---------------------------------------------------------------------- */
update.cpp:    if (sflag == 1) sprintf(estyle,"%s/%s",arg[0],lmp->suffix);
update.cpp:    else sprintf(estyle,"%s/%s",arg[0],lmp->suffix2);
update.cpp:/* ----------------------------------------------------------------------
update.cpp:------------------------------------------------------------------------- */
update.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix);
update.cpp:      sprintf(estyle,"%s/%s",style,lmp->suffix2);
update.cpp:/* ----------------------------------------------------------------------
update.cpp:------------------------------------------------------------------------- */
update.cpp:/* ---------------------------------------------------------------------- */
update.cpp:/* ----------------------------------------------------------------------
update.cpp:------------------------------------------------------------------------- */
update.cpp:/* ----------------------------------------------------------------------
update.cpp:------------------------------------------------------------------------- */
update.cpp:/* ----------------------------------------------------------------------
update.cpp:------------------------------------------------------------------------- */
update.cpp:  // set atimestep to new timestep
update.cpp:  // so future update_time() calls will be correct
update.cpp:  // trigger reset of timestep for output
update.cpp:  // do not allow any timestep-dependent fixes to be already defined
update.cpp:  // reset eflag/vflag global so no commands will think eng/virial are current
update.cpp:  // reset invoked flags of computes,
update.cpp:  // so no commands will think they are current between runs
update.cpp:  // clear timestep list of computes that store future invocation times
update.cpp:  // Neighbor Bin/Stencil/Pair classes store timestamps that need to be cleared
update.cpp:  // NOTE: 7Jun12, adding rerun command, don't think this is required
update.cpp:  //for (int i = 0; i < domain->nregion; i++)
update.cpp:  //  if (domain->regions[i]->dynamic_check())
update.cpp:  //    error->all(FLERR,"Cannot reset timestep with a dynamic region defined");
update.cpp:/* ----------------------------------------------------------------------
update.cpp:------------------------------------------------------------------------- */
update.cpp:/* ----------------------------------------------------------------------
update.cpp:   memory usage of update and integrate/minimize
update.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
variable.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:#define VALUELENGTH 64               // also in python.cpp
variable.cpp:// customize by adding a function
variable.cpp:// if add before XOR:
variable.cpp:// also set precedence level in constructor and precedence length in *.h
variable.cpp:// customize by adding a special function
variable.cpp:/* ---------------------------------------------------------------------- */
variable.cpp:  // customize by assigning a precedence level
variable.cpp:/* ---------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // DELETE
variable.cpp:  // doesn't matter if variable no longer exists
variable.cpp:  // INDEX
variable.cpp:  // num = listed args, which = 1st value, data = copied args
variable.cpp:  // LOOP
variable.cpp:  // 1 arg + pad: num = N, which = 1st value, data = single string
variable.cpp:  // 2 args + pad: num = N2, which = N1, data = single string
variable.cpp:  // WORLD
variable.cpp:  // num = listed args, which = partition this proc is in, data = copied args
variable.cpp:  // error check that num = # of worlds in universe
variable.cpp:  // UNIVERSE and ULOOP
variable.cpp:  // for UNIVERSE: num = listed args, data = copied args
variable.cpp:  // for ULOOP: num = N, data = single string
variable.cpp:  // which = partition this proc is in
variable.cpp:  // universe proc 0 creates lock file
variable.cpp:  // error check that all other universe/uloop variables are same length
variable.cpp:      error->all(FLERR,"Universe/uloop variable count < # of partitions");
variable.cpp:                   "All universe/uloop variables must have same # of values");
variable.cpp:  // STRING
variable.cpp:  // replace pre-existing var if also style STRING (allows it to be reset)
variable.cpp:  // num = 1, which = 1st value
variable.cpp:  // data = 1 value, string to eval
variable.cpp:  // GETENV
variable.cpp:  // remove pre-existing var if also style GETENV (allows it to be reset)
variable.cpp:  // num = 1, which = 1st value
variable.cpp:  // data = 1 value, string to eval
variable.cpp:  // SCALARFILE for strings or numbers
variable.cpp:  // which = 1st value
variable.cpp:  // data = 1 value, string to eval
variable.cpp:  // ATOMFILE for numbers
variable.cpp:  // which = 1st value
variable.cpp:  // data = NULL
variable.cpp:  // FORMAT
variable.cpp:  // num = 3, which = 1st value
variable.cpp:  // data = 3 values
variable.cpp:  //   1st is name of variable to eval, 2nd is format string,
variable.cpp:  //   3rd is filled on retrieval
variable.cpp:  // EQUAL
variable.cpp:  // replace pre-existing var if also style EQUAL (allows it to be reset)
variable.cpp:  // num = 2, which = 1st value
variable.cpp:  // data = 2 values, 1st is string to eval, 2nd is filled on retrieval
variable.cpp:  // ATOM
variable.cpp:  // replace pre-existing var if also style ATOM (allows it to be reset)
variable.cpp:  // num = 1, which = 1st value
variable.cpp:  // data = 1 value, string to eval
variable.cpp:  // VECTOR
variable.cpp:  // replace pre-existing var if also style VECTOR (allows it to be reset)
variable.cpp:  // num = 1, which = 1st value
variable.cpp:  // data = 1 value, string to eval
variable.cpp:  // PYTHON
variable.cpp:  // replace pre-existing var if also style PYTHON (allows it to be reset)
variable.cpp:  // num = 2, which = 1st value
variable.cpp:  // data = 2 values, 1st is Python func to invoke, 2nd is filled by invoke
variable.cpp:  // INTERNAL
variable.cpp:  // replace pre-existing var if also style INTERNAL (allows it to be reset)
variable.cpp:  // num = 1, for string representation of dvalue, set by retrieve()
variable.cpp:  // dvalue = numeric initialization from 2nd arg, reset by internal_set()
variable.cpp:  // set name of variable, if not replacing one flagged with replaceflag
variable.cpp:  // name must be all alphanumeric chars or underscores
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // check that variables exist and are all the same style
variable.cpp:  // exception: UNIVERSE and ULOOP variables can be mixed in same next command
variable.cpp:  // invalid styles: STRING, EQUAL, WORLD, ATOM, VECTOR, GETENV,
variable.cpp:  //                 FORMAT, PYTHON, INTERNAL
variable.cpp:  // if istyle = UNIVERSE or ULOOP, insure all such variables are incremented
variable.cpp:  // increment all variables in list
variable.cpp:  // if any variable is exhausted, set flag = 1 and remove var to allow re-use
variable.cpp:    // wait until lock file can be created and owned by proc 0 of this world
variable.cpp:    // rename() is not atomic in practice, but no known simple fix
variable.cpp:    //   means multiple procs can read/write file at the same time (bad!)
variable.cpp:    // random delays help
variable.cpp:    // delay for random fraction of 1 second before first rename() call
variable.cpp:    // delay for random fraction of 1 second before subsequent tries
variable.cpp:    // when successful, read next available index and Bcast it within my world
variable.cpp:      //printf("READ %d %d\n",universe->me,nextindex);
variable.cpp:      //printf("WRITE %d %d\n",universe->me,nextindex+1);
variable.cpp:    // set all variables in list to nextindex
variable.cpp:    // must increment all UNIVERSE and ULOOP variables here
variable.cpp:    // error check above tested for this
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:    // if Python func returns a string longer than VALUELENGTH
variable.cpp:    // then the Python class stores the result, query it via long_string()
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // (re)allocate space for results if necessary
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:     math operation = (),-x,x+y,x-y,x*y,x/y,x^y,
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:    // whitespace: just skip
variable.cpp:    // ----------------
variable.cpp:    // parentheses: recursively evaluate contents of parens
variable.cpp:    // ----------------
variable.cpp:      // evaluate contents and push on stack
variable.cpp:    // ----------------
variable.cpp:    // number: push value onto stack
variable.cpp:    // ----------------
variable.cpp:      // istop = end of number, including scientific notation
variable.cpp:    // ----------------
variable.cpp:    // letter: c_ID, c_ID[], c_ID[][], f_ID, f_ID[], f_ID[][],
variable.cpp:    //         v_name, v_name[], exp(), xcm(,), x, x[], PI, vol
variable.cpp:    // ----------------
variable.cpp:      // istop = end of word
variable.cpp:      // word = all alphanumeric or underscore
variable.cpp:      // ----------------
variable.cpp:      // compute
variable.cpp:      // ----------------
variable.cpp:	// uppercase used to force access of 
variable.cpp:	// global vector vs global scalar, and global array vs global vector
variable.cpp:        // parse zero or one or two trailing brackets
variable.cpp:        // point i beyond last bracket
variable.cpp:        // nbracket = # of bracket pairs
variable.cpp:        // index1,index2 = int inside each bracket pair, possibly an atom ID
variable.cpp:        // c_ID = scalar from global scalar, must be lowercase
variable.cpp:        // c_ID[i] = scalar from global vector, must be lowercase
variable.cpp:        // c_ID[i][j] = scalar from global array, must be lowercase
variable.cpp:        // c_ID = vector from global vector, lowercase or uppercase
variable.cpp:        // c_ID[i] = vector from global array, lowercase or uppercase
variable.cpp:        // c_ID[i] = scalar from per-atom vector
variable.cpp:        // c_ID[i][j] = scalar from per-atom array
variable.cpp:        // c_ID = vector from per-atom vector
variable.cpp:        // c_ID[i] = vector from per-atom array
variable.cpp:      // ----------------
variable.cpp:      // fix
variable.cpp:      // ----------------
variable.cpp:	// uppercase used to force access of 
variable.cpp:	// global vector vs global scalar, and global array vs global vector
variable.cpp:        // parse zero or one or two trailing brackets
variable.cpp:        // point i beyond last bracket
variable.cpp:        // nbracket = # of bracket pairs
variable.cpp:        // index1,index2 = int inside each bracket pair, possibly an atom ID
variable.cpp:        // f_ID = scalar from global scalar, must be lowercase
variable.cpp:        // f_ID[i] = scalar from global vector, must be lowercase
variable.cpp:        // f_ID[i][j] = scalar from global array, must be lowercase
variable.cpp:        // f_ID = vector from global vector, lowercase or uppercase
variable.cpp:        // f_ID[i] = vector from global array, lowercase or uppercase
variable.cpp:        // f_ID[i] = scalar from per-atom vector
variable.cpp:        // f_ID[i][j] = scalar from per-atom array
variable.cpp:        // f_ID = vector from per-atom vector
variable.cpp:        // f_ID[i] = vector from per-atom array
variable.cpp:      // ----------------
variable.cpp:      // variable
variable.cpp:      // ----------------
variable.cpp:        // parse zero or one trailing brackets
variable.cpp:        // point i beyond last bracket
variable.cpp:        // nbracket = # of bracket pairs
variable.cpp:        // index = int inside bracket, possibly an atom ID
variable.cpp:        // v_name = scalar from internal-style variable
variable.cpp:        // access value directly
variable.cpp:        // v_name = scalar from non atom/atomfile & non vector-style variable
variable.cpp:        // access value via retrieve()
variable.cpp:        // v_name = per-atom vector from atom-style variable
variable.cpp:        // evaluate the atom-style variable as newtree
variable.cpp:        // v_name = per-atom vector from atomfile-style variable
variable.cpp:        // v_name = vector from vector-style variable
variable.cpp:        // evaluate the vector-style variable, put result in newtree
variable.cpp:        // v_name[N] = scalar from atom-style variable
variable.cpp:        // compute the per-atom variable in result
variable.cpp:        // use peratom2global to extract single value from result
variable.cpp:        // v_name[N] = scalar from atomfile-style variable
variable.cpp:        // v_name[N] = scalar from vector-style variable
variable.cpp:        // compute the vector-style variable, extract single value
variable.cpp:	  int m = index;   // convert from tagint to int
variable.cpp:      // ----------------
variable.cpp:      // math/group/special function or atom value/vector or
variable.cpp:      // constant or thermo keyword
variable.cpp:      // ----------------
variable.cpp:        // ----------------
variable.cpp:        // math or group or special function
variable.cpp:        // ----------------
variable.cpp:          else error->all(FLERR,"Invalid math/group/special function "
variable.cpp:        // ----------------
variable.cpp:        // atom value
variable.cpp:        // ----------------
variable.cpp:        // ----------------
variable.cpp:        // atom vector
variable.cpp:        // ----------------
variable.cpp:        // ----------------
variable.cpp:        // constant
variable.cpp:        // ----------------
variable.cpp:        // ----------------
variable.cpp:        // thermo keyword
variable.cpp:        // ----------------
variable.cpp:    // ----------------
variable.cpp:    // math operator, including end-of-string
variable.cpp:    // ----------------
variable.cpp:    } else if (strchr("+-*/^<>=!&|%\0",onechar)) {
variable.cpp:      else if (onechar == '/') op = DIVIDE;
variable.cpp:      // evaluate stack as deep as possible while respecting precedence
variable.cpp:      // before pushing current op onto stack
variable.cpp:            argstack[nargstack++] = value1 / value2;
variable.cpp:      // if end-of-string, break out of entire formula evaluation loop
variable.cpp:      // push current operation onto stack
variable.cpp:  // for atom-style variable, return remaining tree
variable.cpp:  // for equal-style variable, return remaining arg
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:---------------------------------------------------------------------- */
variable.cpp:    tree->value = arg1 / arg2;
variable.cpp:      error->one(FLERR,"Log of zero/negative value in variable formula");
variable.cpp:      error->one(FLERR,"Log of zero/negative value in variable formula");
variable.cpp:  // random() or normal() do not become a single collapsed value
variable.cpp:    if (delta != 0.0) delta /= update->endstep - update->beginstep;
variable.cpp:    int lower = update->ntimestep/ivalue1 * ivalue1;
variable.cpp:      int multiple = update->ntimestep/lower;
variable.cpp:      double delta = ivalue1*(ivalue3-1.0)/ivalue2;
variable.cpp:      tree->value = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:        istep = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:        istep = ivalue4 + (offset/ivalue6)*ivalue6 + ivalue6;
variable.cpp:          istep = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:    double omega = 2.0*MY_PI/arg3;
variable.cpp:    double omega = 2.0*MY_PI/arg3;
variable.cpp:  // mask functions do not become a single collapsed value
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:---------------------------------------------------------------------- */
variable.cpp:    return eval_tree(tree->first,i) / denom;
variable.cpp:      error->one(FLERR,"Log of zero/negative value in variable formula");
variable.cpp:      error->one(FLERR,"Log of zero/negative value in variable formula");
variable.cpp:    if (delta != 0.0) delta /= update->endstep - update->beginstep;
variable.cpp:    int lower = update->ntimestep/ivalue1 * ivalue1;
variable.cpp:      int multiple = update->ntimestep/lower;
variable.cpp:      double delta = ivalue1*(ivalue3-1.0)/ivalue2;
variable.cpp:      arg = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:        istep = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:        istep = ivalue4 + (offset/ivalue6)*ivalue6 + ivalue6;
variable.cpp:          istep = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:    double omega = 2.0*MY_PI/arg3;
variable.cpp:    double omega = 2.0*MY_PI/arg3;
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ---------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // istop = matching ')' at same level, allowing for nested parens
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // evaluate index as floating point variable or as tagint via ATOTAGINT()
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // word not a match to any math function
variable.cpp:  // parse contents for comma-separated args
variable.cpp:  // narg = number of args, args = strings between commas
variable.cpp:  // individual math functions
variable.cpp:  // customize by adding a function
variable.cpp:        error->all(FLERR,"Log of zero/negative value in variable formula");
variable.cpp:        error->all(FLERR,"Log of zero/negative value in variable formula");
variable.cpp:      if (delta != 0.0) delta /= update->endstep - update->beginstep;
variable.cpp:      int lower = update->ntimestep/ivalue1 * ivalue1;
variable.cpp:        int multiple = update->ntimestep/lower;
variable.cpp:	double delta = ivalue1*(ivalue3-1.0)/ivalue2;
variable.cpp:        value = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:          istep = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:          istep = ivalue4 + (offset/ivalue6)*ivalue6 + ivalue6;
variable.cpp:            istep = ivalue1 + (offset/ivalue3)*ivalue3 + ivalue3;
variable.cpp:      double omega = 2.0*MY_PI/values[0];
variable.cpp:      double omega = 2.0*MY_PI/values[0];
variable.cpp:  // delete stored args
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // word not a match to any group function
variable.cpp:  // parse contents for comma-separated args
variable.cpp:  // narg = number of args, args = strings between commas
variable.cpp:  // group to operate on
variable.cpp:  // match word to group function
variable.cpp:  // delete stored args
variable.cpp:  // save value in tree or on argstack
variable.cpp:/* ---------------------------------------------------------------------- */
variable.cpp:  // init region in case sub-regions have been deleted
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // word not a match to any special function
variable.cpp:  // parse contents for comma-separated args
variable.cpp:  // narg = number of args, args = strings between commas
variable.cpp:  // special functions that operate on global vectors
variable.cpp:    // argument is compute
variable.cpp:    // argument is fix
variable.cpp:    // argument is vector-style variable
variable.cpp:          if (nvec > 1) xvalue = (double) i / (nvec-1);
variable.cpp:          if (nvec > 1) xvalue = (double) i / (nvec-1);
variable.cpp:          if (nvec > 1) xvalue = (double) i / (nvec-1);
variable.cpp:    if (method == AVE) value /= nvec;
variable.cpp:      if (denominator != 0.0) value = numerator/denominator / nvec;
variable.cpp:    // save value in tree or on argstack
variable.cpp:  // mask special functions
variable.cpp:  // special function for file-style or atomfile-style variables
variable.cpp:    // SCALARFILE has single current value, read next one
variable.cpp:    // save value in tree or on argstack
variable.cpp:    // ATOMFILE has per-atom values, save values in tree
variable.cpp:    // copy current per-atom values into result so can read next ones
variable.cpp:    // set selfalloc = 1 so result will be deleted by free_tree() after eval
variable.cpp:    // save value in tree or on argstack
variable.cpp:    // save value in tree or on argstack
variable.cpp:    // save value in tree or on argstack
variable.cpp:  // delete stored args
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // error check for ID larger than any atom
variable.cpp:  // int_between_brackets() already checked for ID <= 0
variable.cpp:  // if ID does not exist, index will be -1 for all procs,
variable.cpp:  // and mine will be set to 0.0
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:    int flag;          // 0 for numeric value, 1 for string
variable.cpp:    double value;      // stored numeric value
variable.cpp:    char *str;         // stored string
variable.cpp:    // whitespace: just skip
variable.cpp:    // ----------------
variable.cpp:    // parentheses: recursively evaluate contents of parens
variable.cpp:    // ----------------
variable.cpp:      // evaluate contents and push on stack
variable.cpp:    // ----------------
variable.cpp:    // number: push value onto stack
variable.cpp:    // ----------------
variable.cpp:      // set I to end of number, including scientific notation
variable.cpp:    // ----------------
variable.cpp:    // string: push string onto stack
variable.cpp:    // ----------------
variable.cpp:      // set I to end of string
variable.cpp:    // ----------------
variable.cpp:    // Boolean operator, including end-of-string
variable.cpp:    // ----------------
variable.cpp:      // evaluate stack as deep as possible while respecting precedence
variable.cpp:      // before pushing current op onto stack
variable.cpp:      // if end-of-string, break out of entire formula evaluation loop
variable.cpp:      // push current operation onto stack
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // if atomfile-style variable, must store per-atom values read from file
variable.cpp:  // allocate a new fix STORE, so they persist
variable.cpp:  // id = variable-ID + VARIABLE_STORE, fix group = all
variable.cpp:/* ---------------------------------------------------------------------- */
variable.cpp:  // check modify in case all fixes have already been deleted
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // read one string from file
variable.cpp:      if (n == 0) break;                                 // end of file
variable.cpp:      str[n-1] = '\0';                                   // strip newline
variable.cpp:      if ((ptr = strchr(str,'#'))) *ptr = '\0';          // strip comment
variable.cpp:      if (strtok(str," \t\n\r\f") == NULL) continue;     // skip if blank
variable.cpp:/* ----------------------------------------------------------------------
variable.cpp:------------------------------------------------------------------------- */
variable.cpp:  // set all per-atom values to 0.0
variable.cpp:  // values that appear in file will overwrite this
variable.cpp:  // read one string from file, convert to Nlines
variable.cpp:      if (n == 0) break;                                 // end of file
variable.cpp:      str[n-1] = '\0';                                   // strip newline
variable.cpp:      if ((ptr = strchr(str,'#'))) *ptr = '\0';          // strip comment
variable.cpp:      if (strtok(str," \t\n\r\f") == NULL) continue;     // skip if blank
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
velocity.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:/* ---------------------------------------------------------------------- */
velocity.cpp:/* ---------------------------------------------------------------------- */
velocity.cpp:  // atom masses must all be set
velocity.cpp:  // identify group
velocity.cpp:  // identify style
velocity.cpp:  // set defaults
velocity.cpp:  // read options from end of input line
velocity.cpp:  // change defaults as options specify
velocity.cpp:  // special cases where full init and border communication must be done first
velocity.cpp:  // for ZERO if fix rigid/small is used
velocity.cpp:  // for CREATE/SET if compute temp/cs is used
velocity.cpp:  // b/c methods invoked in the compute/fix perform forward/reverse comm
velocity.cpp:      strcmp(modify->fix[rfix]->style,"rigid/small") == 0) initcomm = 1;
velocity.cpp:      strcmp(temperature->style,"temp/cs") == 0) initcomm = 1;
velocity.cpp:  // initialize velocities based on style
velocity.cpp:  // create() invoked differently, so can be called externally
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:/* ---------------------------------------------------------------------- */
velocity.cpp:  // if sum_flag set, store a copy of current velocities
velocity.cpp:  // if temperature = NULL or bias_flag set,
velocity.cpp:  // create a new ComputeTemp with the velocity group
velocity.cpp:  // initialize temperature computation(s)
velocity.cpp:  // warn if groups don't match
velocity.cpp:  // if bias_flag set, remove bias velocity from all atoms
velocity.cpp:  // for some temperature computes, must first calculate temp to do that
velocity.cpp:  // create new velocities, in uniform or gaussian distribution
velocity.cpp:  // loop option determines looping style, ALL is default
velocity.cpp:  //   ALL = loop over all natoms, only set those I own via atom->map
velocity.cpp:  //    cannot do this if atom IDs do not span 1-Natoms (some were deleted)
velocity.cpp:  //    will produce same V, independent of P, if atoms were read-in
velocity.cpp:  //    will NOT produce same V, independent of P, if used create_atoms
velocity.cpp:  //   LOCAL = only loop over my atoms, adjust RNG to be proc-specific
velocity.cpp:  //    will never produce same V, independent of P
velocity.cpp:  //   GEOM = only loop over my atoms
velocity.cpp:  //    choose RNG for each atom based on its xyz coord (geometry)
velocity.cpp:  //      via random->reset()
velocity.cpp:  //    will always produce same V, independent of P
velocity.cpp:  // adjust by factor for atom mass
velocity.cpp:  // set xdim,ydim,zdim = 1/0 for whether to create velocity in those dims
velocity.cpp:  //   zdim = 0 for 2d
velocity.cpp:  //   any dims can be 0 if bias temperature compute turns them off
velocity.cpp:  //     currently only temp/partial does
velocity.cpp:    // create an atom map if one doesn't exist already
velocity.cpp:    // error check
velocity.cpp:    // loop over all atoms in system
velocity.cpp:    // generate RNGs for all atoms, only assign to ones I own
velocity.cpp:    // use either per-type mass or per-atom rmass
velocity.cpp:          if (rmass) factor = 1.0/sqrt(rmass[m]);
velocity.cpp:          else factor = 1.0/sqrt(mass[type[m]]);
velocity.cpp:    // delete temporary atom map
velocity.cpp:        if (rmass) factor = 1.0/sqrt(rmass[i]);
velocity.cpp:        else factor = 1.0/sqrt(mass[type[i]]);
velocity.cpp:        if (rmass) factor = 1.0/sqrt(rmass[i]);
velocity.cpp:        else factor = 1.0/sqrt(mass[type[i]]);
velocity.cpp:  // apply momentum and rotation zeroing
velocity.cpp:  // scale temp to desired value
velocity.cpp:  // if bias flag is set, bias velocities have already been removed:
velocity.cpp:  //   no-bias compute calculates temp only for new thermal velocities
velocity.cpp:  // if bias_flag set, restore bias velocity to all atoms
velocity.cpp:  // reapply needed for temperature computes where velocity
velocity.cpp:  //   creation has messed up the bias that was already removed:
velocity.cpp:  //   compute temp/partial needs to reset v dims to 0.0
velocity.cpp:  //   compute temp/cs needs to reset v to COM velocity of each C/S pair
velocity.cpp:  // if sum_flag set, add back in previous velocities
velocity.cpp:  // free local memory
velocity.cpp:  // if temperature compute was created, delete it
velocity.cpp:/* ---------------------------------------------------------------------- */
velocity.cpp:  // parse 3 args
velocity.cpp:  // set and apply scale factors
velocity.cpp:  // check variables
velocity.cpp:  // error check for 2d models
velocity.cpp:  // allocate vfield array if necessary
velocity.cpp:  // set velocities via constants
velocity.cpp:  // set velocities via variables
velocity.cpp:  // clean up
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:  // if temperature = NULL, create a new ComputeTemp with the velocity group
velocity.cpp:  // initialize temperature computation
velocity.cpp:  // warn if groups don't match
velocity.cpp:  // scale temp to desired value
velocity.cpp:  // if bias flag is set:
velocity.cpp:  //   temperature calculation will be done accounting for bias
velocity.cpp:  //   remove/restore bias velocities before/after rescale
velocity.cpp:  // if temperature was created, delete it
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:  // set scale factors
velocity.cpp:  // parse args
velocity.cpp:  // vramp = ramped velocity component for v_dim
velocity.cpp:  // add or set based on sum_flag
velocity.cpp:      fraction = (x[i][coord_dim] - coord_lo) / (coord_hi - coord_lo);
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:    else if (strcmp(modify->fix[rfix]->style,"rigid/small") == 0) {
velocity.cpp:    else if (strcmp(modify->fix[rfix]->style,"rigid/small") == 0) {
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:  double factor = sqrt(t_new/t_old);
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:  // cannot have no atoms in group
velocity.cpp:  // compute velocity of center-of-mass of group
velocity.cpp:  // adjust velocities by vcm to zero linear momentum
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:  // cannot have no atoms in group
velocity.cpp:  // compute omega (angular velocity) of group around center-of-mass
velocity.cpp:  // adjust velocities to zero omega
velocity.cpp:  // vnew_i = v_i - w x r_i
velocity.cpp:  // must use unwrapped coords to compute r_i correctly
velocity.cpp:/* ----------------------------------------------------------------------
velocity.cpp:------------------------------------------------------------------------- */
velocity.cpp:  // error check
verlet.cpp:/* ----------------------------------------------------------------------
verlet.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
verlet.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
verlet.cpp:------------------------------------------------------------------------- */
verlet.cpp:/* ---------------------------------------------------------------------- */
verlet.cpp:/* ----------------------------------------------------------------------
verlet.cpp:------------------------------------------------------------------------- */
verlet.cpp:  // warn if no fixes
verlet.cpp:  // virial_style:
verlet.cpp:  // 1 if computed explicitly by pair->compute via sum over pair interactions
verlet.cpp:  // 2 if computed implicitly by pair->virial_fdotr_compute via sum over ghosts
verlet.cpp:  // setup lists of computes for global and per-atom PE and pressure
verlet.cpp:  // detect if fix omp is present for clearing force arrays
verlet.cpp:  // set flags for arrays to clear in force_clear()
verlet.cpp:  // orthogonal vs triclinic simulation box
verlet.cpp:/* ----------------------------------------------------------------------
verlet.cpp:------------------------------------------------------------------------- */
verlet.cpp:    error->all(FLERR,"KOKKOS package requires run_style verlet/kk");
verlet.cpp:  // setup domain, communication and neighboring
verlet.cpp:  // acquire ghosts
verlet.cpp:  // build neighbor lists
verlet.cpp:  // compute all forces
verlet.cpp:/* ----------------------------------------------------------------------
verlet.cpp:------------------------------------------------------------------------- */
verlet.cpp:  // setup domain, communication and neighboring
verlet.cpp:  // acquire ghosts
verlet.cpp:  // build neighbor lists
verlet.cpp:  // compute all forces
verlet.cpp:/* ----------------------------------------------------------------------
verlet.cpp:------------------------------------------------------------------------- */
verlet.cpp:    // initial time integration
verlet.cpp:    // regular communication vs neighbor list rebuild
verlet.cpp:    // force computations
verlet.cpp:    // important for pair to come before bonded contributions
verlet.cpp:    // since some bonded potentials tally pairwise energy/virial
verlet.cpp:    // and Pair:ev_tally() needs to be called before any tallying
verlet.cpp:    // reverse communication of forces
verlet.cpp:    // force modifications, final time integration, diagnostics
verlet.cpp:    // all output
verlet.cpp:/* ---------------------------------------------------------------------- */
verlet.cpp:/* ----------------------------------------------------------------------
verlet.cpp:------------------------------------------------------------------------- */
verlet.cpp:  // clear force on all particles
verlet.cpp:  // if either newton flag is set, also include ghosts
verlet.cpp:  // when using threads always clear all forces.
verlet.cpp:      //test memset for fm
verlet.cpp:      //memset(&atom->fm[0][0],0,3*nbytes);
verlet.cpp:  // neighbor includegroup flag is set
verlet.cpp:  // clear force only on initial nfirst particles
verlet.cpp:  // if either newton flag is set, also include ghosts
write_coeff.cpp:/* ----------------------------------------------------------------------
write_coeff.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
write_coeff.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
write_coeff.cpp:------------------------------------------------------------------------- */
write_coeff.cpp:/* ----------------------------------------------------------------------
write_coeff.cpp:------------------------------------------------------------------------- */
write_coeff.cpp:  // initialize relevant styles
write_coeff.cpp:      fputs(str,two);      // style
write_coeff.cpp:      fgets(str,256,one);  // coeff
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
write_data.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:enum{IGNORE,WARN,ERROR};                    // same as thermo.cpp
write_data.cpp:/* ---------------------------------------------------------------------- */
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // if filename contains a "*", replace with current timestep
write_data.cpp:  // read optional args
write_data.cpp:  // noinit is a hidden arg, only used by -r command-line switch
write_data.cpp:  // init entire system since comm->exchange is done
write_data.cpp:  // comm::init needs neighbor::init needs pair::init needs kspace::init, etc
write_data.cpp:  // exception is when called by -r command-line switch
write_data.cpp:  //   then write_data immediately follows reading of restart file
write_data.cpp:  //   assume that read_restart initialized necessary values
write_data.cpp:  //   if don't make exception:
write_data.cpp:  //     pair->init() can fail due to various unset values:
write_data.cpp:  //     e.g. pair hybrid coeffs, dpd ghost-atom velocity setting
write_data.cpp:    // move atoms to new processors before writing file
write_data.cpp:    // do setup_pre_exchange to force update of per-atom info if needed
write_data.cpp:    // enforce PBC in case atoms are outside box
write_data.cpp:    // call borders() to rebuild atom map since exchange() destroys map
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:   might later let it be directly called within run/minimize loop
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // special case where reneighboring is not done in integrator
write_data.cpp:  //   on timestep data file is written (due to build_once being set)
write_data.cpp:  // if box is changing, must be reset, else data file will have
write_data.cpp:  //   wrong box size and atoms will be lost when data file is read
write_data.cpp:  // other calls to pbc and domain and comm are not made,
write_data.cpp:  //   b/c they only make sense if reneighboring is actually performed
write_data.cpp:  //if (neighbor->build_once) domain->reset_box();
write_data.cpp:  // natoms = sum of nlocal = value to write into data file
write_data.cpp:  // if unequal and thermo lostflag is "error", don't write data file
write_data.cpp:  // sum up bond,angle counts
write_data.cpp:  // may be different than atom->nbonds,nangles if broken/turned-off
write_data.cpp:  // open data file
write_data.cpp:  // proc 0 writes header, ntype-length arrays, force fields
write_data.cpp:  // per atom info
write_data.cpp:  // do not write molecular topology for atom_style template
write_data.cpp:  // extra sections managed by fixes
write_data.cpp:  // close data file
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // do not write molecular topology info for atom_style template
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // communication buffer for all my Atom info
write_data.cpp:  // max_size = largest buffer needed by any proc
write_data.cpp:  // pack my atom data into buf
write_data.cpp:  // write one chunk of atoms per proc to file
write_data.cpp:  // proc 0 pings each proc, receives its chunk, writes to file
write_data.cpp:  // all other procs wait for ping, send their chunk to proc 0
write_data.cpp:        recvrow /= ncol;
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // communication buffer for all my Atom info
write_data.cpp:  // max_size = largest buffer needed by any proc
write_data.cpp:  // pack my velocity data into buf
write_data.cpp:  // write one chunk of velocities per proc to file
write_data.cpp:  // proc 0 pings each proc, receives its chunk, writes to file
write_data.cpp:  // all other procs wait for ping, send their chunk to proc 0
write_data.cpp:        recvrow /= ncol;
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // communication buffer for all my Bond info
write_data.cpp:  // pack my bond data into buf
write_data.cpp:  // write one chunk of info per proc to file
write_data.cpp:  // proc 0 pings each proc, receives its chunk, writes to file
write_data.cpp:  // all other procs wait for ping, send their chunk to proc 0
write_data.cpp:        recvrow /= ncol;
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // communication buffer for all my Angle info
write_data.cpp:  // pack my angle data into buf
write_data.cpp:  // write one chunk of info per proc to file
write_data.cpp:  // proc 0 pings each proc, receives its chunk, writes to file
write_data.cpp:  // all other procs wait for ping, send their chunk to proc 0
write_data.cpp:        recvrow /= ncol;
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // communication buffer for all my Dihedral info
write_data.cpp:  // max_size = largest buffer needed by any proc
write_data.cpp:  // pack my dihedral data into buf
write_data.cpp:  // write one chunk of info per proc to file
write_data.cpp:  // proc 0 pings each proc, receives its chunk, writes to file
write_data.cpp:  // all other procs wait for ping, send their chunk to proc 0
write_data.cpp:        recvrow /= ncol;
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // communication buffer for all my Improper info
write_data.cpp:  // max_size = largest buffer needed by any proc
write_data.cpp:  // pack my improper data into buf
write_data.cpp:  // write one chunk of info per proc to file
write_data.cpp:  // proc 0 pings each proc, receives its chunk, writes to file
write_data.cpp:  // all other procs wait for ping, send their chunk to proc 0
write_data.cpp:        recvrow /= ncol;
write_data.cpp:/* ----------------------------------------------------------------------
write_data.cpp:------------------------------------------------------------------------- */
write_data.cpp:  // communication buffer for Fix info
write_data.cpp:  // pack my fix data into buf
write_data.cpp:  // write one chunk of info per proc to file
write_data.cpp:  // proc 0 pings each proc, receives its chunk, writes to file
write_data.cpp:  // all other procs wait for ping, send their chunk to proc 0
write_data.cpp:        recvrow /= ncol;
write_dump.cpp:/* ----------------------------------------------------------------------
write_dump.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
write_dump.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
write_dump.cpp:------------------------------------------------------------------------- */
write_dump.cpp:/* ----------------------------------------------------------------------
write_dump.cpp:------------------------------------------------------------------------- */
write_dump.cpp:/* ---------------------------------------------------------------------- */
write_dump.cpp:  // modindex = index in args of "modify" keyword
write_dump.cpp:  // will be narg if "modify" is not present
write_dump.cpp:  // create the Dump instance
write_dump.cpp:  // create dump command line with extra required args
write_dump.cpp:  dumpargs[0] = (char *) "WRITE_DUMP"; // dump id
write_dump.cpp:  dumpargs[1] = arg[0];                // group
write_dump.cpp:  dumpargs[2] = arg[1];                // dump style
write_dump.cpp:  dumpargs[3] = (char *) "1";          // dump frequency
write_dump.cpp:  if (0) return;         // dummy line to enable else-if macro expansion
write_dump.cpp:  // write out one frame and then delete the dump again
write_dump.cpp:  // set multifile_override for DumpImage so that filename needs no "*"
write_dump.cpp:  // delete the Dump instance and local storage
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
write_restart.cpp:   http://lammps.sandia.gov, Sandia National Laboratories
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:// same as read_restart.cpp
write_restart.cpp:enum{IGNORE,WARN,ERROR};                    // same as thermo.cpp
write_restart.cpp:/* ---------------------------------------------------------------------- */
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:  // if filename contains a "*", replace with current timestep
write_restart.cpp:  // check for multiproc output and an MPI-IO filename
write_restart.cpp:  // setup output style and process optional args
write_restart.cpp:  // also called by Output class for periodic restart files
write_restart.cpp:  // init entire system since comm->exchange is done
write_restart.cpp:  // comm::init needs neighbor::init needs pair::init needs kspace::init, etc
write_restart.cpp:    // move atoms to new processors before writing file
write_restart.cpp:    // enforce PBC in case atoms are outside box
write_restart.cpp:    // call borders() to rebuild atom map since exchange() destroys map
write_restart.cpp:    // NOTE: removed call to setup_pre_exchange
write_restart.cpp:    //   used to be needed by fixShearHistory for granular
write_restart.cpp:    //   to move history info from neigh list to atoms between runs
write_restart.cpp:    //   but now that is done via FIx::post_run()
write_restart.cpp:    //   don't think any other fix needs this or should do it
write_restart.cpp:    //   e.g. fix evaporate should not delete more atoms
write_restart.cpp:    // modify->setup_pre_exchange();
write_restart.cpp:  // write single restart file
write_restart.cpp:/* ---------------------------------------------------------------------- */
write_restart.cpp:  // error checks
write_restart.cpp:  // defaults for multiproc file writing
write_restart.cpp:  // optional args
write_restart.cpp:      multiproc = nprocs/nper;
write_restart.cpp:      fileproc = me/nper * nper;
write_restart.cpp:      icluster = fileproc/nper;
write_restart.cpp:      icluster = static_cast<int> ((bigint) me * nfile/nprocs);
write_restart.cpp:      fileproc = static_cast<int> ((bigint) icluster * nprocs/nfile);
write_restart.cpp:      int fcluster = static_cast<int> ((bigint) fileproc * nfile/nprocs);
write_restart.cpp:        static_cast<int> ((bigint) (icluster+1) * nprocs/nfile);
write_restart.cpp:      fcluster = static_cast<int> ((bigint) fileprocnext * nfile/nprocs);
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:   called from command() and directly from output within run/minimize loop
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:  // special case where reneighboring is not done in integrator
write_restart.cpp:  //   on timestep restart file is written (due to build_once being set)
write_restart.cpp:  // if box is changing, must be reset, else restart file will have
write_restart.cpp:  //   wrong box size and atoms will be lost when restart file is read
write_restart.cpp:  // other calls to pbc and domain and comm are not made,
write_restart.cpp:  //   b/c they only make sense if reneighboring is actually performed
write_restart.cpp:  // natoms = sum of nlocal = value to write into restart file
write_restart.cpp:  // if unequal and thermo lostflag is "error", don't write restart file
write_restart.cpp:  // open single restart file or base file for multiproc case
write_restart.cpp:  // proc 0 writes magic string, endian flag, numeric version
write_restart.cpp:  // proc 0 writes header, groups, pertype info, force field info
write_restart.cpp:  // all procs write fix info
write_restart.cpp:  // communication buffer for my atom info
write_restart.cpp:  // max_size = largest buffer needed by any proc
write_restart.cpp:  // NOTE: are assuming size_restart() returns 32-bit int
write_restart.cpp:  //   for a huge one-proc problem, nlocal could be 32-bit
write_restart.cpp:  //   but nlocal * doubles-peratom could oveflow
write_restart.cpp:  // all procs write file layout info which may include per-proc sizes
write_restart.cpp:  // header info is complete
write_restart.cpp:  // if multiproc output:
write_restart.cpp:  //   close header file, open multiname file on each writing proc,
write_restart.cpp:  //   write PROCSPERFILE into new file
write_restart.cpp:  // pack my atom data into buf
write_restart.cpp:  // if any fix requires it, remap each atom's coords via PBC
write_restart.cpp:  // is because fix changes atom coords (excepting an integrate fix)
write_restart.cpp:  // just remap in buffer, not actual atoms
write_restart.cpp:  // MPI-IO output to single file
write_restart.cpp:  // output of one or more native files
write_restart.cpp:  // filewriter = 1 = this proc writes to file
write_restart.cpp:  // ping each proc in my cluster, receive its data, write data to file
write_restart.cpp:  // else wait for ping from fileproc, send my data to fileproc
write_restart.cpp:  // clean up
write_restart.cpp:  // invoke any fixes that write their own restart file
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:  // added field for shrink-wrap boundaries with minimum - 2 Jul 2015
write_restart.cpp:  // write atom_style and its args
write_restart.cpp:  // -1 flag signals end of header
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:  // -1 flag signals end of type arrays
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:  // -1 flag signals end of force field info
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:  // -1 flag signals end of file layout info
write_restart.cpp:  // if MPI-IO file, broadcast the end of the header offste
write_restart.cpp:  // this allows all ranks to compute offset to their data
write_restart.cpp:// ----------------------------------------------------------------------
write_restart.cpp:// ----------------------------------------------------------------------
write_restart.cpp:// low-level fwrite methods
write_restart.cpp:// ----------------------------------------------------------------------
write_restart.cpp:// ----------------------------------------------------------------------
write_restart.cpp:/* ---------------------------------------------------------------------- */
write_restart.cpp:/* ---------------------------------------------------------------------- */
write_restart.cpp:/* ---------------------------------------------------------------------- */
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
write_restart.cpp:/* ----------------------------------------------------------------------
write_restart.cpp:------------------------------------------------------------------------- */
