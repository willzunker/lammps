angle_charmm.cpp:  if (comm->me == 0) {
angle_cosine.cpp:  if (comm->me == 0) utils::sfread(FLERR,&k[1],sizeof(double),atom->nangletypes,fp,nullptr,error);
angle_cosine_periodic.cpp:  if (comm->me == 0) {
angle_cosine_squared.cpp:  if (comm->me == 0) {
angle.cpp:      memory->create(eatom,comm->nthreads*maxeatom,"angle:eatom");
angle.cpp:      memory->create(vatom,comm->nthreads*maxvatom,6,"angle:vatom");
angle.cpp:      memory->create(cvatom,comm->nthreads*maxcvatom,9,"angle:cvatom");
angle.cpp:  double bytes = comm->nthreads*maxeatom * sizeof(double);
angle.cpp:  bytes += comm->nthreads*maxvatom*6 * sizeof(double);
angle.cpp:  bytes += comm->nthreads*maxcvatom*9 * sizeof(double);
angle_deprecated.cpp:    if (lmp->comm->me == 0)
angle_harmonic.cpp:  if (comm->me == 0) {
angle_hybrid.cpp:  const int nthreads = comm->nthreads;
angle_hybrid.cpp:  if (comm->nthreads > 1) {
angle_hybrid.cpp:  int me = comm->me;
angle_table.cpp:  if (comm->me == 0) {
angle_zero.cpp:  if (comm->me == 0) {
atom.cpp:  if (comm->layout != Comm::LAYOUT_TILED) {
atom.cpp:      if (comm->myloc[0] == 0) sublo[0] -= epsilon[0];
atom.cpp:      if (comm->myloc[0] == comm->procgrid[0]-1) subhi[0] += epsilon[0];
atom.cpp:      if (comm->myloc[1] == 0) sublo[1] -= epsilon[1];
atom.cpp:      if (comm->myloc[1] == comm->procgrid[1]-1) subhi[1] += epsilon[1];
atom.cpp:      if (comm->myloc[2] == 0) sublo[2] -= epsilon[2];
atom.cpp:      if (comm->myloc[2] == comm->procgrid[2]-1) subhi[2] += epsilon[2];
atom.cpp:      if (comm->mysplit[0][0] == 0.0) sublo[0] -= epsilon[0];
atom.cpp:      if (comm->mysplit[0][1] == 1.0) subhi[0] += epsilon[0];
atom.cpp:      if (comm->mysplit[1][0] == 0.0) sublo[1] -= epsilon[1];
atom.cpp:      if (comm->mysplit[1][1] == 1.0) subhi[1] += epsilon[1];
atom.cpp:      if (comm->mysplit[2][0] == 0.0) sublo[2] -= epsilon[2];
atom.cpp:      if (comm->mysplit[2][1] == 1.0) subhi[2] += epsilon[2];
atom.cpp:  if (comm->me == 0) {
atom.cpp:   called by comm->exchange() if atom_modify first group is set
atom.cpp:   always called between comm->exchange() and comm->borders()
atom.cpp:    if (comm->me == 0)
atom_map.cpp:      int nper = static_cast<int> (natoms/comm->nprocs);
atom_vec_body.cpp:      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
atom_vec_body.cpp:      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
atom_vec_body.cpp:      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
atom_vec_body.cpp:      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
atom_vec_body.cpp:      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
atom_vec_body.cpp:      printf("Proc %d, step %ld, flag %d\n",comm->me,update->ntimestep,flag);
atom_vec.cpp:  f = memory->grow(atom->f,nmax*comm->nthreads,3,"atom:f");
atom_vec.cpp:    const int nthreads = threads[i] ? comm->nthreads : 1;
atom_vec.cpp:  bytes += memory->usage(f,nmax*comm->nthreads,3);
atom_vec.cpp:    const int nthreads = threads[i] ? comm->nthreads : 1;
atom_vec_hybrid.cpp:  if (mass_pertype && mass_peratom && comm->me == 0)
atom_vec_hybrid.cpp:    if ((ptr && strstr(ptr+1,dup)) && (comm->me == 0))
atom_vec_line.cpp:      //if (comm->me == 1 && update->ntimestep == 873)
atom_vec_line.cpp:    printf("BAD vecline ptrs: %s: %d %d: %d\n",str,comm->me,
atom_vec_line.cpp:           str,comm->me,update->ntimestep,count,nlocal_bonus);
balance.cpp:  int *procgrid = comm->procgrid;
balance.cpp:  if (style == BISECTION && comm->style == 0)
balance.cpp:  // init entire system since comm->setup is done
balance.cpp:  comm->setup();
balance.cpp:  comm->exchange();
balance.cpp:  if (comm->layout == Comm::LAYOUT_TILED && style != BISECTION) {
balance.cpp:    if (comm->layout == Comm::LAYOUT_UNIFORM) {
balance.cpp:        comm->layout = Comm::LAYOUT_NONUNIFORM;
balance.cpp:    } else if (comm->layout == Comm::LAYOUT_NONUNIFORM) {
balance.cpp:        comm->layout = Comm::LAYOUT_UNIFORM;
balance.cpp:    } else if (comm->layout == Comm::LAYOUT_TILED) {
balance.cpp:        comm->layout = Comm::LAYOUT_UNIFORM;
balance.cpp:      else comm->layout = Comm::LAYOUT_NONUNIFORM;
balance.cpp:        comm->xsplit[i] = i * 1.0/procgrid[0];
balance.cpp:      comm->xsplit[procgrid[0]] = 1.0;
balance.cpp:      for (int i = 0; i <= procgrid[0]; i++) comm->xsplit[i] = user_xsplit[i];
balance.cpp:        comm->ysplit[i] = i * 1.0/procgrid[1];
balance.cpp:      comm->ysplit[procgrid[1]] = 1.0;
balance.cpp:      for (int i = 0; i <= procgrid[1]; i++) comm->ysplit[i] = user_ysplit[i];
balance.cpp:        comm->zsplit[i] = i * 1.0/procgrid[2];
balance.cpp:      comm->zsplit[procgrid[2]] = 1.0;
balance.cpp:      for (int i = 0; i <= procgrid[2]; i++) comm->zsplit[i] = user_zsplit[i];
balance.cpp:    comm->layout = Comm::LAYOUT_NONUNIFORM;
balance.cpp:    comm->layout = Comm::LAYOUT_TILED;
balance.cpp:      for (int i = 0; i <= comm->procgrid[0]; i++)
balance.cpp:        mesg += fmt::format(" {:.8}",comm->xsplit[i]);
balance.cpp:      for (int i = 0; i <= comm->procgrid[1]; i++)
balance.cpp:        mesg += fmt::format(" {:.8}",comm->ysplit[i]);
balance.cpp:      for (int i = 0; i <= comm->procgrid[2]; i++)
balance.cpp:        mesg += fmt::format(" {:.8}",comm->zsplit[i]);
balance.cpp:  if (outflag && comm->me == 0) {
balance.cpp:  comm->rcbnew = 1;
balance.cpp:  if (idim >= 0) comm->rcbcutfrac = (rcb->cut - boxlo[idim]) / prd[idim];
balance.cpp:  else comm->rcbcutfrac = 0.0;
balance.cpp:  comm->rcbcutdim = idim;
balance.cpp:  double (*mysplit)[2] = comm->mysplit;
balance.cpp:  int max = MAX(comm->procgrid[0],comm->procgrid[1]);
balance.cpp:  max = MAX(max,comm->procgrid[2]);
balance.cpp:  if (comm->layout == Comm::LAYOUT_TILED) {
balance.cpp:    int *procgrid = comm->procgrid;
balance.cpp:    double *xsplit = comm->xsplit;
balance.cpp:    double *ysplit = comm->ysplit;
balance.cpp:    double *zsplit = comm->zsplit;
balance.cpp:  int *procgrid = comm->procgrid;
balance.cpp:      split = comm->xsplit;
balance.cpp:      split = comm->ysplit;
balance.cpp:      split = comm->zsplit;
balance.cpp:  double *xsplit = comm->xsplit;
balance.cpp:  double *ysplit = comm->ysplit;
balance.cpp:  double *zsplit = comm->zsplit;
balance.cpp:  int nx = comm->procgrid[0];
balance.cpp:  int ny = comm->procgrid[1];
balance.cpp:  int nz = comm->procgrid[2];
bond.cpp:      memory->create(eatom,comm->nthreads*maxeatom,"bond:eatom");
bond.cpp:      memory->create(vatom,comm->nthreads*maxvatom,6,"bond:vatom");
bond.cpp:  if (comm->me == 0) {
bond.cpp:  if (comm->me == 0) {
bond.cpp:  double bytes = comm->nthreads*maxeatom * sizeof(double);
bond.cpp:  bytes += comm->nthreads*maxvatom*6 * sizeof(double);
bond_deprecated.cpp:    if (lmp->comm->me == 0)
bond_fene.cpp:    if (comm->me == 0)
bond_fene.cpp:  if (comm->me == 0) {
bond_fene_expand.cpp:    if (comm->me == 0)
bond_fene_expand.cpp:  if (comm->me == 0) {
bond_gromos.cpp:  if (comm->me == 0) {
bond_harmonic.cpp:  if (comm->me == 0) {
bond_hybrid.cpp:  const int nthreads = comm->nthreads;
bond_hybrid.cpp:  int me = comm->me;
bond_morse.cpp:  if (comm->me == 0) {
bond_nonlinear.cpp:  if (comm->me == 0) {
bond_quartic.cpp:  if (comm->me == 0) {
bond_table.cpp:  if (comm->me == 0) {
bond_zero.cpp:  if (comm->me == 0) {
change_box.cpp:  if (comm->me == 0) utils::logmesg(lmp,"Changing box ...\n");
change_box.cpp:  if (natoms != atom->natoms && comm->me == 0)
comm_brick.cpp:  if (oldcomm->layout == Comm::LAYOUT_TILED)
comm_brick.cpp:  layout = oldcomm->layout;
comm.cpp:  if (oldcomm->grid2proc) {
comm.cpp:    memcpy(&grid2proc[0][0][0],&oldcomm->grid2proc[0][0][0],
comm.cpp:    memcpy(xsplit,oldcomm->xsplit,(procgrid[0]+1)*sizeof(double));
comm.cpp:    memcpy(ysplit,oldcomm->ysplit,(procgrid[1]+1)*sizeof(double));
comm.cpp:    memcpy(zsplit,oldcomm->zsplit,(procgrid[2]+1)*sizeof(double));
comm.cpp:  if (oldcomm->cutusermulti) {
comm.cpp:    memcpy(cutusermulti,oldcomm->cutusermulti,ncollections);
comm.cpp:  if (oldcomm->cutusermultiold) {
comm.cpp:    memcpy(cutusermultiold,oldcomm->cutusermultiold,atom->ntypes+1);
comm.cpp:    int n = strlen(oldcomm->customfile) + 1;
comm.cpp:    strcpy(customfile,oldcomm->customfile);
comm.cpp:    int n = strlen(oldcomm->outfile) + 1;
comm.cpp:    strcpy(outfile,oldcomm->outfile);
comm_tiled.cpp:  layout = oldcomm->layout;
compute_adf.cpp:    if (mycutneigh > comm->cutghostuser)
compute_aggregate_atom.cpp:  if (count > 1 && comm->me == 0)
compute_aggregate_atom.cpp:    comm->forward_comm_compute(this);
compute_aggregate_atom.cpp:    comm->forward_comm_compute(this);
compute_aggregate_atom.cpp:      comm->reverse_comm_compute(this);
compute_bond_local.cpp:  if (velflag && !comm->ghost_velocity) ghostvelflag = 1;
compute_bond_local.cpp:  if (ghostvelflag && !initflag) comm->forward_comm_compute(this);
compute_centro_atom.cpp:  if (count > 1 && comm->me == 0)
compute_centroid_stress_atom.cpp:    comm->reverse_comm_compute(this);
compute_chunk_atom.cpp:    int nprocs = comm->nprocs;
compute_chunk_atom.cpp:    comm->ring(n,sizeof(int),list,1,idring,nullptr,(void *)this,0);
compute_chunk_atom.cpp:   callback from comm->ring()
compute_chunk_atom.cpp:  if (flagall && comm->me == 0)
compute_cluster_atom.cpp:  if (count > 1 && comm->me == 0)
compute_cluster_atom.cpp:    comm->forward_comm_compute(this);
compute_cluster_atom.cpp:    comm->forward_comm_compute(this);
compute_cluster_atom.cpp:    comm->forward_comm_compute(this);
compute_cna_atom.cpp:      comm->me == 0)
compute_cna_atom.cpp:  if (count > 1 && comm->me == 0)
compute_cna_atom.cpp:  if (nerrorall && comm->me == 0)
compute_cna_atom.cpp:  if (nerrorall && comm->me == 0)
compute_contact_atom.cpp:  if (count > 1 && comm->me == 0)
compute_contact_atom.cpp:  if (force->newton_pair) comm->reverse_comm_compute(this);
compute_coord_atom.cpp:    comm->forward_comm_compute(this);
compute_deprecated.cpp:    if (lmp->comm->me == 0)
compute_erotate_sphere_atom.cpp:  if (count > 1 && comm->me == 0)
compute_fragment_atom.cpp:  if (count > 1 && comm->me == 0)
compute_fragment_atom.cpp:    comm->forward_comm_compute(this);
compute_fragment_atom.cpp:    comm->forward_comm_compute(this);
compute_group_group.cpp:    if ((fabs(e_correction) > SMALL) && (comm->me == 0))
compute_hexorder_atom.cpp:  if (count > 1 && comm->me == 0)
compute_ke_atom.cpp:  if (count > 1 && comm->me == 0)
compute_orientorder_atom.cpp:  if (count > 1 && comm->me == 0)
compute_pe_atom.cpp:    comm->reverse_comm_compute(this);
compute_property_atom.cpp:  int me = comm->me;
compute_rdf.cpp:      cutghost = MAX(force->pair->cutforce+skin,comm->cutghostuser);
compute_rdf.cpp:      cutghost = comm->cutghostuser;
compute_rdf.cpp:      if (comm->me == 0)
compute_stress_atom.cpp:    comm->reverse_comm_compute(this);
compute_temp_deform.cpp:          comm->me == 0)
compute_temp_deform.cpp:  if (i == modify->nfix && comm->me == 0)
create_atoms.cpp:    if (comm->layout != Comm::LAYOUT_TILED) {
create_atoms.cpp:        if (comm->myloc[0] == 0) sublo[0] -= epsilon[0];
create_atoms.cpp:        if (comm->myloc[0] == comm->procgrid[0]-1) subhi[0] -= 2.0*epsilon[0];
create_atoms.cpp:        if (comm->myloc[1] == 0) sublo[1] -= epsilon[1];
create_atoms.cpp:        if (comm->myloc[1] == comm->procgrid[1]-1) subhi[1] -= 2.0*epsilon[1];
create_atoms.cpp:        if (comm->myloc[2] == 0) sublo[2] -= epsilon[2];
create_atoms.cpp:        if (comm->myloc[2] == comm->procgrid[2]-1) subhi[2] -= 2.0*epsilon[2];
create_atoms.cpp:        if (comm->mysplit[0][0] == 0.0) sublo[0] -= epsilon[0];
create_atoms.cpp:        if (comm->mysplit[0][1] == 1.0) subhi[0] -= 2.0*epsilon[0];
create_atoms.cpp:        if (comm->mysplit[1][0] == 0.0) sublo[1] -= epsilon[1];
create_atoms.cpp:        if (comm->mysplit[1][1] == 1.0) subhi[1] -= 2.0*epsilon[1];
create_atoms.cpp:        if (comm->mysplit[2][0] == 0.0) sublo[2] -= epsilon[2];
create_atoms.cpp:        if (comm->mysplit[2][1] == 1.0) subhi[2] -= 2.0*epsilon[2];
create_bonds.cpp:  // init entire system since comm->borders and neighbor->build is done
create_bonds.cpp:  if (rmax > neighbor->cutneighmin && comm->me == 0)
create_bonds.cpp:  comm->setup();
create_bonds.cpp:  comm->exchange();
create_bonds.cpp:  comm->borders();
create_bonds.cpp:  if (comm->me == 0)
create_box.cpp:  comm->set_proc_grid();
delete_atoms.cpp:    } else if (comm->me == 0)
delete_atoms.cpp:  if (comm->me == 0) {
delete_atoms.cpp:  if (comm->me == 0) utils::logmesg(lmp,"System init for delete_atoms ...\n");
delete_atoms.cpp:  // init entire system since comm->borders and neighbor->build is done
delete_atoms.cpp:  if (cut > neighbor->cutneighmin && comm->me == 0)
delete_atoms.cpp:  comm->setup();
delete_atoms.cpp:  comm->exchange();
delete_atoms.cpp:  comm->borders();
delete_atoms.cpp:  RanMars *random = new RanMars(lmp,seed + comm->me);
delete_atoms.cpp:  // pass list to all other procs via comm->ring()
delete_atoms.cpp:  comm->ring(n,sizeof(tagint),list,1,bondring,nullptr,(void *)this);
delete_atoms.cpp:  // pass list to all other procs via comm->ring()
delete_atoms.cpp:  comm->ring(n,sizeof(tagint),list,1,molring,nullptr,(void *)this);
delete_atoms.cpp:   callback from comm->ring() in delete_bond()
delete_atoms.cpp:   callback from comm->ring() in delete_molecule()
delete_bonds.cpp:  // init entire system since comm->borders is done
delete_bonds.cpp:  if (comm->me == 0) utils::logmesg(lmp,"System init for delete_bonds ...\n");
delete_bonds.cpp:  if (comm->me == 0) utils::logmesg(lmp,"Deleting bonds ...\n");
delete_bonds.cpp:  comm->setup();
delete_bonds.cpp:  comm->exchange();
delete_bonds.cpp:  comm->borders();
delete_bonds.cpp:  if (comm->me == 0) {
deprecated.cpp:    if (lmp->comm->me == 0)
deprecated.cpp:    if (lmp->comm->me == 0)
dihedral_charmm.cpp:  if (comm->me == 0) {
dihedral_charmmfsw.cpp:  if (comm->me == 0) {
dihedral.cpp:      memory->create(eatom,comm->nthreads*maxeatom,"dihedral:eatom");
dihedral.cpp:      memory->create(vatom,comm->nthreads*maxvatom,6,"dihedral:vatom");
dihedral.cpp:      memory->create(cvatom,comm->nthreads*maxcvatom,9,"dihedral:cvatom");
dihedral.cpp:  double bytes = comm->nthreads*maxeatom * sizeof(double);
dihedral.cpp:  bytes += comm->nthreads*maxvatom*6 * sizeof(double);
dihedral.cpp:  bytes += comm->nthreads*maxcvatom*9 * sizeof(double);
dihedral_deprecated.cpp:    if (lmp->comm->me == 0)
dihedral_harmonic.cpp:  if (comm->me == 0) {
dihedral_helix.cpp:  if (comm->me == 0) {
dihedral_hybrid.cpp:  int me = comm->me;
dihedral_multi_harmonic.cpp:  if (comm->me == 0) {
dihedral_opls.cpp:  if (comm->me == 0) {
displace_atoms.cpp:  if (comm->me == 0) utils::logmesg(lmp,"Displacing atoms ...\n");
displace_atoms.cpp:  if (natoms != atom->natoms && comm->me == 0)
domain.cpp:      else if (comm->me == 0)
domain.cpp:   uses comm->xyz_split or comm->mysplit
domain.cpp:  if (comm->layout != Comm::LAYOUT_TILED) {
domain.cpp:    int *myloc = comm->myloc;
domain.cpp:    double *xsplit = comm->xsplit;
domain.cpp:    double *ysplit = comm->ysplit;
domain.cpp:    double *zsplit = comm->zsplit;
domain.cpp:    double (*mysplit)[2] = comm->mysplit;
domain.cpp:   uses comm->xyz_split or comm->mysplit
domain.cpp:  if (comm->layout != Comm::LAYOUT_TILED) {
domain.cpp:    int *myloc = comm->myloc;
domain.cpp:    int *procgrid = comm->procgrid;
domain.cpp:    double *xsplit = comm->xsplit;
domain.cpp:    double *ysplit = comm->ysplit;
domain.cpp:    double *zsplit = comm->zsplit;
domain.cpp:    double (*mysplit)[2] = comm->mysplit;
domain.cpp:  comm->forward_comm_array(3,unwrap);
domain.cpp:  if (flagall && comm->me == 0)
domain.cpp:    if (all && comm->me == 0)
domain.cpp:    if (all && comm->me == 0)
domain.cpp:  if (flagall && comm->me == 0)
domain.cpp:    since may lead to lost atoms in comm->exchange()
domain.cpp:  if (flagall && comm->me == 0)
domain.cpp:    if ((flag_all > 0) && (comm->me == 0))
domain.cpp:  if (comm->me == 0) {
dump_deprecated.cpp:    if (lmp->comm->me == 0)
dump_image.cpp:    comm->forward_comm_dump(this);
dump_movie.cpp:  if ((comm->me == 0) && (fp == nullptr)) {
finish.cpp:  const int nthreads = comm->nthreads;
fix_balance.cpp:  if (lbstyle == BISECTION && comm->style == 0)
fix_balance.cpp:   compute final imbalance factor based on nlocal after comm->exchange()
fix_balance.cpp:  // invoke balancer and reset comm->uniform flag
fix_balance.cpp:    comm->layout = Comm::LAYOUT_NONUNIFORM;
fix_balance.cpp:    comm->layout = Comm::LAYOUT_TILED;
fix_balance.cpp:  //   since may lead to lost atoms in comm->exchange()
fix_balance.cpp:  // else allow caller's comm->exchange() to do it
fix_balance.cpp:  //   b/c atoms may migrate again in comm->exchange()
fix_balance.cpp:  // can only be done after atoms migrate in comm->exchange()
fix_box_relax.cpp:    if (temperature->igroup != 0 && comm->me == 0)
fix_cmap.cpp:  if (comm->me == 0) {
fix_cmap.cpp:    if (comm->me == 0)
fix_cmap.cpp:  if (comm->me == 0) fclose(fp);
fix_cmap.cpp:  if (comm->me == 0) {
fix_deform.cpp:  if (comm->me == 0) {
fix_deprecated.cpp:    if (lmp->comm->me == 0)
fix_deprecated.cpp:    if (lmp->comm->me == 0)
fix_dt_reset.cpp:        strcmp(output->dump[i]->style,"xtc") == 0) && comm->me == 0)
fix_group.cpp:  if (warn && comm->me == 0)
fix_halt.cpp:    if (comm->me == 0 && msgflag == YESMSG) error->message(FLERR,message);
fix_langevin.cpp:  random = new RanMars(lmp,seed + comm->me);
fix_langevin.cpp:    if (temperature->igroup != igroup && comm->me == 0)
fix_move.cpp:  if (comm->me == 0) {
fix_neigh_history.cpp:    int nmypage = comm->nthreads;
fix_neigh_history.cpp:  comm->reverse_comm_fix(this,0);
fix_neigh_history.cpp:  comm->reverse_comm_fix_variable(this);
fix_neigh_history.cpp:  int nmypage = comm->nthreads;
fix_neigh_history.cpp:  if (comm->me == 0) {
fix_nh.cpp:  if (comm->me == 0) {
fix_nh.cpp:    if (temperature->igroup != 0 && comm->me == 0)
fix_nve_limit.cpp:      if (comm->me == 0)
fix_pour.cpp:        if (comm->layout != Comm::LAYOUT_TILED) {
fix_pour.cpp:          if (comm->myloc[2] == comm->procgrid[2]-1 &&
fix_pour.cpp:          if (comm->mysplit[2][1] == 1.0 &&
fix_pour.cpp:        if (comm->layout != Comm::LAYOUT_TILED) {
fix_pour.cpp:          if (comm->myloc[1] == comm->procgrid[1]-1 &&
fix_pour.cpp:          if (comm->mysplit[1][1] == 1.0 &&
fix_press_berendsen.cpp:    if (temperature->igroup != 0 && comm->me == 0)
fix_property_atom.cpp:    if (flag && comm->me == 0)
fix_recenter.cpp:  if (flag && comm->me == 0)
fix_restrain.cpp:                                   comm->me,update->ntimestep));
fix_restrain.cpp:                                   comm->me,update->ntimestep));
fix_restrain.cpp:                                   comm->me,update->ntimestep));
fix_restrain.cpp:                                   comm->me,update->ntimestep));
fix_restrain.cpp:                                   ids[m][2],comm->me,update->ntimestep));
fix_restrain.cpp:                                   ids[m][2],comm->me,update->ntimestep));
fix_restrain.cpp:                                   ids[m][2],ids[m][3],comm->me,
fix_restrain.cpp:                                   ids[m][2],ids[m][3],comm->me,
fix_restrain.cpp:                  comm->me,x[i1][0],x[i1][1],x[i1][2],
fix_restrain.cpp:                  comm->me,x[i2][0],x[i2][1],x[i2][2],
fix_restrain.cpp:                  comm->me,x[i3][0],x[i3][1],x[i3][2],
fix_restrain.cpp:                  comm->me,x[i4][0],x[i4][1],x[i4][2]);
fix_spring_chunk.cpp:  if (comm->me == 0) {
fix_spring_chunk.cpp:    if (comm->me == 0)
fix_spring_rg.cpp:  if (comm->me == 0) {
fix_store.cpp:  // PERATOM may be comm->exchanged before filled by caller
fix_store.cpp:  if (comm->me == 0) {
fix_temp_berendsen.cpp:    if (temperature->igroup != igroup && comm->me == 0)
fix_temp_berendsen.cpp:  if (comm->me == 0) {
fix_temp_csld.cpp:  random = new RanMars(lmp,seed + comm->me);
fix_temp_csld.cpp:    if (temperature->igroup != igroup && comm->me == 0)
fix_temp_csld.cpp:  int nsize = PRNGSIZE*comm->nprocs+2; // pRNG state per proc + nprocs + energy
fix_temp_csld.cpp:  if (comm->me == 0) {
fix_temp_csld.cpp:    list[1] = comm->nprocs;
fix_temp_csld.cpp:  if (comm->me == 0) {
fix_temp_csld.cpp:  if (nprocs != comm->nprocs) {
fix_temp_csld.cpp:    if (comm->me == 0)
fix_temp_csld.cpp:  } else random->set_state(list+2+comm->me*103);
fix_temp_csvr.cpp:  random = new RanMars(lmp,seed + comm->me);
fix_temp_csvr.cpp:  if (comm->me == 0) {
fix_temp_csvr.cpp:    if (temperature->igroup != igroup && comm->me == 0)
fix_temp_csvr.cpp:  int nsize = PRNGSIZE*comm->nprocs+2; // pRNG state per proc + nprocs + energy
fix_temp_csvr.cpp:  if (comm->me == 0) {
fix_temp_csvr.cpp:    list[1] = comm->nprocs;
fix_temp_csvr.cpp:  if (comm->me == 0) {
fix_temp_csvr.cpp:  if (nprocs != comm->nprocs) {
fix_temp_csvr.cpp:    if (comm->me == 0)
fix_temp_csvr.cpp:  } else random->set_state(list+2+comm->me*103);
fix_temp_rescale.cpp:    if (temperature->igroup != igroup && comm->me == 0)
fix_temp_rescale.cpp:  if (comm->me == 0) {
fix_wall_gran_region.cpp:  if (comm->me) return;
fix_wall_reflect.cpp:  if (nrigid && comm->me == 0)
force.cpp:  if (comm->me == 0) {
group.cpp:  // pass list to all other procs via comm->ring()
group.cpp:  comm->ring(n,sizeof(tagint),list,1,molring,nullptr,(void *)this);
group.cpp:   callback from comm->ring()
imbalance_neigh.cpp:    if (comm->me == 0 && !did_warn)
improper.cpp:      memory->create(eatom,comm->nthreads*maxeatom,"improper:eatom");
improper.cpp:      memory->create(vatom,comm->nthreads*maxvatom,6,"improper:vatom");
improper.cpp:      memory->create(cvatom,comm->nthreads*maxcvatom,9,"improper:cvatom");
improper.cpp:  double bytes = comm->nthreads*maxeatom * sizeof(double);
improper.cpp:  bytes += comm->nthreads*maxvatom*6 * sizeof(double);
improper_cvff.cpp:  if (comm->me == 0) {
improper_deprecated.cpp:    if (lmp->comm->me == 0)
improper_harmonic.cpp:  if (comm->me == 0) {
improper_hybrid.cpp:  int me = comm->me;
improper_umbrella.cpp:  if (comm->me == 0) {
info.cpp:  if (comm->me != 0) return;
info.cpp:               commstyles[comm->style], commlayout[comm->layout],
info.cpp:               comm->ghost_velocity ? "yes" : "no");
info.cpp:      if (comm->mode == 0)
info.cpp:                   comm->get_comm_cutoff());
info.cpp:      if (comm->mode == 1) {
info.cpp:          if (comm->cutusermulti) cut = MAX(cut,comm->cutusermulti[i]);
info.cpp:    fmt::print(out,"Nprocs = {},   Nthreads = {}\n",comm->nprocs,comm->nthreads);
info.cpp:      fmt::print(out,"Processor grid = {} x {} x {}\n",comm->procgrid[0],
info.cpp:                 comm->procgrid[1], comm->procgrid[2]);
info.cpp:    style = commstyles[comm->style];
info.cpp:    bytes += comm->memory_usage();
input.cpp:  comm->modify_params(narg,arg);
input.cpp:    if (comm->style == 0) return;
input.cpp:    if (comm->style == 1) return;
input.cpp:  comm->set_processors(narg,arg);
irregular.cpp:   can be used in place of comm->exchange()
irregular.cpp:  if (!preassign) comm->coord2proc_setup();
irregular.cpp:        mproclist[nsendatom] = comm->coord2proc(x[i],igx,igy,igz);
irregular.cpp:   if not, caller can decide to use comm->exchange() instead
irregular.cpp:  if (comm->layout == Comm::LAYOUT_TILED) return 1;
irregular.cpp:  // cannot check via comm->procneigh since it ignores PBC
irregular.cpp:  int *myloc = comm->myloc;
irregular.cpp:  int *procgrid = comm->procgrid;
irregular.cpp:      comm->coord2proc(x[i],igx,igy,igz);
kspace.cpp:  if ((qsqsum == 0.0) && (comm->me == 0) && warn_nocharge && warning_flag) {
kspace.cpp:    if (warn_nonneutral == 1 && comm->me == 0) error->warning(FLERR,message);
kspace.cpp:  if (comm->me == 0) {
kspace.cpp:    if ((table_accuracy > spr) && (comm->me == 0))
kspace.cpp:        if (slab_volfactor < 2.0 && comm->me == 0)
kspace_deprecated.cpp:    if (lmp->comm->me == 0)
lammps.cpp:  const int me = comm->me;
lammps.cpp:  comm->init();          // comm must come after force, modify, neighbor, atom
lattice.cpp:  if (comm->me == 0)
library.cpp:        && (lmp->comm->me == 0)) {
library.cpp:        && (lmp->comm->me == 0)) {
library.cpp:    lmp->comm->set_proc_grid();
library.cpp:  if (strcmp(keyword,"world_rank") == 0) return lmp->comm->me;
library.cpp:  if (strcmp(keyword,"world_size") == 0) return lmp->comm->nprocs;
library.cpp:  if (strcmp(keyword,"nthreads") == 0) return lmp->comm->nthreads;
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:    int nprocs = lmp->comm->nprocs;
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:    int nprocs = lmp->comm->nprocs;
library.cpp:      if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:        if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0)
library.cpp:      if (lmp->comm->me == 0) lmp->error->warning(FLERR,msg);
min.cpp:    if (comm->me == 0)
min.cpp:  if (comm->me == 0 && screen) {
min.cpp:    if (comm->me == 0 && screen)
min.cpp:  comm->setup();
min.cpp:  comm->exchange();
min.cpp:  comm->borders();
min.cpp:  // atoms may have migrated in comm->exchange()
min.cpp:  if (force->newton) comm->reverse_comm();
min.cpp:    comm->setup();
min.cpp:    comm->exchange();
min.cpp:    comm->borders();
min.cpp:  // atoms may have migrated in comm->exchange()
min.cpp:  if (force->newton) comm->reverse_comm();
min.cpp:    comm->forward_comm();
min.cpp:      comm->setup();
min.cpp:    comm->exchange();
min.cpp:    comm->borders();
min.cpp:    comm->reverse_comm();
min_fire.cpp:  if (comm->me == 0 && logfile) {
modify.cpp:  if (comm->me == 0 && checkall)
modify.cpp:    if (fix[ifix]->igroup != igroup && comm->me == 0)
modify.cpp:      if (comm->me == 0)
modify.cpp:      if (comm->me == 0)
modify.cpp:  int me = comm->me;
modify.cpp:  int me = comm->me;
modify.cpp:    if (flag && comm->me == 0) {
modify.cpp:    if (flag && comm->me == 0) {
molecule.cpp:  me = comm->me;
nbin_multi.cpp:  // bsubbox lo/hi = bounding box of my subdomain extended by comm->cutghost
nbin_multi.cpp:  //   include dimension-dependent extension via comm->cutghost
nbin_multi.cpp:  double *cutghost = comm->cutghost;
nbin_standard.cpp:  // bsubbox lo/hi = bounding box of my subdomain extended by comm->cutghost
nbin_standard.cpp:  //   include dimension-dependent extension via comm->cutghost
nbin_standard.cpp:  double *cutghost = comm->cutghost;
neighbor.cpp:  if (!same && comm->me == 0) print_pairwise_info();
neighbor.cpp:  if (comm->me == 0) printf("SAME flag %d\n",same);
neighbor.cpp:  const double cutghost = MAX(cutneighmax,comm->cutghostuser);
neigh_list.cpp:  int nmypage = comm->nthreads;
neigh_list.cpp:  if (comm->me != 0) return;
neigh_list.cpp:  int nmypage = comm->nthreads;
ntopo.cpp:  me = comm->me;
ntopo.cpp:  nprocs = comm->nprocs;
output.cpp:  if (thermo->modified && comm->me == 0)
output.cpp:  if (strchr(arg[1],'%')) multiproc = comm->nprocs;
output.cpp:  mbavg /= comm->nprocs;
output.cpp:  if (comm->me == 0)
pair_beck.cpp:  int me = comm->me;
pair_beck.cpp:  int me = comm->me;
pair_born_coul_dsf.cpp:  int me = comm->me;
pair_born_coul_dsf.cpp:  if (comm->me == 0) {
pair_born_coul_wolf.cpp:  int me = comm->me;
pair_born_coul_wolf.cpp:  if (comm->me == 0) {
pair_born.cpp:  int me = comm->me;
pair_born.cpp:  if (comm->me == 0) {
pair_brownian.cpp:  random = new RanMars(lmp,seed + comm->me);
pair_brownian.cpp:  if (force->newton_pair == 0 && comm->me == 0)
pair_brownian.cpp:  int me = comm->me;
pair_brownian.cpp:  int me = comm->me;
pair_brownian.cpp:  random = new RanMars(lmp,seed + comm->me);
pair_buck_coul_cut.cpp:  int me = comm->me;
pair_buck_coul_cut.cpp:  if (comm->me == 0) {
pair_buck.cpp:  int me = comm->me;
pair_buck.cpp:  if (comm->me == 0) {
pair_colloid.cpp:      if (comm->me == 0) utils::sfread(FLERR,&setflag[i][j],sizeof(int),1,fp,nullptr,error);
pair_colloid.cpp:        if (comm->me == 0) {
pair_colloid.cpp:  int me = comm->me;
pair_coul_cut.cpp:  int me = comm->me;
pair_coul_cut.cpp:  if (comm->me == 0) {
pair_coul_debye.cpp:  if (comm->me == 0) {
pair_coul_dsf.cpp:  int me = comm->me;
pair_coul_dsf.cpp:  if (comm->me == 0) {
pair_coul_streitz.cpp:  if (comm->me == 0) {
pair_coul_streitz.cpp:  if (comm->me != 0) {
pair_coul_wolf.cpp:  int me = comm->me;
pair_coul_wolf.cpp:  if (comm->me == 0) {
pair.cpp:  if (tail_flag && domain->nonperiodic && comm->me == 0)
pair.cpp:  if (!compute_flag && tail_flag && comm->me == 0)
pair.cpp:  if (!compute_flag && offset_flag && comm->me == 0)
pair.cpp:    if (flag && comm->me == 0)
pair.cpp:  if (comm->me == 0)
pair.cpp:  if (comm->me == 0)
pair.cpp:      memory->create(eatom,comm->nthreads*maxeatom,"pair:eatom");
pair.cpp:      memory->create(vatom,comm->nthreads*maxvatom,6,"pair:vatom");
pair.cpp:      memory->create(cvatom,comm->nthreads*maxcvatom,9,"pair:cvatom");
pair.cpp:  if (comm->me == 0) {
pair.cpp:  if ((comm->me == 0) && (epair))
pair.cpp:    if (comm->me == 0)
pair.cpp:    if (comm->me == 0) fprintf(fp,"%d %.15g %.15g %.15g\n",i+1,r,e,f);
pair.cpp:  if (comm->me == 0) fclose(fp);
pair.cpp:  double bytes = comm->nthreads*maxeatom * sizeof(double);
pair.cpp:  bytes += comm->nthreads*maxvatom*6 * sizeof(double);
pair.cpp:  bytes += comm->nthreads*maxcvatom*9 * sizeof(double);
pair_deprecated.cpp:    if (lmp->comm->me == 0)
pair_deprecated.cpp:    if (lmp->comm->me == 0)
pair_dpd.cpp:  random = new RanMars(lmp,seed + comm->me);
pair_dpd.cpp:  if (comm->ghost_velocity == 0)
pair_dpd.cpp:  if (force->newton_pair == 0 && comm->me == 0) error->warning(FLERR,
pair_dpd.cpp:  int me = comm->me;
pair_dpd.cpp:  if (comm->me == 0) {
pair_dpd.cpp:  random = new RanMars(lmp,seed + comm->me);
pair_dpd_tstat.cpp:  random = new RanMars(lmp,seed + comm->me);
pair_dpd_tstat.cpp:  int me = comm->me;
pair_dpd_tstat.cpp:  if (comm->me == 0) {
pair_dpd_tstat.cpp:  random = new RanMars(lmp,seed + comm->me);
pair_gauss.cpp:  int me = comm->me;
pair_gauss.cpp:  if (comm->me == 0) {
pair_gran_hertz_history.cpp:    comm->forward_comm_pair(this);
pair_gran_hooke.cpp:    comm->forward_comm_pair(this);
pair_gran_hooke_history.cpp:    comm->forward_comm_pair(this);
pair_gran_hooke_history.cpp:  if (comm->ghost_velocity == 0)
pair_gran_hooke_history.cpp:  int me = comm->me;
pair_gran_hooke_history.cpp:  if (comm->me == 0) {
pair_granular.cpp:    comm->forward_comm_pair(this);
pair_granular.cpp:  if (comm->ghost_velocity == 0)
pair_granular.cpp:  int me = comm->me;
pair_hybrid.cpp:  int me = comm->me;
pair_lj96_cut.cpp:  int me = comm->me;
pair_lj96_cut.cpp:  int me = comm->me;
pair_lj_charmm_coul_charmm.cpp:  int me = comm->me;
pair_lj_charmm_coul_charmm.cpp:  if (comm->me == 0) {
pair_lj_charmmfsw_coul_charmmfsh.cpp:    if ((comm->me == 0) && (force->qqr2e != force->qqr2e_charmm_real))
pair_lj_charmmfsw_coul_charmmfsh.cpp:    if ((comm->me == 0) && (force->qqr2e == force->qqr2e_charmm_real))
pair_lj_charmmfsw_coul_charmmfsh.cpp:  int me = comm->me;
pair_lj_charmmfsw_coul_charmmfsh.cpp:  if (comm->me == 0) {
pair_lj_cubic.cpp:  int me = comm->me;
pair_lj_cubic.cpp:  int me = comm->me;
pair_lj_cut_coul_cut.cpp:  int me = comm->me;
pair_lj_cut_coul_cut.cpp:  if (comm->me == 0) {
pair_lj_cut_coul_debye.cpp:  if (comm->me == 0) {
pair_lj_cut_coul_dsf.cpp:  int me = comm->me;
pair_lj_cut_coul_dsf.cpp:  if (comm->me == 0) {
pair_lj_cut_coul_wolf.cpp:  int me = comm->me;
pair_lj_cut_coul_wolf.cpp:  int me = comm->me;
pair_lj_cut.cpp:  int me = comm->me;
pair_lj_cut.cpp:  int me = comm->me;
pair_lj_cut_tip4p_cut.cpp:  int me = comm->me;
pair_lj_cut_tip4p_cut.cpp:  if (comm->me == 0) {
pair_lj_expand.cpp:  int me = comm->me;
pair_lj_expand.cpp:  if (comm->me == 0) {
pair_lj_gromacs_coul_gromacs.cpp:  int me = comm->me;
pair_lj_gromacs_coul_gromacs.cpp:  if (comm->me == 0) {
pair_lj_gromacs.cpp:  int me = comm->me;
pair_lj_gromacs.cpp:  int me = comm->me;
pair_lj_smooth.cpp:  int me = comm->me;
pair_lj_smooth.cpp:  int me = comm->me;
pair_lj_smooth_linear.cpp:  int me = comm->me;
pair_lj_smooth_linear.cpp:  int me = comm->me;
pair_lubricate.cpp:    // no need to do this if not shearing since comm->ghost_velocity is set
pair_lubricate.cpp:    comm->forward_comm_pair(this);
pair_lubricate.cpp:  if (comm->ghost_velocity == 0)
pair_lubricate.cpp:  int me = comm->me;
pair_lubricate.cpp:  int me = comm->me;
pair_lubricate_poly.cpp:    // no need to do this if not shearing since comm->ghost_velocity is set
pair_lubricate_poly.cpp:    comm->forward_comm_pair(this);
pair_lubricate_poly.cpp:  if (comm->ghost_velocity == 0)
pair_lubricateU.cpp:  if (newton_pair) comm->reverse_comm();
pair_lubricateU.cpp:  comm->forward_comm_pair(this);
pair_lubricateU.cpp:  if (newton_pair) comm->reverse_comm();
pair_lubricateU.cpp:    comm->forward_comm_pair(this);
pair_lubricateU.cpp:    if (newton_pair) comm->reverse_comm();
pair_lubricateU.cpp:  comm->forward_comm_pair(this);
pair_lubricateU.cpp:  if (newton_pair) comm->reverse_comm();
pair_lubricateU.cpp:  comm->forward_comm_pair(this);
pair_lubricateU.cpp:  if (newton_pair) comm->reverse_comm();
pair_lubricateU.cpp:    comm->forward_comm_pair(this);
pair_lubricateU.cpp:    if (newton_pair) comm->reverse_comm();
pair_lubricateU.cpp:  comm->forward_comm_pair(this);
pair_lubricateU.cpp:  if (newton_pair) comm->reverse_comm(); // not really needed
pair_lubricateU.cpp:  if (comm->ghost_velocity == 0)
pair_lubricateU.cpp:  int me = comm->me;
pair_lubricateU.cpp:  int me = comm->me;
pair_lubricateU_poly.cpp:  if (newton_pair) comm->reverse_comm();
pair_lubricateU_poly.cpp:  comm->forward_comm_pair(this);
pair_lubricateU_poly.cpp:  if (newton_pair) comm->reverse_comm();
pair_lubricateU_poly.cpp:    comm->forward_comm_pair(this);
pair_lubricateU_poly.cpp:    if (newton_pair) comm->reverse_comm();
pair_lubricateU_poly.cpp:  comm->forward_comm_pair(this);
pair_lubricateU_poly.cpp:  if (newton_pair) comm->reverse_comm(); // not really needed
pair_lubricateU_poly.cpp:  if (comm->ghost_velocity == 0)
pair_lubricateU_poly.cpp:  if (!comm->me) {
pair_mie_cut.cpp:  int me = comm->me;
pair_mie_cut.cpp:  int me = comm->me;
pair_morse.cpp:  int me = comm->me;
pair_morse.cpp:  if (comm->me == 0) {
pair_soft.cpp:  int me = comm->me;
pair_soft.cpp:  if (comm->me == 0) {
pair_table.cpp:  if (comm->me == 0) {
pair_tip4p_cut.cpp:  int me = comm->me;
pair_tip4p_cut.cpp:  if (comm->me == 0) {
pair_ufm.cpp:  int me = comm->me;
pair_ufm.cpp:  int me = comm->me;
pair_yukawa.cpp:  int me = comm->me;
pair_yukawa.cpp:  if (comm->me == 0) {
pair_zbl.cpp:  int me = comm->me;
pair_zbl.cpp:  int me = comm->me;
pair_zero.cpp:  int me = comm->me;
pair_zero.cpp:  int me = comm->me;
potential_file_reader.cpp:  if (comm->me != 0) {
random_mars.cpp:    //if (comm->me == 0) printf("%d %ld %ld %g %ld\n",
read_data.cpp:      if (comm->nprocs == 1) n = static_cast<int> (atom->natoms);
read_data.cpp:      else n = static_cast<int> (LB_FACTOR * atom->natoms / comm->nprocs);
read_data.cpp:      comm->set_proc_grid();
read_data.cpp:      comm->set_proc_grid();
read_data.cpp:  // do comm->init() but not comm->setup() b/c pair/neigh cutoffs not yet set
read_data.cpp:  // need call to map_set() b/c comm->exchange clears atom map
read_data.cpp:  if (comm->me == 0)
read_data.cpp:    eof = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
read_data.cpp:    eof = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
read_data.cpp:    eof = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
read_data.cpp:    eof = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
read_data.cpp:    eof = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
read_data.cpp:    eof = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
read_data.cpp:    eof = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
read_data.cpp:  int eof = comm->read_lines_from_file(fp,ntypes,MAXLINE,buf);
read_data.cpp:  int eof = comm->read_lines_from_file(fp,ntypes,MAXLINE,buf);
read_data.cpp:  int eof = comm->read_lines_from_file(fp,nsq,MAXLINE,buf);
read_data.cpp:  int eof = comm->read_lines_from_file(fp,nbondtypes,MAXLINE,buf);
read_data.cpp:  int eof = comm->read_lines_from_file(fp,nangletypes,MAXLINE,buf);
read_data.cpp:  int eof = comm->read_lines_from_file(fp,ndihedraltypes,MAXLINE,buf);
read_data.cpp:  int eof = comm->read_lines_from_file(fp,nimpropertypes,MAXLINE,buf);
read_data.cpp:    eof = comm->read_lines_from_file(fp,nchunk,MAXLINE,buffer);
read_dump.cpp:    comm->set_proc_grid(0);
read_restart.cpp:  comm->set_proc_grid();
read_restart.cpp:  if (comm->me == 0)
read_restart.cpp:      if (nprocs_file != comm->nprocs && me == 0)
read_restart.cpp:                                         comm->nprocs));
read_restart.cpp:      if (comm->user_procgrid[0] != 0 &&
read_restart.cpp:          procgrid[0] != comm->user_procgrid[0]) flag = 1;
read_restart.cpp:      if (comm->user_procgrid[1] != 0 &&
read_restart.cpp:          procgrid[1] != comm->user_procgrid[1]) flag = 1;
read_restart.cpp:      if (comm->user_procgrid[2] != 0 &&
read_restart.cpp:          procgrid[2] != comm->user_procgrid[2]) flag = 1;
read_restart.cpp:      if (comm->me ==0)
read_restart.cpp:      comm->mode = read_int();
read_restart.cpp:      comm->cutghostuser = read_double();
read_restart.cpp:      comm->ghost_velocity = read_int();
read_restart.cpp:      if (comm->me ==0)
read_restart.cpp:      if (comm->me ==0)
read_restart.cpp:      if (comm->me ==0)
read_restart.cpp:      if (comm->me ==0)
read_restart.cpp:      if (comm->me ==0)
read_restart.cpp:      if (comm->me ==0)
region_deprecated.cpp:    if (lmp->comm->me == 0)
replicate.cpp:  int me = comm->me;
replicate.cpp:  int nprocs = comm->nprocs;
replicate.cpp:    if (comm->me == 0)
replicate.cpp:  comm->set_proc_grid();
replicate.cpp:  if (comm->layout != Comm::LAYOUT_TILED) {
replicate.cpp:      if (comm->myloc[0] == 0) sublo[0] -= epsilon[0];
replicate.cpp:      if (comm->myloc[0] == comm->procgrid[0]-1) subhi[0] += epsilon[0];
replicate.cpp:      if (comm->myloc[1] == 0) sublo[1] -= epsilon[1];
replicate.cpp:      if (comm->myloc[1] == comm->procgrid[1]-1) subhi[1] += epsilon[1];
replicate.cpp:      if (comm->myloc[2] == 0) sublo[2] -= epsilon[2];
replicate.cpp:      if (comm->myloc[2] == comm->procgrid[2]-1) subhi[2] += epsilon[2];
replicate.cpp:      if (comm->mysplit[0][0] == 0.0) sublo[0] -= epsilon[0];
replicate.cpp:      if (comm->mysplit[0][1] == 1.0) subhi[0] += epsilon[0];
replicate.cpp:      if (comm->mysplit[1][0] == 0.0) sublo[1] -= epsilon[1];
replicate.cpp:      if (comm->mysplit[1][1] == 1.0) subhi[1] += epsilon[1];
replicate.cpp:      if (comm->mysplit[2][0] == 0.0) sublo[2] -= epsilon[2];
replicate.cpp:      if (comm->mysplit[2][1] == 1.0) subhi[2] += epsilon[2];
reset_atom_ids.cpp:  if (comm->me == 0) utils::logmesg(lmp,"Resetting atom IDs ...\n");
reset_atom_ids.cpp:  // initialize system since comm->borders() will be invoked
reset_atom_ids.cpp:  comm->setup();
reset_atom_ids.cpp:  comm->exchange();
reset_atom_ids.cpp:  comm->borders();
reset_atom_ids.cpp:  comm->forward_comm_array(1,newIDs);
reset_atom_ids.cpp:  int me = comm->me;
reset_atom_ids.cpp:  int nprocs = comm->nprocs;
reset_atom_ids.cpp:  int nreturn = comm->rendezvous(1,nlocal,(char *) atombuf,sizeof(AtomRvous),
reset_atom_ids.cpp:      //             rptr->comm->me,i,n,in[i].ibin,binlo,binhi);
reset_atom_ids.cpp:  // pass outbuf of IDRvous datums back to comm->rendezvous
reset_mol_ids.cpp:  if (comm->me == 0) utils::logmesg(lmp,"Resetting molecule IDs ...\n");
reset_mol_ids.cpp:  // initialize system since comm->borders() will be invoked
reset_mol_ids.cpp:  comm->setup();
reset_mol_ids.cpp:  comm->exchange();
reset_mol_ids.cpp:  comm->borders();
reset_mol_ids.cpp:  if (comm->me == 0) {
respa.cpp:  if (comm->me == 0) {
respa.cpp:  if (flag && comm->me == 0)
respa.cpp:  if (modify->nfix == 0 && comm->me == 0)
respa.cpp:  if (comm->me == 0 && screen) {
respa.cpp:  comm->setup();
respa.cpp:  comm->exchange();
respa.cpp:  comm->borders();
respa.cpp:    if (newton[ilevel]) comm->reverse_comm();
respa.cpp:    comm->setup();
respa.cpp:    comm->exchange();
respa.cpp:    comm->borders();
respa.cpp:    if (newton[ilevel]) comm->reverse_comm();
respa.cpp:          comm->setup();
respa.cpp:        comm->exchange();
respa.cpp:        comm->borders();
respa.cpp:        comm->forward_comm();
respa.cpp:      comm->forward_comm();
respa.cpp:      comm->reverse_comm();
set.cpp:  if (comm->me == 0) utils::logmesg(lmp,"Setting atom values ...\n");
set.cpp:    if (comm->me == 0) {
set.cpp:  RanMars *ranmars = new RanMars(lmp,seed + comm->me);
set.cpp:  // init entire system since comm->exchange is done
set.cpp:  if (comm->me == 0) utils::logmesg(lmp,"  system init for set ...\n");
set.cpp:  comm->setup();
set.cpp:  comm->exchange();
set.cpp:  comm->borders();
special.cpp:  comm->rendezvous(RVOUS,nlocal,(char *) idbuf,sizeof(IDRvous),0,proclist,
special.cpp:  int nreturn = comm->rendezvous(RVOUS,nsend,(char *) inbuf,sizeof(PairRvous),
special.cpp:  int nreturn = comm->rendezvous(RVOUS,nsend,(char *) inbuf,sizeof(PairRvous),
special.cpp:  int nreturn = comm->rendezvous(RVOUS,nsend,(char *) inbuf,sizeof(PairRvous),
special.cpp:    int nreturn = comm->rendezvous(RVOUS,nsend,(char *) inbuf,sizeof(PairRvous),
special.cpp:    int nreturn = comm->rendezvous(RVOUS,nsend,(char *) inbuf,sizeof(PairRvous),
special.cpp:  if (comm->me == 0)
